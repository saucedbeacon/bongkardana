package o;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import o.JavaSCLogCatImpl;
import o.MonitorPrinterFactory;
import o.SCLogCatInterface;
import o.getSCLog;
import o.isAndroidMPaaSPlatform;
import o.printLog;
import o.setLogImpl;

public final class systemOut implements setEncryptRandomStringAndType {
    private static final Set<Class<? extends SCNetworkAsyncTaskExecutorFactory>> getMax = new LinkedHashSet(Arrays.asList(new Class[]{getAlphabet.class, encodeToFile.class, decodeToObject.class, decodeFromFile.class, stringUtf8.class, Base64$1.class, encodeFromFile.class}));
    private static final Map<Class<? extends SCNetworkAsyncTaskExecutorFactory>, setOnConfirmListener> getMin;
    private final List<setOnConfirmListener> FastBitmap$CoordinateSystem;
    private int IsOverlapping = 0;
    private Map<Base64$OutputStream, Boolean> Mean$Arithmetic = new HashMap();
    private boolean equals;
    private List<setOnFocusChangeListener> hashCode = new ArrayList();
    private int isInside = 0;
    private CharSequence length;
    private int setMax = 0;
    private int setMin = 0;
    private Set<setOnFocusChangeListener> toDoubleRange = new HashSet();
    private int toFloatRange = 0;
    private boolean toIntRange;
    private final asciiBytes toString;
    private final createMPaaSMonitorPrinter values;

    static {
        HashMap hashMap = new HashMap();
        hashMap.put(getAlphabet.class, new isAndroidMPaaSPlatform.getMin());
        hashMap.put(encodeToFile.class, new printLog.getMin());
        hashMap.put(decodeToObject.class, new JavaSCLogCatImpl.length());
        hashMap.put(decodeFromFile.class, new SCLogCatInterface.length());
        hashMap.put(stringUtf8.class, new MonitorPrinterFactory.length());
        hashMap.put(Base64$1.class, new setLogImpl.getMin());
        hashMap.put(encodeFromFile.class, new getSCLog.length());
        getMin = Collections.unmodifiableMap(hashMap);
    }

    public systemOut(List<setOnConfirmListener> list, asciiBytes asciibytes) {
        this.FastBitmap$CoordinateSystem = list;
        this.toString = asciibytes;
        createMPaaSMonitorPrinter creatempaasmonitorprinter = new createMPaaSMonitorPrinter();
        this.values = creatempaasmonitorprinter;
        this.hashCode.add(creatempaasmonitorprinter);
        this.toDoubleRange.add(creatempaasmonitorprinter);
    }

    public static Set<Class<? extends SCNetworkAsyncTaskExecutorFactory>> getMin() {
        return getMax;
    }

    public static List<setOnConfirmListener> setMax(List<setOnConfirmListener> list, Set<Class<? extends SCNetworkAsyncTaskExecutorFactory>> set) {
        ArrayList arrayList = new ArrayList();
        arrayList.addAll(list);
        for (Class<? extends SCNetworkAsyncTaskExecutorFactory> cls : set) {
            arrayList.add(getMin.get(cls));
        }
        return arrayList;
    }

    public final encodeBytesToBytes length(String str) {
        int i = 0;
        while (true) {
            int max = SSLExtensions.getMax(str, i);
            if (max == -1) {
                break;
            }
            setMin((CharSequence) new SCNetworkAsyncTaskUtil(str, i, max));
            i = max + 1;
            if (i < str.length() && str.charAt(max) == 13 && str.charAt(i) == 10) {
                i = max + 2;
            }
        }
        if (str.length() > 0 && (i == 0 || i < str.length())) {
            setMin((CharSequence) new SCNetworkAsyncTaskUtil(str, i, str.length()));
        }
        getMax(this.hashCode);
        for (setOnFocusChangeListener max2 : this.toDoubleRange) {
            max2.getMax(this.toString);
        }
        return this.values.length;
    }

    public final CharSequence getMax() {
        return this.length;
    }

    public final int setMin() {
        return this.setMax;
    }

    public final int setMax() {
        return this.IsOverlapping;
    }

    public final int length() {
        return this.setMin;
    }

    public final int toFloatRange() {
        return this.isInside;
    }

    public final boolean toIntRange() {
        return this.toIntRange;
    }

    public final setOnFocusChangeListener equals() {
        List<setOnFocusChangeListener> list = this.hashCode;
        return list.get(list.size() - 1);
    }

    private void setMin(CharSequence charSequence) {
        this.length = SSLExtensions.setMax(charSequence);
        this.setMax = 0;
        this.setMin = 0;
        this.equals = false;
        List<setOnFocusChangeListener> list = this.hashCode;
        int i = 1;
        for (setOnFocusChangeListener next : list.subList(1, list.size())) {
            isInside();
            setRsaPublicKey max = next.setMax((setEncryptRandomStringAndType) this);
            if (!(max instanceof isAndroidPlatform)) {
                break;
            }
            isAndroidPlatform isandroidplatform = (isAndroidPlatform) max;
            if (isandroidplatform.setMin()) {
                getMin(next);
                return;
            }
            if (isandroidplatform.setMax != -1) {
                getMax(isandroidplatform.setMax);
            } else if (isandroidplatform.length != -1) {
                length(isandroidplatform.length);
            }
            i++;
        }
        List<setOnFocusChangeListener> list2 = this.hashCode;
        ArrayList arrayList = new ArrayList(list2.subList(i, list2.size()));
        setOnFocusChangeListener setonfocuschangelistener = this.hashCode.get(i - 1);
        boolean isEmpty = arrayList.isEmpty();
        boolean z = (setonfocuschangelistener.getMax() instanceof suspendEncoding) || setonfocuschangelistener.length();
        setOnFocusChangeListener setonfocuschangelistener2 = setonfocuschangelistener;
        while (true) {
            if (!z) {
                break;
            }
            isInside();
            if (toIntRange() || (this.isInside < SSLExtensions.setMax && SSLExtensions.getMin(this.length, this.IsOverlapping))) {
                getMax(this.IsOverlapping);
            } else {
                createAndroidMPaaSLogImpl max2 = setMax(setonfocuschangelistener2);
                if (max2 == null) {
                    getMax(this.IsOverlapping);
                    break;
                }
                if (!isEmpty) {
                    getMax((List<setOnFocusChangeListener>) arrayList);
                    isEmpty = true;
                }
                if (max2.getMin != -1) {
                    getMax(max2.getMin);
                } else if (max2.length != -1) {
                    length(max2.length);
                }
                if (max2.setMax()) {
                    List<setOnFocusChangeListener> list3 = this.hashCode;
                    setOnFocusChangeListener setonfocuschangelistener3 = list3.get(list3.size() - 1);
                    List<setOnFocusChangeListener> list4 = this.hashCode;
                    list4.remove(list4.size() - 1);
                    this.toDoubleRange.remove(setonfocuschangelistener3);
                    setonfocuschangelistener3.getMax().toIntRange();
                }
                for (setOnFocusChangeListener setonfocuschangelistener4 : max2.setMin) {
                    setonfocuschangelistener2 = setMin(setonfocuschangelistener4);
                    z = setonfocuschangelistener4.length();
                }
            }
        }
        if (!isEmpty && !toIntRange()) {
            List<setOnFocusChangeListener> list5 = this.hashCode;
            if (list5.get(list5.size() - 1) instanceof SCLogCatUtil) {
                values();
                return;
            }
        }
        if (!isEmpty) {
            getMax((List<setOnFocusChangeListener>) arrayList);
        }
        getMin(setonfocuschangelistener2, setonfocuschangelistener);
        if (!setonfocuschangelistener2.length()) {
            values();
        } else if (!toIntRange()) {
            setMin(new SCLogCatUtil());
            values();
        }
    }

    private void isInside() {
        int i = this.setMax;
        int i2 = this.setMin;
        this.toIntRange = true;
        while (true) {
            if (i >= this.length.length()) {
                break;
            }
            char charAt = this.length.charAt(i);
            if (charAt == 9) {
                i++;
                i2 += 4 - (i2 % 4);
            } else if (charAt != ' ') {
                this.toIntRange = false;
                break;
            } else {
                i++;
                i2++;
            }
        }
        this.IsOverlapping = i;
        this.toFloatRange = i2;
        this.isInside = i2 - this.setMin;
    }

    private void getMax(int i) {
        int i2 = this.IsOverlapping;
        if (i >= i2) {
            this.setMax = i2;
            this.setMin = this.toFloatRange;
        }
        while (true) {
            int i3 = this.setMax;
            if (i3 >= i || i3 == this.length.length()) {
                this.equals = false;
            } else {
                IsOverlapping();
            }
        }
        this.equals = false;
    }

    private void length(int i) {
        int i2 = this.toFloatRange;
        if (i >= i2) {
            this.setMax = this.IsOverlapping;
            this.setMin = i2;
        }
        while (this.setMin < i && this.setMax != this.length.length()) {
            IsOverlapping();
        }
        if (this.setMin > i) {
            this.setMax--;
            this.setMin = i;
            this.equals = true;
            return;
        }
        this.equals = false;
    }

    private void IsOverlapping() {
        if (this.length.charAt(this.setMax) == 9) {
            this.setMax++;
            int i = this.setMin;
            this.setMin = i + SSLExtensions.setMin(i);
            return;
        }
        this.setMax++;
        this.setMin++;
    }

    private void values() {
        CharSequence charSequence;
        if (this.equals) {
            CharSequence charSequence2 = this.length;
            CharSequence subSequence = charSequence2.subSequence(this.setMax + 1, charSequence2.length());
            int min = SSLExtensions.setMin(this.setMin);
            StringBuilder sb = new StringBuilder(subSequence.length() + min);
            for (int i = 0; i < min; i++) {
                sb.append(' ');
            }
            sb.append(subSequence);
            charSequence = sb.toString();
        } else {
            CharSequence charSequence3 = this.length;
            charSequence = charSequence3.subSequence(this.setMax, charSequence3.length());
        }
        List<setOnFocusChangeListener> list = this.hashCode;
        list.get(list.size() - 1).getMax(charSequence);
    }

    private createAndroidMPaaSLogImpl setMax(setOnFocusChangeListener setonfocuschangelistener) {
        getMin getmin = new getMin(setonfocuschangelistener);
        for (setOnConfirmListener length2 : this.FastBitmap$CoordinateSystem) {
            setNeedConfirmButton length3 = length2.length(this, getmin);
            if (length3 instanceof createAndroidMPaaSLogImpl) {
                return (createAndroidMPaaSLogImpl) length3;
            }
        }
        return null;
    }

    private boolean getMax(Base64$OutputStream base64$OutputStream) {
        while (base64$OutputStream != null) {
            if (length(base64$OutputStream)) {
                return true;
            }
            if (!(base64$OutputStream instanceof Base64$1) && !(base64$OutputStream instanceof flushBase64)) {
                return false;
            }
            base64$OutputStream = base64$OutputStream.toFloatRange;
        }
        return false;
    }

    private void getMin(setOnFocusChangeListener setonfocuschangelistener, setOnFocusChangeListener setonfocuschangelistener2) {
        if (toIntRange() && setonfocuschangelistener.getMax().toFloatRange != null) {
            this.Mean$Arithmetic.put(setonfocuschangelistener.getMax().toFloatRange, Boolean.TRUE);
        }
        SCNetworkAsyncTaskExecutorFactory max = setonfocuschangelistener.getMax();
        boolean z = toIntRange() && !(max instanceof getAlphabet) && !(max instanceof decodeToObject) && (!(max instanceof flushBase64) || max.toIntRange != null || setonfocuschangelistener == setonfocuschangelistener2);
        for (Base64$OutputStream max2 = setonfocuschangelistener.getMax(); max2 != null; max2 = max2.getMin()) {
            this.Mean$Arithmetic.put(max2, Boolean.valueOf(z));
        }
    }

    private boolean length(Base64$OutputStream base64$OutputStream) {
        Boolean bool = this.Mean$Arithmetic.get(base64$OutputStream);
        return bool != null && bool.booleanValue();
    }

    private boolean getMax(List<setOnFocusChangeListener> list) {
        for (int size = list.size() - 1; size >= 0; size--) {
            getMin(list.get(size));
        }
        return true;
    }

    static class getMin implements SafeInputContext {
        private final setOnFocusChangeListener getMax;

        public getMin(setOnFocusChangeListener setonfocuschangelistener) {
            this.getMax = setonfocuschangelistener;
        }

        public final setOnFocusChangeListener getMax() {
            return this.getMax;
        }

        public final CharSequence getMin() {
            setOnFocusChangeListener setonfocuschangelistener = this.getMax;
            if (setonfocuschangelistener instanceof SCLogCatUtil) {
                return ((SCLogCatUtil) setonfocuschangelistener).getMax.getMax.toString();
            }
            return null;
        }
    }

    private void getMin(setOnFocusChangeListener setonfocuschangelistener) {
        List<setOnFocusChangeListener> list = this.hashCode;
        if (list.get(list.size() - 1) == setonfocuschangelistener) {
            List<setOnFocusChangeListener> list2 = this.hashCode;
            list2.remove(list2.size() - 1);
        }
        setonfocuschangelistener.I_();
        if (setonfocuschangelistener instanceof SCLogCatUtil) {
            asciiBytes asciibytes = this.toString;
            if (asciibytes instanceof MonitorPrinter) {
                ((SCLogCatUtil) setonfocuschangelistener).setMax((MonitorPrinter) asciibytes);
                return;
            }
        }
        if (setonfocuschangelistener instanceof setLogImpl) {
            length((setLogImpl) setonfocuschangelistener);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:16:0x0028, code lost:
        r5.length.setMin = false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void length(o.setLogImpl r5) {
        /*
            r4 = this;
            o.Base64$1 r0 = r5.length
            o.Base64$OutputStream r0 = r0.toIntRange
        L_0x0004:
            if (r0 == 0) goto L_0x0033
            boolean r1 = r4.getMax((o.Base64$OutputStream) r0)
            r2 = 0
            if (r1 == 0) goto L_0x0016
            o.Base64$OutputStream r1 = r0.IsOverlapping
            if (r1 == 0) goto L_0x0016
            o.Base64$1 r5 = r5.length
            r5.setMin = r2
            return
        L_0x0016:
            o.Base64$OutputStream r1 = r0.toIntRange
        L_0x0018:
            if (r1 == 0) goto L_0x0030
            boolean r3 = r4.getMax((o.Base64$OutputStream) r1)
            if (r3 == 0) goto L_0x002d
            o.Base64$OutputStream r3 = r0.IsOverlapping
            if (r3 != 0) goto L_0x0028
            o.Base64$OutputStream r3 = r1.IsOverlapping
            if (r3 == 0) goto L_0x002d
        L_0x0028:
            o.Base64$1 r1 = r5.length
            r1.setMin = r2
            goto L_0x0030
        L_0x002d:
            o.Base64$OutputStream r1 = r1.IsOverlapping
            goto L_0x0018
        L_0x0030:
            o.Base64$OutputStream r0 = r0.IsOverlapping
            goto L_0x0004
        L_0x0033:
            return
        */
        throw new UnsupportedOperationException("Method not decompiled: o.systemOut.length(o.setLogImpl):void");
    }

    private <T extends setOnFocusChangeListener> T setMin(T t) {
        while (true) {
            List<setOnFocusChangeListener> list = this.hashCode;
            if (!list.get(list.size() - 1).setMax(t.getMax())) {
                List<setOnFocusChangeListener> list2 = this.hashCode;
                getMin(list2.get(list2.size() - 1));
            } else {
                List<setOnFocusChangeListener> list3 = this.hashCode;
                list3.get(list3.size() - 1).getMax().getMax(t.getMax());
                this.hashCode.add(t);
                this.toDoubleRange.add(t);
                return t;
            }
        }
    }
}

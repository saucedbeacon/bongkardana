package o;

import com.bca.xco.widget.connection.httpclient.internal.http2.a;
import com.google.android.exoplayer2.C;
import java.io.Closeable;
import java.io.IOException;
import java.net.Socket;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import o.getUseCompatPadding;

public final class setContentPadding implements Closeable {
    static final /* synthetic */ boolean IsOverlapping = (!setContentPadding.class.desiredAssertionStatus());
    /* access modifiers changed from: private */
    public static final ExecutorService isInside = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue(), CustomTabsIntent$ShareState.getMin("OkHttp FramedConnection", true));
    /* access modifiers changed from: private */
    public final Map<Integer, setMinimumWidth> FastBitmap$CoordinateSystem;
    /* access modifiers changed from: private */
    public final setUseCompatPadding Grayscale$Algorithm;
    private final ExecutorService Mean$Arithmetic;
    final getMin equals;
    /* access modifiers changed from: private */
    public final Set<Integer> getCause;
    final getContentPaddingLeft getMax;
    long getMin;
    /* access modifiers changed from: private */
    public final String hashCode;
    /* access modifiers changed from: private */
    public boolean invoke;
    private Map<Integer, getContentPaddingTop> invokeSuspend;
    final boolean length;
    /* access modifiers changed from: private */
    public boolean onNavigationEvent;
    getContentPaddingLeft setMax;
    long setMin;
    /* access modifiers changed from: private */
    public int toDoubleRange;
    final Socket toFloatRange;
    final setMinimumHeight toIntRange;
    /* access modifiers changed from: private */
    public int toString;
    private int valueOf;
    /* access modifiers changed from: private */
    public final setMin values;

    public static class getMax {
        setUseCompatPadding IsOverlapping = setUseCompatPadding.getMin;
        public resize getMax;
        public put getMin;
        public String length;
        public Socket setMax;
        public setMin setMin = setMin.FastBitmap$CoordinateSystem;
        /* access modifiers changed from: private */
        public boolean toIntRange = true;
    }

    public static abstract class setMin {
        public static final setMin FastBitmap$CoordinateSystem = new setMin() {
            public final void getMax(setMinimumWidth setminimumwidth) {
                a aVar = a.REFUSED_STREAM;
                if (setminimumwidth.getMin(aVar)) {
                    setminimumwidth.setMin.getMin(setminimumwidth.getMax, aVar);
                }
            }
        };

        public void getMax(setContentPadding setcontentpadding) {
        }

        public abstract void getMax(setMinimumWidth setminimumwidth);
    }

    /* access modifiers changed from: private */
    public static boolean setMin(int i) {
        return i != 0 && (i & 1) == 0;
    }

    public /* synthetic */ setContentPadding(getMax getmax, byte b) {
        this(getmax);
    }

    private setContentPadding(getMax getmax) {
        this.FastBitmap$CoordinateSystem = new HashMap();
        this.getMin = 0;
        this.setMax = new getContentPaddingLeft();
        this.getMax = new getContentPaddingLeft();
        this.onNavigationEvent = false;
        this.getCause = new LinkedHashSet();
        this.Grayscale$Algorithm = getmax.IsOverlapping;
        this.length = getmax.toIntRange;
        this.values = getmax.setMin;
        int i = 2;
        this.toDoubleRange = getmax.toIntRange ? 1 : 2;
        if (getmax.toIntRange) {
            this.toDoubleRange += 2;
        }
        this.valueOf = getmax.toIntRange ? 1 : i;
        if (getmax.toIntRange) {
            this.setMax.length(7, C.DEFAULT_MUXED_BUFFER_SIZE);
        }
        this.hashCode = getmax.length;
        this.Mean$Arithmetic = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS, new LinkedBlockingQueue(), CustomTabsIntent$ShareState.getMin(CustomTabsIntent$ShareState.getMin("OkHttp %s Push Observer", this.hashCode), true));
        int i2 = 65535;
        this.getMax.length(7, 65535);
        this.getMax.length(5, 16384);
        getContentPaddingLeft getcontentpaddingleft = this.getMax;
        this.setMin = (long) ((getcontentpaddingleft.setMin & 128) != 0 ? getcontentpaddingleft.setMax[7] : i2);
        this.toFloatRange = getmax.setMax;
        this.toIntRange = new setMinimumHeight(getmax.getMax, this.length);
        this.equals = new getMin(this, new getUseCompatPadding(getmax.getMin, this.length), (byte) 0);
    }

    /* access modifiers changed from: package-private */
    public final synchronized setMinimumWidth getMax(int i) {
        return this.FastBitmap$CoordinateSystem.get(Integer.valueOf(i));
    }

    /* access modifiers changed from: package-private */
    public final synchronized setMinimumWidth getMin(int i) {
        setMinimumWidth remove;
        remove = this.FastBitmap$CoordinateSystem.remove(Integer.valueOf(i));
        notifyAll();
        return remove;
    }

    public final synchronized int setMax() {
        getContentPaddingLeft getcontentpaddingleft = this.getMax;
        if ((getcontentpaddingleft.setMin & 16) == 0) {
            return Integer.MAX_VALUE;
        }
        return getcontentpaddingleft.setMax[4];
    }

    /* access modifiers changed from: package-private */
    /* JADX WARNING: Removed duplicated region for block: B:18:0x0037  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public final o.setMinimumWidth length(java.util.List<o.CardView> r11, boolean r12) {
        /*
            r10 = this;
            r6 = r12 ^ 1
            o.setMinimumHeight r7 = r10.toIntRange
            monitor-enter(r7)
            monitor-enter(r10)     // Catch:{ all -> 0x005a }
            boolean r0 = r10.invoke     // Catch:{ all -> 0x0057 }
            if (r0 != 0) goto L_0x004f
            int r8 = r10.toDoubleRange     // Catch:{ all -> 0x0057 }
            int r0 = r10.toDoubleRange     // Catch:{ all -> 0x0057 }
            int r0 = r0 + 2
            r10.toDoubleRange = r0     // Catch:{ all -> 0x0057 }
            o.setMinimumWidth r9 = new o.setMinimumWidth     // Catch:{ all -> 0x0057 }
            r4 = 0
            r0 = r9
            r1 = r8
            r2 = r10
            r3 = r6
            r5 = r11
            r0.<init>(r1, r2, r3, r4, r5)     // Catch:{ all -> 0x0057 }
            if (r12 == 0) goto L_0x0030
            long r0 = r10.setMin     // Catch:{ all -> 0x0057 }
            r2 = 0
            int r12 = (r0 > r2 ? 1 : (r0 == r2 ? 0 : -1))
            if (r12 == 0) goto L_0x0030
            long r0 = r9.length     // Catch:{ all -> 0x0057 }
            int r12 = (r0 > r2 ? 1 : (r0 == r2 ? 0 : -1))
            if (r12 != 0) goto L_0x002e
            goto L_0x0030
        L_0x002e:
            r12 = 0
            goto L_0x0031
        L_0x0030:
            r12 = 1
        L_0x0031:
            boolean r0 = r9.setMax()     // Catch:{ all -> 0x0057 }
            if (r0 == 0) goto L_0x0040
            java.util.Map<java.lang.Integer, o.setMinimumWidth> r0 = r10.FastBitmap$CoordinateSystem     // Catch:{ all -> 0x0057 }
            java.lang.Integer r1 = java.lang.Integer.valueOf(r8)     // Catch:{ all -> 0x0057 }
            r0.put(r1, r9)     // Catch:{ all -> 0x0057 }
        L_0x0040:
            monitor-exit(r10)     // Catch:{ all -> 0x0057 }
            o.setMinimumHeight r0 = r10.toIntRange     // Catch:{ all -> 0x005a }
            r0.getMax(r6, r8, r11)     // Catch:{ all -> 0x005a }
            monitor-exit(r7)     // Catch:{ all -> 0x005a }
            if (r12 == 0) goto L_0x004e
            o.setMinimumHeight r11 = r10.toIntRange
            r11.getMin()
        L_0x004e:
            return r9
        L_0x004f:
            java.io.IOException r11 = new java.io.IOException     // Catch:{ all -> 0x0057 }
            java.lang.String r12 = "shutdown"
            r11.<init>(r12)     // Catch:{ all -> 0x0057 }
            throw r11     // Catch:{ all -> 0x0057 }
        L_0x0057:
            r11 = move-exception
            monitor-exit(r10)     // Catch:{ all -> 0x005a }
            throw r11     // Catch:{ all -> 0x005a }
        L_0x005a:
            r11 = move-exception
            monitor-exit(r7)
            throw r11
        */
        throw new UnsupportedOperationException("Method not decompiled: o.setContentPadding.length(java.util.List, boolean):o.setMinimumWidth");
    }

    /* JADX WARNING: Can't wrap try/catch for region: R(3:26|27|28) */
    /* JADX WARNING: Code restructure failed: missing block: B:16:?, code lost:
        r3 = java.lang.Math.min((int) java.lang.Math.min(r12, r8.setMin), r8.toIntRange.getMin);
        r6 = (long) r3;
        r8.setMin -= r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x005d, code lost:
        throw new java.io.InterruptedIOException();
     */
    /* JADX WARNING: Missing exception handler attribute for start block: B:26:0x0058 */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public final void getMax(int r9, boolean r10, o.maxSize r11, long r12) {
        /*
            r8 = this;
            r0 = 0
            r1 = 0
            int r3 = (r12 > r1 ? 1 : (r12 == r1 ? 0 : -1))
            if (r3 != 0) goto L_0x000d
            o.setMinimumHeight r12 = r8.toIntRange
            r12.length(r10, r9, r11, r0)
            return
        L_0x000d:
            int r3 = (r12 > r1 ? 1 : (r12 == r1 ? 0 : -1))
            if (r3 <= 0) goto L_0x0060
            monitor-enter(r8)
        L_0x0012:
            long r3 = r8.setMin     // Catch:{ InterruptedException -> 0x0058 }
            int r5 = (r3 > r1 ? 1 : (r3 == r1 ? 0 : -1))
            if (r5 > 0) goto L_0x0030
            java.util.Map<java.lang.Integer, o.setMinimumWidth> r3 = r8.FastBitmap$CoordinateSystem     // Catch:{ InterruptedException -> 0x0058 }
            java.lang.Integer r4 = java.lang.Integer.valueOf(r9)     // Catch:{ InterruptedException -> 0x0058 }
            boolean r3 = r3.containsKey(r4)     // Catch:{ InterruptedException -> 0x0058 }
            if (r3 == 0) goto L_0x0028
            r8.wait()     // Catch:{ InterruptedException -> 0x0058 }
            goto L_0x0012
        L_0x0028:
            java.io.IOException r9 = new java.io.IOException     // Catch:{ InterruptedException -> 0x0058 }
            java.lang.String r10 = "stream closed"
            r9.<init>(r10)     // Catch:{ InterruptedException -> 0x0058 }
            throw r9     // Catch:{ InterruptedException -> 0x0058 }
        L_0x0030:
            long r3 = r8.setMin     // Catch:{ all -> 0x0056 }
            long r3 = java.lang.Math.min(r12, r3)     // Catch:{ all -> 0x0056 }
            int r4 = (int) r3     // Catch:{ all -> 0x0056 }
            o.setMinimumHeight r3 = r8.toIntRange     // Catch:{ all -> 0x0056 }
            int r3 = r3.getMin     // Catch:{ all -> 0x0056 }
            int r3 = java.lang.Math.min(r4, r3)     // Catch:{ all -> 0x0056 }
            long r4 = r8.setMin     // Catch:{ all -> 0x0056 }
            long r6 = (long) r3     // Catch:{ all -> 0x0056 }
            long r4 = r4 - r6
            r8.setMin = r4     // Catch:{ all -> 0x0056 }
            monitor-exit(r8)     // Catch:{ all -> 0x0056 }
            long r12 = r12 - r6
            o.setMinimumHeight r4 = r8.toIntRange
            if (r10 == 0) goto L_0x0051
            int r5 = (r12 > r1 ? 1 : (r12 == r1 ? 0 : -1))
            if (r5 != 0) goto L_0x0051
            r5 = 1
            goto L_0x0052
        L_0x0051:
            r5 = 0
        L_0x0052:
            r4.length(r5, r9, r11, r3)
            goto L_0x000d
        L_0x0056:
            r9 = move-exception
            goto L_0x005e
        L_0x0058:
            java.io.InterruptedIOException r9 = new java.io.InterruptedIOException     // Catch:{ all -> 0x0056 }
            r9.<init>()     // Catch:{ all -> 0x0056 }
            throw r9     // Catch:{ all -> 0x0056 }
        L_0x005e:
            monitor-exit(r8)
            throw r9
        L_0x0060:
            return
        */
        throw new UnsupportedOperationException("Method not decompiled: o.setContentPadding.getMax(int, boolean, o.maxSize, long):void");
    }

    /* access modifiers changed from: package-private */
    public final void length(int i, a aVar) {
        final int i2 = i;
        final a aVar2 = aVar;
        isInside.submit(new CustomTabsIntent$ColorScheme("OkHttp %s stream %d", new Object[]{this.hashCode, Integer.valueOf(i)}) {
            public final void getMax() {
                try {
                    setContentPadding.this.getMin(i2, aVar2);
                } catch (IOException unused) {
                }
            }
        });
    }

    public final void getMin(int i, a aVar) {
        int max = dispatchOnCancelled.setMax(i);
        if (i != max) {
            onCanceled oncanceled = new onCanceled(i, max, 1);
            onCancelLoad.setMax(483793525, oncanceled);
            onCancelLoad.getMin(483793525, oncanceled);
        }
        this.toIntRange.getMax(i, aVar);
    }

    /* access modifiers changed from: package-private */
    public final void getMin(int i, long j) {
        final int i2 = i;
        final long j2 = j;
        isInside.execute(new CustomTabsIntent$ColorScheme("OkHttp Window Update %s stream %d", new Object[]{this.hashCode, Integer.valueOf(i)}) {
            public final void getMax() {
                try {
                    setContentPadding.this.toIntRange.setMin(i2, j2);
                } catch (IOException unused) {
                }
            }
        });
    }

    /* access modifiers changed from: private */
    public synchronized getContentPaddingTop length(int i) {
        if (this.invokeSuspend == null) {
            return null;
        }
        return this.invokeSuspend.remove(Integer.valueOf(i));
    }

    private void getMin(a aVar) {
        synchronized (this.toIntRange) {
            synchronized (this) {
                if (!this.invoke) {
                    this.invoke = true;
                    int i = this.toString;
                    this.toIntRange.setMin(i, aVar, CustomTabsIntent$ShareState.getMin);
                }
            }
        }
    }

    public final void close() {
        getMin(a.NO_ERROR, a.CANCEL);
    }

    /* access modifiers changed from: private */
    public void getMin(a aVar, a aVar2) {
        setMinimumWidth[] setminimumwidthArr;
        if (IsOverlapping || !Thread.holdsLock(this)) {
            getContentPaddingTop[] getcontentpaddingtopArr = null;
            try {
                getMin(aVar);
                e = null;
            } catch (IOException e) {
                e = e;
            }
            synchronized (this) {
                if (!this.FastBitmap$CoordinateSystem.isEmpty()) {
                    setminimumwidthArr = (setMinimumWidth[]) this.FastBitmap$CoordinateSystem.values().toArray(new setMinimumWidth[this.FastBitmap$CoordinateSystem.size()]);
                    this.FastBitmap$CoordinateSystem.clear();
                } else {
                    setminimumwidthArr = null;
                }
                if (this.invokeSuspend != null) {
                    this.invokeSuspend = null;
                    getcontentpaddingtopArr = (getContentPaddingTop[]) this.invokeSuspend.values().toArray(new getContentPaddingTop[this.invokeSuspend.size()]);
                }
            }
            if (setminimumwidthArr != null) {
                for (setMinimumWidth setminimumwidth : setminimumwidthArr) {
                    try {
                        if (setminimumwidth.getMin(aVar2)) {
                            setminimumwidth.setMin.getMin(setminimumwidth.getMax, aVar2);
                        }
                    } catch (IOException e2) {
                        if (e != null) {
                            e = e2;
                        }
                    }
                }
            }
            if (getcontentpaddingtopArr != null) {
                for (getContentPaddingTop min : getcontentpaddingtopArr) {
                    min.getMin();
                }
            }
            try {
                this.toIntRange.close();
            } catch (IOException e3) {
                if (e == null) {
                    e = e3;
                }
            }
            try {
                this.toFloatRange.close();
            } catch (IOException e4) {
                e = e4;
            }
            if (e != null) {
                throw e;
            }
            return;
        }
        throw new AssertionError();
    }

    public final void setMin() {
        this.toIntRange.setMax();
        this.toIntRange.setMax(this.setMax);
        getContentPaddingLeft getcontentpaddingleft = this.setMax;
        int i = (getcontentpaddingleft.setMin & 128) != 0 ? getcontentpaddingleft.setMax[7] : 65535;
        if (i != 65535) {
            this.toIntRange.setMin(0, (long) (i - 65535));
        }
        new Thread(this.equals).start();
    }

    class getMin extends CustomTabsIntent$ColorScheme implements getUseCompatPadding.setMin {
        final getUseCompatPadding setMin;

        /* synthetic */ getMin(setContentPadding setcontentpadding, getUseCompatPadding getusecompatpadding, byte b) {
            this(getusecompatpadding);
        }

        private getMin(getUseCompatPadding getusecompatpadding) {
            super("OkHttp %s", setContentPadding.this.hashCode);
            this.setMin = getusecompatpadding;
        }

        /* JADX WARNING: Can't wrap try/catch for region: R(4:24|25|26|27) */
        /* JADX WARNING: Code restructure failed: missing block: B:23:0x006b, code lost:
            r2 = move-exception;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:25:?, code lost:
            r0 = com.bca.xco.widget.connection.httpclient.internal.http2.a.PROTOCOL_ERROR;
            r1 = com.bca.xco.widget.connection.httpclient.internal.http2.a.PROTOCOL_ERROR;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:27:?, code lost:
            r2 = r9.setMax;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:29:?, code lost:
            o.setContentPadding.getMax(r9.setMax, r0, r1);
         */
        /* JADX WARNING: Code restructure failed: missing block: B:30:0x0079, code lost:
            o.CustomTabsIntent$ShareState.setMin((java.io.Closeable) r9.setMin);
         */
        /* JADX WARNING: Code restructure failed: missing block: B:32:0x007f, code lost:
            throw r2;
         */
        /* JADX WARNING: Failed to process nested try/catch */
        /* JADX WARNING: Missing exception handler attribute for start block: B:24:0x006d */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public final void getMax() {
            /*
                r9 = this;
                com.bca.xco.widget.connection.httpclient.internal.http2.a r0 = com.bca.xco.widget.connection.httpclient.internal.http2.a.INTERNAL_ERROR
                com.bca.xco.widget.connection.httpclient.internal.http2.a r1 = com.bca.xco.widget.connection.httpclient.internal.http2.a.INTERNAL_ERROR
                o.setContentPadding r2 = o.setContentPadding.this     // Catch:{ IOException -> 0x006d }
                boolean r2 = r2.length     // Catch:{ IOException -> 0x006d }
                if (r2 != 0) goto L_0x0054
                o.getUseCompatPadding r2 = r9.setMin     // Catch:{ IOException -> 0x006d }
                boolean r3 = r2.getMax     // Catch:{ IOException -> 0x006d }
                if (r3 != 0) goto L_0x0054
                o.put r2 = r2.getMin     // Catch:{ IOException -> 0x006d }
                o.evictAll r3 = o.ShareTarget$RequestMethod.setMax     // Catch:{ IOException -> 0x006d }
                int r3 = r3.j()     // Catch:{ IOException -> 0x006d }
                long r3 = (long) r3     // Catch:{ IOException -> 0x006d }
                o.evictAll r2 = r2.getMax(r3)     // Catch:{ IOException -> 0x006d }
                java.util.logging.Logger r3 = o.getUseCompatPadding.setMin     // Catch:{ IOException -> 0x006d }
                java.util.logging.Level r4 = java.util.logging.Level.FINE     // Catch:{ IOException -> 0x006d }
                boolean r3 = r3.isLoggable(r4)     // Catch:{ IOException -> 0x006d }
                r4 = 0
                r5 = 1
                if (r3 == 0) goto L_0x003c
                java.util.logging.Logger r3 = o.getUseCompatPadding.setMin     // Catch:{ IOException -> 0x006d }
                java.lang.String r6 = "<< CONNECTION %s"
                java.lang.Object[] r7 = new java.lang.Object[r5]     // Catch:{ IOException -> 0x006d }
                java.lang.String r8 = r2.g()     // Catch:{ IOException -> 0x006d }
                r7[r4] = r8     // Catch:{ IOException -> 0x006d }
                java.lang.String r6 = o.CustomTabsIntent$ShareState.getMin((java.lang.String) r6, (java.lang.Object[]) r7)     // Catch:{ IOException -> 0x006d }
                r3.fine(r6)     // Catch:{ IOException -> 0x006d }
            L_0x003c:
                o.evictAll r3 = o.ShareTarget$RequestMethod.setMax     // Catch:{ IOException -> 0x006d }
                boolean r3 = r3.equals(r2)     // Catch:{ IOException -> 0x006d }
                if (r3 == 0) goto L_0x0045
                goto L_0x0054
            L_0x0045:
                java.lang.String r3 = "Expected a connection header but was %s"
                java.lang.Object[] r5 = new java.lang.Object[r5]     // Catch:{ IOException -> 0x006d }
                java.lang.String r2 = r2.a()     // Catch:{ IOException -> 0x006d }
                r5[r4] = r2     // Catch:{ IOException -> 0x006d }
                java.io.IOException r2 = o.ShareTarget$RequestMethod.getMin(r3, r5)     // Catch:{ IOException -> 0x006d }
                throw r2     // Catch:{ IOException -> 0x006d }
            L_0x0054:
                o.getUseCompatPadding r2 = r9.setMin     // Catch:{ IOException -> 0x006d }
                boolean r2 = r2.length(r9)     // Catch:{ IOException -> 0x006d }
                if (r2 != 0) goto L_0x0054
                com.bca.xco.widget.connection.httpclient.internal.http2.a r0 = com.bca.xco.widget.connection.httpclient.internal.http2.a.NO_ERROR     // Catch:{ IOException -> 0x006d }
                com.bca.xco.widget.connection.httpclient.internal.http2.a r1 = com.bca.xco.widget.connection.httpclient.internal.http2.a.CANCEL     // Catch:{ IOException -> 0x006d }
                o.setContentPadding r2 = o.setContentPadding.this     // Catch:{ IOException -> 0x0065 }
            L_0x0062:
                r2.getMin((com.bca.xco.widget.connection.httpclient.internal.http2.a) r0, (com.bca.xco.widget.connection.httpclient.internal.http2.a) r1)     // Catch:{ IOException -> 0x0065 }
            L_0x0065:
                o.getUseCompatPadding r0 = r9.setMin
                o.CustomTabsIntent$ShareState.setMin((java.io.Closeable) r0)
                return
            L_0x006b:
                r2 = move-exception
                goto L_0x0074
            L_0x006d:
                com.bca.xco.widget.connection.httpclient.internal.http2.a r0 = com.bca.xco.widget.connection.httpclient.internal.http2.a.PROTOCOL_ERROR     // Catch:{ all -> 0x006b }
                com.bca.xco.widget.connection.httpclient.internal.http2.a r1 = com.bca.xco.widget.connection.httpclient.internal.http2.a.PROTOCOL_ERROR     // Catch:{ all -> 0x006b }
                o.setContentPadding r2 = o.setContentPadding.this     // Catch:{ IOException -> 0x0065 }
                goto L_0x0062
            L_0x0074:
                o.setContentPadding r3 = o.setContentPadding.this     // Catch:{ IOException -> 0x0079 }
                r3.getMin((com.bca.xco.widget.connection.httpclient.internal.http2.a) r0, (com.bca.xco.widget.connection.httpclient.internal.http2.a) r1)     // Catch:{ IOException -> 0x0079 }
            L_0x0079:
                o.getUseCompatPadding r0 = r9.setMin
                o.CustomTabsIntent$ShareState.setMin((java.io.Closeable) r0)
                goto L_0x0080
            L_0x007f:
                throw r2
            L_0x0080:
                goto L_0x007f
            */
            throw new UnsupportedOperationException("Method not decompiled: o.setContentPadding.getMin.getMax():void");
        }

        public final void getMax(boolean z, int i, put put, int i2) {
            if (setContentPadding.setMin(i)) {
                setContentPadding.length(setContentPadding.this, i, put, i2, z);
                return;
            }
            setMinimumWidth max = setContentPadding.this.getMax(i);
            if (max == null) {
                setContentPadding.this.length(i, a.PROTOCOL_ERROR);
                put.setMin((long) i2);
            } else if (setMinimumWidth.IsOverlapping || !Thread.holdsLock(max)) {
                max.toFloatRange.setMin(put, (long) i2);
                if (z) {
                    max.setMin();
                }
            } else {
                throw new AssertionError();
            }
        }

        /* JADX WARNING: Code restructure failed: missing block: B:26:0x007c, code lost:
            if (o.setMinimumWidth.IsOverlapping != false) goto L_0x008b;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:28:0x0082, code lost:
            if (java.lang.Thread.holdsLock(r1) != false) goto L_0x0085;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:30:0x008a, code lost:
            throw new java.lang.AssertionError();
         */
        /* JADX WARNING: Code restructure failed: missing block: B:31:0x008b, code lost:
            monitor-enter(r1);
         */
        /* JADX WARNING: Code restructure failed: missing block: B:34:0x008e, code lost:
            if (r1.setMax != null) goto L_0x009a;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:35:0x0090, code lost:
            r1.setMax = r14;
            r2 = r1.setMax();
            r1.notifyAll();
         */
        /* JADX WARNING: Code restructure failed: missing block: B:36:0x009a, code lost:
            r13 = new java.util.ArrayList();
            r13.addAll(r1.setMax);
            r13.addAll(r14);
            r1.setMax = r13;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:37:0x00a9, code lost:
            monitor-exit(r1);
         */
        /* JADX WARNING: Code restructure failed: missing block: B:38:0x00aa, code lost:
            if (r2 != false) goto L_0x00b3;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:39:0x00ac, code lost:
            r1.setMin.getMin(r1.getMax);
         */
        /* JADX WARNING: Code restructure failed: missing block: B:40:0x00b3, code lost:
            if (r12 == false) goto L_?;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:41:0x00b5, code lost:
            r1.setMin();
         */
        /* JADX WARNING: Code restructure failed: missing block: B:48:?, code lost:
            return;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:49:?, code lost:
            return;
         */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public final void length(boolean r12, int r13, java.util.List<o.CardView> r14) {
            /*
                r11 = this;
                boolean r0 = o.setContentPadding.setMin((int) r13)
                if (r0 == 0) goto L_0x000c
                o.setContentPadding r0 = o.setContentPadding.this
                o.setContentPadding.setMax(r0, r13, r14, r12)
                return
            L_0x000c:
                o.setContentPadding r0 = o.setContentPadding.this
                monitor-enter(r0)
                o.setContentPadding r1 = o.setContentPadding.this     // Catch:{ all -> 0x00bc }
                boolean r1 = r1.invoke     // Catch:{ all -> 0x00bc }
                if (r1 == 0) goto L_0x0019
                monitor-exit(r0)     // Catch:{ all -> 0x00bc }
                return
            L_0x0019:
                o.setContentPadding r1 = o.setContentPadding.this     // Catch:{ all -> 0x00bc }
                o.setMinimumWidth r1 = r1.getMax((int) r13)     // Catch:{ all -> 0x00bc }
                r2 = 1
                if (r1 != 0) goto L_0x0079
                o.setContentPadding r1 = o.setContentPadding.this     // Catch:{ all -> 0x00bc }
                int r1 = r1.toString     // Catch:{ all -> 0x00bc }
                if (r13 > r1) goto L_0x002c
                monitor-exit(r0)     // Catch:{ all -> 0x00bc }
                return
            L_0x002c:
                int r1 = r13 % 2
                o.setContentPadding r3 = o.setContentPadding.this     // Catch:{ all -> 0x00bc }
                int r3 = r3.toDoubleRange     // Catch:{ all -> 0x00bc }
                r4 = 2
                int r3 = r3 % r4
                if (r1 != r3) goto L_0x003a
                monitor-exit(r0)     // Catch:{ all -> 0x00bc }
                return
            L_0x003a:
                o.setMinimumWidth r1 = new o.setMinimumWidth     // Catch:{ all -> 0x00bc }
                o.setContentPadding r7 = o.setContentPadding.this     // Catch:{ all -> 0x00bc }
                r8 = 0
                r5 = r1
                r6 = r13
                r9 = r12
                r10 = r14
                r5.<init>(r6, r7, r8, r9, r10)     // Catch:{ all -> 0x00bc }
                o.setContentPadding r12 = o.setContentPadding.this     // Catch:{ all -> 0x00bc }
                int unused = r12.toString = r13     // Catch:{ all -> 0x00bc }
                o.setContentPadding r12 = o.setContentPadding.this     // Catch:{ all -> 0x00bc }
                java.util.Map r12 = r12.FastBitmap$CoordinateSystem     // Catch:{ all -> 0x00bc }
                java.lang.Integer r14 = java.lang.Integer.valueOf(r13)     // Catch:{ all -> 0x00bc }
                r12.put(r14, r1)     // Catch:{ all -> 0x00bc }
                java.util.concurrent.ExecutorService r12 = o.setContentPadding.isInside     // Catch:{ all -> 0x00bc }
                o.setContentPadding$getMin$4 r14 = new o.setContentPadding$getMin$4     // Catch:{ all -> 0x00bc }
                java.lang.String r3 = "OkHttp %s stream %d"
                java.lang.Object[] r4 = new java.lang.Object[r4]     // Catch:{ all -> 0x00bc }
                r5 = 0
                o.setContentPadding r6 = o.setContentPadding.this     // Catch:{ all -> 0x00bc }
                java.lang.String r6 = r6.hashCode     // Catch:{ all -> 0x00bc }
                r4[r5] = r6     // Catch:{ all -> 0x00bc }
                java.lang.Integer r13 = java.lang.Integer.valueOf(r13)     // Catch:{ all -> 0x00bc }
                r4[r2] = r13     // Catch:{ all -> 0x00bc }
                r14.<init>(r3, r4, r1)     // Catch:{ all -> 0x00bc }
                r12.execute(r14)     // Catch:{ all -> 0x00bc }
                monitor-exit(r0)     // Catch:{ all -> 0x00bc }
                return
            L_0x0079:
                monitor-exit(r0)
                boolean r13 = o.setMinimumWidth.IsOverlapping
                if (r13 != 0) goto L_0x008b
                boolean r13 = java.lang.Thread.holdsLock(r1)
                if (r13 != 0) goto L_0x0085
                goto L_0x008b
            L_0x0085:
                java.lang.AssertionError r12 = new java.lang.AssertionError
                r12.<init>()
                throw r12
            L_0x008b:
                monitor-enter(r1)
                java.util.List<o.CardView> r13 = r1.setMax     // Catch:{ all -> 0x00b9 }
                if (r13 != 0) goto L_0x009a
                r1.setMax = r14     // Catch:{ all -> 0x00b9 }
                boolean r2 = r1.setMax()     // Catch:{ all -> 0x00b9 }
                r1.notifyAll()     // Catch:{ all -> 0x00b9 }
                goto L_0x00a9
            L_0x009a:
                java.util.ArrayList r13 = new java.util.ArrayList     // Catch:{ all -> 0x00b9 }
                r13.<init>()     // Catch:{ all -> 0x00b9 }
                java.util.List<o.CardView> r0 = r1.setMax     // Catch:{ all -> 0x00b9 }
                r13.addAll(r0)     // Catch:{ all -> 0x00b9 }
                r13.addAll(r14)     // Catch:{ all -> 0x00b9 }
                r1.setMax = r13     // Catch:{ all -> 0x00b9 }
            L_0x00a9:
                monitor-exit(r1)     // Catch:{ all -> 0x00b9 }
                if (r2 != 0) goto L_0x00b3
                o.setContentPadding r13 = r1.setMin
                int r14 = r1.getMax
                r13.getMin((int) r14)
            L_0x00b3:
                if (r12 == 0) goto L_0x00b8
                r1.setMin()
            L_0x00b8:
                return
            L_0x00b9:
                r12 = move-exception
                monitor-exit(r1)
                throw r12
            L_0x00bc:
                r12 = move-exception
                monitor-exit(r0)
                throw r12
            */
            throw new UnsupportedOperationException("Method not decompiled: o.setContentPadding.getMin.length(boolean, int, java.util.List):void");
        }

        public final void setMin(int i, a aVar) {
            if (setContentPadding.setMin(i)) {
                setContentPadding.length(setContentPadding.this, i, aVar);
                return;
            }
            setMinimumWidth min = setContentPadding.this.getMin(i);
            if (min != null) {
                min.length(aVar);
            }
        }

        /* JADX WARNING: type inference failed for: r14v17, types: [java.lang.Object[]] */
        /* JADX WARNING: Multi-variable type inference failed */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public final void setMax(final o.getContentPaddingLeft r14) {
            /*
                r13 = this;
                o.setContentPadding r0 = o.setContentPadding.this
                monitor-enter(r0)
                o.setContentPadding r1 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                o.getContentPaddingLeft r1 = r1.getMax     // Catch:{ all -> 0x00e3 }
                int r2 = r1.setMin     // Catch:{ all -> 0x00e3 }
                r2 = r2 & 128(0x80, float:1.794E-43)
                r3 = 7
                r4 = 65535(0xffff, float:9.1834E-41)
                if (r2 == 0) goto L_0x0016
                int[] r1 = r1.setMax     // Catch:{ all -> 0x00e3 }
                r1 = r1[r3]     // Catch:{ all -> 0x00e3 }
                goto L_0x0019
            L_0x0016:
                r1 = 65535(0xffff, float:9.1834E-41)
            L_0x0019:
                o.setContentPadding r2 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                o.getContentPaddingLeft r2 = r2.getMax     // Catch:{ all -> 0x00e3 }
                r5 = 0
                r6 = 0
            L_0x001f:
                r7 = 10
                if (r6 >= r7) goto L_0x0033
                boolean r7 = r14.getMax(r6)     // Catch:{ all -> 0x00e3 }
                if (r7 == 0) goto L_0x0030
                int[] r7 = r14.setMax     // Catch:{ all -> 0x00e3 }
                r7 = r7[r6]     // Catch:{ all -> 0x00e3 }
                r2.length(r6, r7)     // Catch:{ all -> 0x00e3 }
            L_0x0030:
                int r6 = r6 + 1
                goto L_0x001f
            L_0x0033:
                java.util.concurrent.ExecutorService r2 = o.setContentPadding.isInside     // Catch:{ all -> 0x00e3 }
                o.setContentPadding$getMin$2 r6 = new o.setContentPadding$getMin$2     // Catch:{ all -> 0x00e3 }
                java.lang.String r7 = "OkHttp %s ACK Settings"
                r8 = 1
                java.lang.Object[] r9 = new java.lang.Object[r8]     // Catch:{ all -> 0x00e3 }
                o.setContentPadding r10 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                java.lang.String r10 = r10.hashCode     // Catch:{ all -> 0x00e3 }
                r9[r5] = r10     // Catch:{ all -> 0x00e3 }
                r6.<init>(r7, r9, r14)     // Catch:{ all -> 0x00e3 }
                r2.execute(r6)     // Catch:{ all -> 0x00e3 }
                o.setContentPadding r14 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                o.getContentPaddingLeft r14 = r14.getMax     // Catch:{ all -> 0x00e3 }
                int r2 = r14.setMin     // Catch:{ all -> 0x00e3 }
                r2 = r2 & 128(0x80, float:1.794E-43)
                if (r2 == 0) goto L_0x005a
                int[] r14 = r14.setMax     // Catch:{ all -> 0x00e3 }
                r4 = r14[r3]     // Catch:{ all -> 0x00e3 }
            L_0x005a:
                r14 = -1
                r2 = 0
                r6 = 0
                if (r4 == r14) goto L_0x00a9
                if (r4 == r1) goto L_0x00a9
                int r4 = r4 - r1
                long r9 = (long) r4     // Catch:{ all -> 0x00e3 }
                o.setContentPadding r14 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                boolean r14 = r14.onNavigationEvent     // Catch:{ all -> 0x00e3 }
                if (r14 != 0) goto L_0x007f
                o.setContentPadding r14 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                long r11 = r14.setMin     // Catch:{ all -> 0x00e3 }
                long r11 = r11 + r9
                r14.setMin = r11     // Catch:{ all -> 0x00e3 }
                int r1 = (r9 > r2 ? 1 : (r9 == r2 ? 0 : -1))
                if (r1 <= 0) goto L_0x007a
                r14.notifyAll()     // Catch:{ all -> 0x00e3 }
            L_0x007a:
                o.setContentPadding r14 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                boolean unused = r14.onNavigationEvent = true     // Catch:{ all -> 0x00e3 }
            L_0x007f:
                o.setContentPadding r14 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                java.util.Map r14 = r14.FastBitmap$CoordinateSystem     // Catch:{ all -> 0x00e3 }
                boolean r14 = r14.isEmpty()     // Catch:{ all -> 0x00e3 }
                if (r14 != 0) goto L_0x00aa
                o.setContentPadding r14 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                java.util.Map r14 = r14.FastBitmap$CoordinateSystem     // Catch:{ all -> 0x00e3 }
                java.util.Collection r14 = r14.values()     // Catch:{ all -> 0x00e3 }
                o.setContentPadding r1 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                java.util.Map r1 = r1.FastBitmap$CoordinateSystem     // Catch:{ all -> 0x00e3 }
                int r1 = r1.size()     // Catch:{ all -> 0x00e3 }
                o.setMinimumWidth[] r1 = new o.setMinimumWidth[r1]     // Catch:{ all -> 0x00e3 }
                java.lang.Object[] r14 = r14.toArray(r1)     // Catch:{ all -> 0x00e3 }
                r6 = r14
                o.setMinimumWidth[] r6 = (o.setMinimumWidth[]) r6     // Catch:{ all -> 0x00e3 }
                goto L_0x00aa
            L_0x00a9:
                r9 = r2
            L_0x00aa:
                java.util.concurrent.ExecutorService r14 = o.setContentPadding.isInside     // Catch:{ all -> 0x00e3 }
                o.setContentPadding$getMin$1 r1 = new o.setContentPadding$getMin$1     // Catch:{ all -> 0x00e3 }
                java.lang.String r4 = "OkHttp %s settings"
                java.lang.Object[] r7 = new java.lang.Object[r8]     // Catch:{ all -> 0x00e3 }
                o.setContentPadding r8 = o.setContentPadding.this     // Catch:{ all -> 0x00e3 }
                java.lang.String r8 = r8.hashCode     // Catch:{ all -> 0x00e3 }
                r7[r5] = r8     // Catch:{ all -> 0x00e3 }
                r1.<init>(r4, r7)     // Catch:{ all -> 0x00e3 }
                r14.execute(r1)     // Catch:{ all -> 0x00e3 }
                monitor-exit(r0)     // Catch:{ all -> 0x00e3 }
                if (r6 == 0) goto L_0x00e2
                int r14 = (r9 > r2 ? 1 : (r9 == r2 ? 0 : -1))
                if (r14 == 0) goto L_0x00e2
                int r14 = r6.length
            L_0x00ca:
                if (r5 >= r14) goto L_0x00e2
                r0 = r6[r5]
                monitor-enter(r0)
                long r7 = r0.length     // Catch:{ all -> 0x00df }
                long r7 = r7 + r9
                r0.length = r7     // Catch:{ all -> 0x00df }
                int r1 = (r9 > r2 ? 1 : (r9 == r2 ? 0 : -1))
                if (r1 <= 0) goto L_0x00db
                r0.notifyAll()     // Catch:{ all -> 0x00df }
            L_0x00db:
                monitor-exit(r0)     // Catch:{ all -> 0x00df }
                int r5 = r5 + 1
                goto L_0x00ca
            L_0x00df:
                r14 = move-exception
                monitor-exit(r0)
                throw r14
            L_0x00e2:
                return
            L_0x00e3:
                r14 = move-exception
                monitor-exit(r0)
                goto L_0x00e7
            L_0x00e6:
                throw r14
            L_0x00e7:
                goto L_0x00e6
            */
            throw new UnsupportedOperationException("Method not decompiled: o.setContentPadding.getMin.setMax(o.getContentPaddingLeft):void");
        }

        public final void setMax(boolean z, int i, int i2) {
            if (z) {
                getContentPaddingTop max = setContentPadding.this.length(i);
                if (max == null) {
                    return;
                }
                if (max.setMin != -1 || max.length == -1) {
                    throw new IllegalStateException();
                }
                max.setMin = System.nanoTime();
                max.getMin.countDown();
                return;
            }
            setContentPadding.getMin(setContentPadding.this, i, i2);
        }

        public final void getMin(int i, evictAll evictall) {
            setMinimumWidth[] setminimumwidthArr;
            evictall.j();
            synchronized (setContentPadding.this) {
                setminimumwidthArr = (setMinimumWidth[]) setContentPadding.this.FastBitmap$CoordinateSystem.values().toArray(new setMinimumWidth[setContentPadding.this.FastBitmap$CoordinateSystem.size()]);
                boolean unused = setContentPadding.this.invoke = true;
            }
            for (setMinimumWidth setminimumwidth : setminimumwidthArr) {
                if (setminimumwidth.getMax > i && setminimumwidth.length()) {
                    setminimumwidth.length(a.REFUSED_STREAM);
                    setContentPadding.this.getMin(setminimumwidth.getMax);
                }
            }
        }

        public final void getMax(int i, long j) {
            if (i == 0) {
                synchronized (setContentPadding.this) {
                    setContentPadding.this.setMin += j;
                    setContentPadding.this.notifyAll();
                }
                return;
            }
            setMinimumWidth max = setContentPadding.this.getMax(i);
            if (max != null) {
                synchronized (max) {
                    max.length += j;
                    if (j > 0) {
                        max.notifyAll();
                    }
                }
            }
        }

        public final void getMax(int i, List<CardView> list) {
            setContentPadding.setMax(setContentPadding.this, i, list);
        }
    }

    static /* synthetic */ void getMax(setContentPadding setcontentpadding, boolean z, int i, int i2, getContentPaddingTop getcontentpaddingtop) {
        synchronized (setcontentpadding.toIntRange) {
            if (getcontentpaddingtop != null) {
                if (getcontentpaddingtop.length == -1) {
                    getcontentpaddingtop.length = System.nanoTime();
                } else {
                    throw new IllegalStateException();
                }
            }
            setcontentpadding.toIntRange.setMin(z, i, i2);
        }
    }

    static /* synthetic */ void length(setContentPadding setcontentpadding, int i, put put, int i2, boolean z) {
        final maxSize maxsize = new maxSize();
        long j = (long) i2;
        put.length(j);
        put.length(maxsize, j);
        if (maxsize.setMax == j) {
            final int i3 = i;
            final int i4 = i2;
            final boolean z2 = z;
            setcontentpadding.Mean$Arithmetic.execute(new CustomTabsIntent$ColorScheme("OkHttp %s Push Data[%s]", new Object[]{setcontentpadding.hashCode, Integer.valueOf(i)}) {
                public final void getMax() {
                    try {
                        setContentPadding.this.Grayscale$Algorithm.getMin(maxsize, i4);
                        setContentPadding.this.toIntRange.getMax(i3, a.CANCEL);
                        synchronized (setContentPadding.this) {
                            setContentPadding.this.getCause.remove(Integer.valueOf(i3));
                        }
                    } catch (IOException unused) {
                    }
                }
            });
            return;
        }
        StringBuilder sb = new StringBuilder();
        sb.append(maxsize.setMax);
        sb.append(" != ");
        sb.append(i2);
        throw new IOException(sb.toString());
    }

    static /* synthetic */ void setMax(setContentPadding setcontentpadding, int i, List list, boolean z) {
        final int i2 = i;
        final List list2 = list;
        final boolean z2 = z;
        setcontentpadding.Mean$Arithmetic.execute(new CustomTabsIntent$ColorScheme("OkHttp %s Push Headers[%s]", new Object[]{setcontentpadding.hashCode, Integer.valueOf(i)}) {
            public final void getMax() {
                setUseCompatPadding unused = setContentPadding.this.Grayscale$Algorithm;
                try {
                    setContentPadding.this.toIntRange.getMax(i2, a.CANCEL);
                    synchronized (setContentPadding.this) {
                        setContentPadding.this.getCause.remove(Integer.valueOf(i2));
                    }
                } catch (IOException unused2) {
                }
            }
        });
    }

    static /* synthetic */ void length(setContentPadding setcontentpadding, int i, a aVar) {
        final int i2 = i;
        final a aVar2 = aVar;
        setcontentpadding.Mean$Arithmetic.execute(new CustomTabsIntent$ColorScheme("OkHttp %s Push Reset[%s]", new Object[]{setcontentpadding.hashCode, Integer.valueOf(i)}) {
            public final void getMax() {
                setUseCompatPadding unused = setContentPadding.this.Grayscale$Algorithm;
                synchronized (setContentPadding.this) {
                    setContentPadding.this.getCause.remove(Integer.valueOf(i2));
                }
            }
        });
    }

    static /* synthetic */ void getMin(setContentPadding setcontentpadding, int i, int i2) {
        final int i3 = i;
        final int i4 = i2;
        isInside.execute(new CustomTabsIntent$ColorScheme("OkHttp %s ping %08x%08x", new Object[]{setcontentpadding.hashCode, Integer.valueOf(i), Integer.valueOf(i2)}) {
            final /* synthetic */ getContentPaddingTop setMax;
            final /* synthetic */ boolean setMin = true;

            {
                this.setMax = null;
            }

            public final void getMax() {
                try {
                    setContentPadding.getMax(setContentPadding.this, this.setMin, i3, i4, this.setMax);
                } catch (IOException unused) {
                }
            }
        });
    }

    static /* synthetic */ void setMax(setContentPadding setcontentpadding, int i, List list) {
        synchronized (setcontentpadding) {
            if (setcontentpadding.getCause.contains(Integer.valueOf(i))) {
                setcontentpadding.length(i, a.PROTOCOL_ERROR);
                return;
            }
            setcontentpadding.getCause.add(Integer.valueOf(i));
            final int i2 = i;
            final List list2 = list;
            setcontentpadding.Mean$Arithmetic.execute(new CustomTabsIntent$ColorScheme("OkHttp %s Push Request[%s]", new Object[]{setcontentpadding.hashCode, Integer.valueOf(i)}) {
                public final void getMax() {
                    setContentPadding.this.Grayscale$Algorithm.length(i2);
                    try {
                        setContentPadding.this.toIntRange.getMax(i2, a.CANCEL);
                        synchronized (setContentPadding.this) {
                            setContentPadding.this.getCause.remove(Integer.valueOf(i2));
                        }
                    } catch (IOException unused) {
                    }
                }
            });
        }
    }
}

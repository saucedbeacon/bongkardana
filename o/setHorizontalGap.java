package o;

import android.content.ComponentCallbacks2;
import android.content.Context;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.view.View;
import androidx.annotation.CheckResult;
import androidx.annotation.DrawableRes;
import androidx.annotation.GuardedBy;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RawRes;
import com.bumptech.glide.Glide;
import com.bumptech.glide.Priority;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import o.ConstraintLayout;

public class setHorizontalGap implements ComponentCallbacks2, setGuidelinePercent {
    private static final dispatchApplyWindowInsetsToBehaviors getMin = ((dispatchApplyWindowInsetsToBehaviors) ((dispatchApplyWindowInsetsToBehaviors) new dispatchApplyWindowInsetsToBehaviors().length((Class<?>) Bitmap.class)).values());
    private static final dispatchApplyWindowInsetsToBehaviors isInside = ((dispatchApplyWindowInsetsToBehaviors) ((dispatchApplyWindowInsetsToBehaviors) new dispatchApplyWindowInsetsToBehaviors().length((Class<?>) getViewWidget.class)).values());
    private static final dispatchApplyWindowInsetsToBehaviors toIntRange = ((dispatchApplyWindowInsetsToBehaviors) ((dispatchApplyWindowInsetsToBehaviors) ((dispatchApplyWindowInsetsToBehaviors) new dispatchApplyWindowInsetsToBehaviors().getMin(evaluate.getMin)).length(Priority.LOW)).length(true));
    private final Runnable FastBitmap$CoordinateSystem;
    @GuardedBy("this")
    private final getEmptyVisibility IsOverlapping;
    @GuardedBy("this")
    private final releaseTempRect equals;
    final CopyOnWriteArrayList<parseBehavior<Object>> getMax;
    private final Handler hashCode;
    protected final Glide length;
    final Group setMax;
    protected final Context setMin;
    private boolean toDoubleRange;
    @GuardedBy("this")
    private final CoordinatorLayout toFloatRange;
    @GuardedBy("this")
    private dispatchApplyWindowInsetsToBehaviors toString;
    private final ConstraintLayout.LayoutParams values;

    public void onConfigurationChanged(Configuration configuration) {
    }

    public void onLowMemory() {
    }

    public setHorizontalGap(@NonNull Glide glide, @NonNull Group group, @NonNull getEmptyVisibility getemptyvisibility, @NonNull Context context) {
        this(glide, group, getemptyvisibility, new CoordinatorLayout(), glide.equals, context);
    }

    private setHorizontalGap(Glide glide, Group group, getEmptyVisibility getemptyvisibility, CoordinatorLayout coordinatorLayout, Guideline guideline, Context context) {
        this.equals = new releaseTempRect();
        this.FastBitmap$CoordinateSystem = new Runnable() {
            public final void run() {
                setHorizontalGap.this.setMax.getMax(setHorizontalGap.this);
            }
        };
        this.hashCode = new Handler(Looper.getMainLooper());
        this.length = glide;
        this.setMax = group;
        this.IsOverlapping = getemptyvisibility;
        this.toFloatRange = coordinatorLayout;
        this.setMin = context;
        this.values = guideline.length(context.getApplicationContext(), new getMax(coordinatorLayout));
        if (getDependents.setMin()) {
            this.hashCode.post(this.FastBitmap$CoordinateSystem);
        } else {
            group.getMax(this);
        }
        group.getMax(this.values);
        setFirstHorizontalStyle setfirsthorizontalstyle = glide.setMax;
        int max = dispatchOnCancelled.getMax(0);
        if (max != 0) {
            onCanceled oncanceled = new onCanceled(0, max, 16);
            onCancelLoad.setMax(2101013095, oncanceled);
            onCancelLoad.getMin(2101013095, oncanceled);
        }
        this.getMax = new CopyOnWriteArrayList<>(setfirsthorizontalstyle.setMin);
        getMin(glide.setMax.getMax());
        synchronized (glide.IsOverlapping) {
            if (!glide.IsOverlapping.contains(this)) {
                glide.IsOverlapping.add(this);
            } else {
                throw new IllegalStateException("Cannot register already registered manager");
            }
        }
    }

    public synchronized void getMin(@NonNull dispatchApplyWindowInsetsToBehaviors dispatchapplywindowinsetstobehaviors) {
        this.toString = (dispatchApplyWindowInsetsToBehaviors) ((dispatchApplyWindowInsetsToBehaviors) dispatchapplywindowinsetstobehaviors.clone()).toDoubleRange();
    }

    private synchronized void equals() {
        CoordinatorLayout coordinatorLayout = this.toFloatRange;
        coordinatorLayout.length = true;
        for (T t : getDependents.getMin(coordinatorLayout.setMin)) {
            if (t.getMax()) {
                t.setMax();
                coordinatorLayout.setMax.add(t);
            }
        }
    }

    private synchronized void IsOverlapping() {
        CoordinatorLayout coordinatorLayout = this.toFloatRange;
        coordinatorLayout.length = true;
        for (T t : getDependents.getMin(coordinatorLayout.setMin)) {
            if (t.getMax() || t.setMin()) {
                t.getMin();
                coordinatorLayout.setMax.add(t);
            }
        }
    }

    private synchronized void toIntRange() {
        IsOverlapping();
        for (setHorizontalGap IsOverlapping2 : this.IsOverlapping.setMin()) {
            IsOverlapping2.IsOverlapping();
        }
    }

    private synchronized void toFloatRange() {
        CoordinatorLayout coordinatorLayout = this.toFloatRange;
        coordinatorLayout.length = false;
        for (T t : getDependents.getMin(coordinatorLayout.setMin)) {
            if (!t.setMin() && !t.getMax()) {
                t.length();
            }
        }
        coordinatorLayout.setMax.clear();
    }

    public final synchronized void setMax() {
        toFloatRange();
        this.equals.setMax();
    }

    public final synchronized void getMin() {
        equals();
        this.equals.getMin();
    }

    public final synchronized void setMin() {
        this.equals.setMin();
        for (T t : getDependents.getMin(this.equals.getMax)) {
            if (t != null) {
                length((layoutChildWithAnchor<?>) t);
            }
        }
        this.equals.getMax.clear();
        CoordinatorLayout coordinatorLayout = this.toFloatRange;
        for (T min : getDependents.getMin(coordinatorLayout.setMin)) {
            coordinatorLayout.getMin(min);
        }
        coordinatorLayout.setMax.clear();
        this.setMax.getMin(this);
        this.setMax.getMin(this.values);
        this.hashCode.removeCallbacks(this.FastBitmap$CoordinateSystem);
        Glide glide = this.length;
        synchronized (glide.IsOverlapping) {
            if (glide.IsOverlapping.contains(this)) {
                glide.IsOverlapping.remove(this);
            } else {
                throw new IllegalStateException("Cannot unregister not yet registered manager");
            }
        }
    }

    @CheckResult
    @NonNull
    public setFirstVerticalBias<Bitmap> length() {
        return getMax(Bitmap.class).getMin((getTopSortedChildren<?>) getMin);
    }

    @CheckResult
    @NonNull
    public setFirstVerticalBias<Drawable> getMax() {
        return getMax(Drawable.class);
    }

    @CheckResult
    @NonNull
    public setFirstVerticalBias<Drawable> length(@Nullable Drawable drawable) {
        return getMax().getMin(drawable);
    }

    @CheckResult
    @NonNull
    public setFirstVerticalBias<Drawable> getMax(@Nullable String str) {
        return getMax().getMax(str);
    }

    @CheckResult
    @NonNull
    public setFirstVerticalBias<Drawable> setMin(@Nullable Uri uri) {
        return getMax().length(uri);
    }

    @CheckResult
    @NonNull
    public setFirstVerticalBias<Drawable> setMin(@RawRes @DrawableRes @Nullable Integer num) {
        return getMax().getMax(num);
    }

    @CheckResult
    @NonNull
    public setFirstVerticalBias<Drawable> setMax(@Nullable Object obj) {
        return getMax().getMin(obj);
    }

    @CheckResult
    @NonNull
    public <ResourceType> setFirstVerticalBias<ResourceType> getMax(@NonNull Class<ResourceType> cls) {
        return new setFirstVerticalBias<>(this.length, this, cls, this.setMin);
    }

    public final void getMax(@Nullable layoutChildWithAnchor<?> layoutchildwithanchor) {
        if (layoutchildwithanchor != null) {
            length(layoutchildwithanchor);
        }
    }

    private void length(@NonNull layoutChildWithAnchor<?> layoutchildwithanchor) {
        boolean max = setMax(layoutchildwithanchor);
        getResolvedLayoutParams max2 = layoutchildwithanchor.getMax();
        if (!max && !this.length.length(layoutchildwithanchor) && max2 != null) {
            layoutchildwithanchor.setMin((getResolvedLayoutParams) null);
            max2.getMin();
        }
    }

    public final synchronized boolean setMax(@NonNull layoutChildWithAnchor<?> layoutchildwithanchor) {
        getResolvedLayoutParams max = layoutchildwithanchor.getMax();
        if (max == null) {
            return true;
        }
        if (!this.toFloatRange.getMin(max)) {
            return false;
        }
        this.equals.getMax.remove(layoutchildwithanchor);
        layoutchildwithanchor.setMin((getResolvedLayoutParams) null);
        return true;
    }

    /* access modifiers changed from: package-private */
    public final synchronized void setMin(@NonNull layoutChildWithAnchor<?> layoutchildwithanchor, @NonNull getResolvedLayoutParams getresolvedlayoutparams) {
        this.equals.getMax.add(layoutchildwithanchor);
        CoordinatorLayout coordinatorLayout = this.toFloatRange;
        coordinatorLayout.setMin.add(getresolvedlayoutparams);
        if (!coordinatorLayout.length) {
            getresolvedlayoutparams.length();
            return;
        }
        getresolvedlayoutparams.getMin();
        coordinatorLayout.setMax.add(getresolvedlayoutparams);
    }

    /* access modifiers changed from: package-private */
    public final synchronized dispatchApplyWindowInsetsToBehaviors isInside() {
        return this.toString;
    }

    /* access modifiers changed from: package-private */
    @NonNull
    public final <T> setFirstHorizontalBias<?, T> getMin(Class<T> cls) {
        int max;
        setFirstHorizontalStyle setfirsthorizontalstyle = this.length.setMax;
        Context baseContext = setfirsthorizontalstyle.getBaseContext();
        Context applicationContext = baseContext != null ? baseContext.getApplicationContext() : null;
        if (!(applicationContext == null || -1079018285 == (max = dispatchOnCancelled.getMax(applicationContext, -1079018285)))) {
            onCanceled oncanceled = new onCanceled(-1079018285, max, 512);
            onCancelLoad.setMax(-1079018285, oncanceled);
            onCancelLoad.getMin(-1079018285, oncanceled);
        }
        setFirstHorizontalBias<?, T> setfirsthorizontalbias = setfirsthorizontalstyle.getMax.get(cls);
        if (setfirsthorizontalbias == null) {
            for (Map.Entry next : setfirsthorizontalstyle.getMax.entrySet()) {
                if (((Class) next.getKey()).isAssignableFrom(cls)) {
                    setfirsthorizontalbias = (setFirstHorizontalBias) next.getValue();
                }
            }
        }
        return setfirsthorizontalbias == null ? setFirstHorizontalStyle.getMin : setfirsthorizontalbias;
    }

    public synchronized String toString() {
        StringBuilder sb;
        sb = new StringBuilder();
        sb.append(super.toString());
        sb.append("{tracker=");
        sb.append(this.toFloatRange);
        sb.append(", treeNode=");
        sb.append(this.IsOverlapping);
        sb.append("}");
        return sb.toString();
    }

    public void onTrimMemory(int i) {
        if (i == 60 && this.toDoubleRange) {
            toIntRange();
        }
    }

    class getMax implements ConstraintLayout.LayoutParams.length {
        @GuardedBy("RequestManager.this")
        private final CoordinatorLayout getMin;

        getMax(@NonNull CoordinatorLayout coordinatorLayout) {
            this.getMin = coordinatorLayout;
        }

        public final void getMax(boolean z) {
            if (z) {
                synchronized (setHorizontalGap.this) {
                    CoordinatorLayout coordinatorLayout = this.getMin;
                    for (T t : getDependents.getMin(coordinatorLayout.setMin)) {
                        if (!t.setMin() && !t.equals()) {
                            t.getMin();
                            if (!coordinatorLayout.length) {
                                t.length();
                            } else {
                                coordinatorLayout.setMax.add(t);
                            }
                        }
                    }
                }
            }
        }
    }

    public static class setMin extends recordLastChildRect<View, Object> {
        public final void getMin(@NonNull Object obj) {
        }

        public final void length(@Nullable Drawable drawable) {
        }

        public final void setMin(@Nullable Drawable drawable) {
        }

        public setMin(@NonNull View view) {
            super(view);
        }
    }
}

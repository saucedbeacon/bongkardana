package o;

import java.util.Iterator;
import java.util.concurrent.CopyOnWriteArraySet;

public final class createEventForHost {
    private static int values;
    private final String FastBitmap$CoordinateSystem;
    public final CopyOnWriteArraySet<Object> IsOverlapping = new CopyOnWriteArraySet<>();
    public double equals;
    public final setMax getMax = new setMax((byte) 0);
    public boolean getMin;
    private double hashCode = 0.005d;
    public double isInside;
    public final setMax length = new setMax((byte) 0);
    public obtainAccessibilityNodeInfo setMax;
    public final setMax setMin = new setMax((byte) 0);
    public double toFloatRange = 0.0d;
    public boolean toIntRange = true;
    private double toString = 0.005d;

    public static class setMax {
        public double getMax;
        public double setMax;

        private setMax() {
        }

        /* synthetic */ setMax(byte b) {
            this();
        }
    }

    public createEventForHost() {
        StringBuilder sb = new StringBuilder("spring:");
        int i = values;
        values = i + 1;
        sb.append(i);
        this.FastBitmap$CoordinateSystem = sb.toString();
        obtainAccessibilityNodeInfo obtainaccessibilitynodeinfo = obtainAccessibilityNodeInfo.getMin;
        if (obtainaccessibilitynodeinfo != null) {
            this.setMax = obtainaccessibilitynodeinfo;
            return;
        }
        throw new IllegalArgumentException("springConfig is required");
    }

    public final createEventForHost setMax(double d) {
        if (this.isInside == d && setMin()) {
            return this;
        }
        this.equals = this.setMin.setMax;
        this.isInside = d;
        Iterator<Object> it = this.IsOverlapping.iterator();
        while (it.hasNext()) {
            it.next();
        }
        return this;
    }

    public final boolean setMax() {
        if (this.setMax.length <= 0.0d) {
            return false;
        }
        if (this.equals >= this.isInside || this.setMin.setMax <= this.isInside) {
            return this.equals > this.isInside && this.setMin.setMax < this.isInside;
        }
        return true;
    }

    public final boolean setMin() {
        if (Math.abs(this.setMin.getMax) > this.hashCode) {
            return false;
        }
        return Math.abs(this.isInside - this.setMin.setMax) <= this.toString || this.setMax.length == 0.0d;
    }
}

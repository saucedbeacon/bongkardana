package o;

import android.graphics.DashPathEffect;
import com.github.mikephil.charting.components.LimitLine;
import java.util.ArrayList;
import java.util.List;

public abstract class getDrawerLockMode extends setDrawerTitle {
    protected boolean FastBitmap$CoordinateSystem = false;
    protected List<LimitLine> Grayscale$Algorithm;
    protected float ICustomTabsCallback = 0.0f;
    public int IsOverlapping = 6;
    public DashPathEffect Mean$Arithmetic = null;
    protected boolean b = false;
    protected boolean create = true;
    public int equals;
    protected boolean extraCallback = false;
    public float extraCallbackWithResult = 0.0f;
    protected float getCause = 0.0f;
    public int getMax = -7829368;
    protected closeDrawers getMin;
    protected boolean hashCode = true;
    protected boolean invoke = false;
    public DashPathEffect invokeSuspend = null;
    public int isInside;
    public float length = 1.0f;
    public float onMessageChannelReady = 0.0f;
    protected boolean onNavigationEvent = false;
    public float onPostMessage = 0.0f;
    public float setMax = 1.0f;
    public int setMin = -7829368;
    protected float toDoubleRange = 1.0f;
    public float[] toFloatRange = new float[0];
    public float[] toIntRange = new float[0];
    protected boolean toString = false;
    protected boolean valueOf = true;
    protected boolean values = true;

    public getDrawerLockMode() {
        this.ICustomTabsCallback$Stub = getTargetFragment.setMax(10.0f);
        this.asInterface = getTargetFragment.setMax(5.0f);
        this.ICustomTabsCallback$Default = getTargetFragment.setMax(5.0f);
        this.Grayscale$Algorithm = new ArrayList();
    }

    public final void length(boolean z) {
        this.hashCode = z;
    }

    public final boolean setMax() {
        return this.hashCode;
    }

    public final void getMax() {
        this.values = false;
    }

    public final boolean setMin() {
        return this.values;
    }

    public final boolean getMin() {
        return this.invoke && this.isInside > 0;
    }

    public final void getMax(boolean z) {
        this.valueOf = z;
    }

    public final boolean length() {
        return this.valueOf;
    }

    public final boolean equals() {
        return this.toString;
    }

    public final boolean toIntRange() {
        return this.FastBitmap$CoordinateSystem;
    }

    public final float IsOverlapping() {
        return this.toDoubleRange;
    }

    public final List<LimitLine> isInside() {
        return this.Grayscale$Algorithm;
    }

    public final boolean toFloatRange() {
        return this.onNavigationEvent;
    }

    public final void toDoubleRange() {
        this.create = true;
    }

    public final boolean FastBitmap$CoordinateSystem() {
        return this.create;
    }

    public final String values() {
        String str;
        int i = 0;
        String str2 = "";
        while (true) {
            float[] fArr = this.toIntRange;
            if (i >= fArr.length) {
                return str2;
            }
            if (i < 0 || i >= fArr.length) {
                str = "";
            } else {
                str = invoke().getMin(this.toIntRange[i]);
            }
            if (str != null && str2.length() < str.length()) {
                str2 = str;
            }
            i++;
        }
    }

    public final String getMax(int i) {
        return (i < 0 || i >= this.toIntRange.length) ? "" : invoke().getMin(this.toIntRange[i]);
    }

    public final void length(closeDrawers closedrawers) {
        this.getMin = closedrawers;
    }

    public final closeDrawers invoke() {
        closeDrawers closedrawers = this.getMin;
        if (closedrawers == null || ((closedrawers instanceof isDrawerView) && ((isDrawerView) closedrawers).setMax() != this.equals)) {
            this.getMin = new isDrawerView(this.equals);
        }
        return this.getMin;
    }

    public final void setMax(float f) {
        this.b = true;
        this.onPostMessage = f;
        this.extraCallbackWithResult = Math.abs(this.onMessageChannelReady - f);
    }

    public final void length(float f) {
        this.extraCallback = true;
        this.onMessageChannelReady = f;
        this.extraCallbackWithResult = Math.abs(f - this.onPostMessage);
    }

    public void setMax(float f, float f2) {
        float f3 = this.b ? this.onPostMessage : f - this.getCause;
        float f4 = this.extraCallback ? this.onMessageChannelReady : f2 + this.ICustomTabsCallback;
        if (Math.abs(f4 - f3) == 0.0f) {
            f4 += 1.0f;
            f3 -= 1.0f;
        }
        this.onPostMessage = f3;
        this.onMessageChannelReady = f4;
        this.extraCallbackWithResult = Math.abs(f4 - f3);
    }

    public final void Grayscale$Algorithm() {
        this.getCause = 0.5f;
    }

    public final void valueOf() {
        this.ICustomTabsCallback = 0.5f;
    }

    public final void setMin(int i, boolean z) {
        if (i > 25) {
            i = 25;
        }
        if (i < 2) {
            i = 2;
        }
        this.IsOverlapping = i;
        this.toString = false;
        this.toString = z;
    }
}

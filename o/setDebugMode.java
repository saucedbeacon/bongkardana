package o;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.VisibleForTesting;
import com.bumptech.glide.load.engine.DecodeJob;
import java.util.Map;
import o.addPreDrawListener;
import o.getConstraintSetNames;
import o.isInteractionEnabled;
import o.onNewStateAttachHandlers;
import o.setPositiveButtonIcon;

public final class setDebugMode implements getTransitionTimeMs, isInteractionEnabled.setMin, onNewStateAttachHandlers.length {
    private static final boolean length = Log.isLoggable("Engine", 2);
    private final setMin IsOverlapping;
    private final setTransitionListener getMax;
    private final isInteractionEnabled getMin;
    private final getDesignTool isInside;
    private final getMax setMax;
    private final getCurrentState setMin;
    private final getTransitionState toFloatRange;
    private final getMin toIntRange;

    public setDebugMode(isInteractionEnabled isinteractionenabled, getConstraintSetNames.setMin setmin, access$500 access_500, access$500 access_5002, access$500 access_5003, access$500 access_5004, boolean z) {
        this(isinteractionenabled, setmin, access_500, access_5002, access_5003, access_5004, z, (byte) 0);
    }

    @VisibleForTesting
    private setDebugMode(isInteractionEnabled isinteractionenabled, getConstraintSetNames.setMin setmin, access$500 access_500, access$500 access_5002, access$500 access_5003, access$500 access_5004, boolean z, byte b) {
        this.getMin = isinteractionenabled;
        this.toIntRange = new getMin(setmin);
        getTransitionState gettransitionstate = new getTransitionState(z);
        this.toFloatRange = gettransitionstate;
        synchronized (this) {
            synchronized (gettransitionstate) {
                gettransitionstate.setMin = this;
            }
        }
        this.setMin = new getCurrentState();
        this.getMax = new setTransitionListener();
        this.setMax = new getMax(access_500, access_5002, access_5003, access_5004, this, this);
        this.IsOverlapping = new setMin(this.toIntRange);
        this.isInside = new getDesignTool();
        isinteractionenabled.getMax((isInteractionEnabled.setMin) this);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:57:0x0187, code lost:
        return r0;
     */
    /* JADX WARNING: Removed duplicated region for block: B:34:0x00b8 A[Catch:{ all -> 0x00aa }] */
    /* JADX WARNING: Removed duplicated region for block: B:64:0x0196  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public final <R> o.setDebugMode.length setMax(o.setFirstHorizontalStyle r20, java.lang.Object r21, o.setPivotY r22, int r23, int r24, java.lang.Class<?> r25, java.lang.Class<R> r26, com.bumptech.glide.Priority r27, o.evaluate r28, java.util.Map<java.lang.Class<?>, o.updatePostLayout<?>> r29, boolean r30, boolean r31, o.MotionHelper r32, boolean r33, boolean r34, boolean r35, boolean r36, o.getDescendantRect r37, java.util.concurrent.Executor r38) {
        /*
            r19 = this;
            r7 = r19
            r0 = r20
            r6 = r21
            r5 = r22
            r4 = r23
            r3 = r24
            r2 = r27
            r1 = r28
            r15 = r32
            r14 = r36
            r13 = r37
            r12 = r38
            boolean r8 = length
            if (r8 == 0) goto L_0x0021
            long r8 = o.getDependencySortedChildren.setMax()
            goto L_0x0023
        L_0x0021:
            r8 = 0
        L_0x0023:
            r17 = r8
            o.getAnchorDpDt r11 = new o.getAnchorDpDt
            r8 = r11
            r9 = r21
            r10 = r22
            r4 = r11
            r11 = r23
            r12 = r24
            r13 = r29
            r14 = r25
            r15 = r26
            r16 = r32
            r8.<init>(r9, r10, r11, r12, r13, r14, r15, r16)
            monitor-enter(r19)
            if (r33 == 0) goto L_0x00ad
            o.getTransitionState r9 = r7.toFloatRange     // Catch:{ all -> 0x00aa }
            o.onNewStateAttachHandlers r9 = r9.getMin((o.setPivotY) r4)     // Catch:{ all -> 0x00aa }
            if (r9 == 0) goto L_0x004a
            r9.toIntRange()     // Catch:{ all -> 0x00aa }
        L_0x004a:
            if (r9 == 0) goto L_0x005e
            boolean r10 = length     // Catch:{ all -> 0x00aa }
            if (r10 == 0) goto L_0x0053
            o.getDependencySortedChildren.length(r17)     // Catch:{ all -> 0x00aa }
        L_0x0053:
            r11 = r23
            r13 = r1
            r14 = r2
            r15 = r4
            r12 = r5
            r8 = r6
            r10 = r9
            r9 = r3
            goto L_0x00b6
        L_0x005e:
            o.isInteractionEnabled r9 = r7.getMin     // Catch:{ all -> 0x00aa }
            o.fireTrigger r9 = r9.length(r4)     // Catch:{ all -> 0x00aa }
            if (r9 != 0) goto L_0x0070
            r11 = r23
            r13 = r1
            r14 = r2
            r9 = r3
            r15 = r4
            r12 = r5
            r8 = r6
            r10 = 0
            goto L_0x0096
        L_0x0070:
            boolean r10 = r9 instanceof o.onNewStateAttachHandlers     // Catch:{ all -> 0x00aa }
            if (r10 == 0) goto L_0x0080
            o.onNewStateAttachHandlers r9 = (o.onNewStateAttachHandlers) r9     // Catch:{ all -> 0x00aa }
            r11 = r23
            r13 = r1
            r14 = r2
            r15 = r4
            r12 = r5
            r8 = r6
            r10 = r9
            r9 = r3
            goto L_0x0096
        L_0x0080:
            o.onNewStateAttachHandlers r10 = new o.onNewStateAttachHandlers     // Catch:{ all -> 0x00aa }
            r11 = 1
            r12 = 1
            r13 = r1
            r1 = r10
            r14 = r2
            r2 = r9
            r9 = r3
            r3 = r11
            r11 = r23
            r15 = r4
            r4 = r12
            r12 = r5
            r5 = r15
            r8 = r6
            r6 = r19
            r1.<init>(r2, r3, r4, r5, r6)     // Catch:{ all -> 0x00aa }
        L_0x0096:
            if (r10 == 0) goto L_0x00a0
            r10.toIntRange()     // Catch:{ all -> 0x00aa }
            o.getTransitionState r1 = r7.toFloatRange     // Catch:{ all -> 0x00aa }
            r1.getMax(r15, r10)     // Catch:{ all -> 0x00aa }
        L_0x00a0:
            if (r10 == 0) goto L_0x00b5
            boolean r1 = length     // Catch:{ all -> 0x00aa }
            if (r1 == 0) goto L_0x00b6
            o.getDependencySortedChildren.length(r17)     // Catch:{ all -> 0x00aa }
            goto L_0x00b6
        L_0x00aa:
            r0 = move-exception
            goto L_0x0194
        L_0x00ad:
            r11 = r23
            r13 = r1
            r14 = r2
            r9 = r3
            r15 = r4
            r12 = r5
            r8 = r6
        L_0x00b5:
            r10 = 0
        L_0x00b6:
            if (r10 != 0) goto L_0x0196
            o.setTransitionListener r1 = r7.getMax     // Catch:{ all -> 0x00aa }
            r10 = r36
            if (r10 == 0) goto L_0x00c1
            java.util.Map<o.setPivotY, o.setScene<?>> r1 = r1.getMin     // Catch:{ all -> 0x00aa }
            goto L_0x00c3
        L_0x00c1:
            java.util.Map<o.setPivotY, o.setScene<?>> r1 = r1.setMin     // Catch:{ all -> 0x00aa }
        L_0x00c3:
            java.lang.Object r1 = r1.get(r15)     // Catch:{ all -> 0x00aa }
            o.setScene r1 = (o.setScene) r1     // Catch:{ all -> 0x00aa }
            if (r1 == 0) goto L_0x00e0
            r6 = r37
            r5 = r38
            r1.setMax((o.getDescendantRect) r6, (java.util.concurrent.Executor) r5)     // Catch:{ all -> 0x00aa }
            boolean r0 = length     // Catch:{ all -> 0x00aa }
            if (r0 == 0) goto L_0x00d9
            o.getDependencySortedChildren.length(r17)     // Catch:{ all -> 0x00aa }
        L_0x00d9:
            o.setDebugMode$length r0 = new o.setDebugMode$length     // Catch:{ all -> 0x00aa }
            r0.<init>(r6, r1)     // Catch:{ all -> 0x00aa }
            goto L_0x0186
        L_0x00e0:
            r6 = r37
            r5 = r38
            o.setDebugMode$getMax r1 = r7.setMax     // Catch:{ all -> 0x00aa }
            o.setPositiveButtonIcon$length<o.setScene<?>> r1 = r1.equals     // Catch:{ all -> 0x00aa }
            java.lang.Object r1 = r1.getMax()     // Catch:{ all -> 0x00aa }
            o.setScene r1 = (o.setScene) r1     // Catch:{ all -> 0x00aa }
            java.lang.String r2 = "Argument must not be null"
            if (r1 == 0) goto L_0x018e
            o.setScene r1 = (o.setScene) r1     // Catch:{ all -> 0x00aa }
            r2 = r15
            r3 = r33
            r4 = r34
            r5 = r35
            r6 = r36
            o.setScene r1 = r1.length(r2, r3, r4, r5, r6)     // Catch:{ all -> 0x00aa }
            o.setDebugMode$setMin r2 = r7.IsOverlapping     // Catch:{ all -> 0x00aa }
            o.setPositiveButtonIcon$length<com.bumptech.glide.load.engine.DecodeJob<?>> r3 = r2.setMin     // Catch:{ all -> 0x00aa }
            java.lang.Object r3 = r3.getMax()     // Catch:{ all -> 0x00aa }
            com.bumptech.glide.load.engine.DecodeJob r3 = (com.bumptech.glide.load.engine.DecodeJob) r3     // Catch:{ all -> 0x00aa }
            java.lang.String r4 = "Argument must not be null"
            if (r3 == 0) goto L_0x0188
            com.bumptech.glide.load.engine.DecodeJob r3 = (com.bumptech.glide.load.engine.DecodeJob) r3     // Catch:{ all -> 0x00aa }
            int r4 = r2.getMin     // Catch:{ all -> 0x00aa }
            int r5 = r4 + 1
            r2.getMin = r5     // Catch:{ all -> 0x00aa }
            o.requestLayout<R> r2 = r3.setMin     // Catch:{ all -> 0x00aa }
            com.bumptech.glide.load.engine.DecodeJob$getMin r5 = r3.setMax     // Catch:{ all -> 0x00aa }
            r2.setMax = r0     // Catch:{ all -> 0x00aa }
            r2.getMin = r8     // Catch:{ all -> 0x00aa }
            r2.hashCode = r12     // Catch:{ all -> 0x00aa }
            r2.getMax = r11     // Catch:{ all -> 0x00aa }
            r2.toFloatRange = r9     // Catch:{ all -> 0x00aa }
            r2.invoke = r13     // Catch:{ all -> 0x00aa }
            r6 = r25
            r2.equals = r6     // Catch:{ all -> 0x00aa }
            r2.IsOverlapping = r5     // Catch:{ all -> 0x00aa }
            r5 = r26
            r2.values = r5     // Catch:{ all -> 0x00aa }
            r2.toString = r14     // Catch:{ all -> 0x00aa }
            r5 = r32
            r2.isInside = r5     // Catch:{ all -> 0x00aa }
            r6 = r29
            r2.toIntRange = r6     // Catch:{ all -> 0x00aa }
            r6 = r30
            r2.valueOf = r6     // Catch:{ all -> 0x00aa }
            r6 = r31
            r2.invokeSuspend = r6     // Catch:{ all -> 0x00aa }
            r3.getMax = r0     // Catch:{ all -> 0x00aa }
            r3.IsOverlapping = r12     // Catch:{ all -> 0x00aa }
            r3.toFloatRange = r14     // Catch:{ all -> 0x00aa }
            r3.toIntRange = r15     // Catch:{ all -> 0x00aa }
            r3.equals = r11     // Catch:{ all -> 0x00aa }
            r3.isInside = r9     // Catch:{ all -> 0x00aa }
            r3.hashCode = r13     // Catch:{ all -> 0x00aa }
            r3.invokeSuspend = r10     // Catch:{ all -> 0x00aa }
            r3.toDoubleRange = r5     // Catch:{ all -> 0x00aa }
            r3.FastBitmap$CoordinateSystem = r1     // Catch:{ all -> 0x00aa }
            r3.toString = r4     // Catch:{ all -> 0x00aa }
            com.bumptech.glide.load.engine.DecodeJob$RunReason r0 = com.bumptech.glide.load.engine.DecodeJob.RunReason.INITIALIZE     // Catch:{ all -> 0x00aa }
            r3.values = r0     // Catch:{ all -> 0x00aa }
            r3.valueOf = r8     // Catch:{ all -> 0x00aa }
            o.setTransitionListener r0 = r7.getMax     // Catch:{ all -> 0x00aa }
            boolean r2 = r1.length()     // Catch:{ all -> 0x00aa }
            if (r2 == 0) goto L_0x016a
            java.util.Map<o.setPivotY, o.setScene<?>> r0 = r0.getMin     // Catch:{ all -> 0x00aa }
            goto L_0x016c
        L_0x016a:
            java.util.Map<o.setPivotY, o.setScene<?>> r0 = r0.setMin     // Catch:{ all -> 0x00aa }
        L_0x016c:
            r0.put(r15, r1)     // Catch:{ all -> 0x00aa }
            r0 = r37
            r2 = r38
            r1.setMax((o.getDescendantRect) r0, (java.util.concurrent.Executor) r2)     // Catch:{ all -> 0x00aa }
            r1.getMin(r3)     // Catch:{ all -> 0x00aa }
            boolean r2 = length     // Catch:{ all -> 0x00aa }
            if (r2 == 0) goto L_0x0180
            o.getDependencySortedChildren.length(r17)     // Catch:{ all -> 0x00aa }
        L_0x0180:
            o.setDebugMode$length r2 = new o.setDebugMode$length     // Catch:{ all -> 0x00aa }
            r2.<init>(r0, r1)     // Catch:{ all -> 0x00aa }
            r0 = r2
        L_0x0186:
            monitor-exit(r19)     // Catch:{ all -> 0x00aa }
            return r0
        L_0x0188:
            java.lang.NullPointerException r0 = new java.lang.NullPointerException     // Catch:{ all -> 0x00aa }
            r0.<init>(r4)     // Catch:{ all -> 0x00aa }
            throw r0     // Catch:{ all -> 0x00aa }
        L_0x018e:
            java.lang.NullPointerException r0 = new java.lang.NullPointerException     // Catch:{ all -> 0x00aa }
            r0.<init>(r2)     // Catch:{ all -> 0x00aa }
            throw r0     // Catch:{ all -> 0x00aa }
        L_0x0194:
            monitor-exit(r19)
            throw r0
        L_0x0196:
            r0 = r37
            monitor-exit(r19)
            com.bumptech.glide.load.DataSource r1 = com.bumptech.glide.load.DataSource.MEMORY_CACHE
            r0.length(r10, r1)
            r0 = 0
            return r0
        */
        throw new UnsupportedOperationException("Method not decompiled: o.setDebugMode.setMax(o.setFirstHorizontalStyle, java.lang.Object, o.setPivotY, int, int, java.lang.Class, java.lang.Class, com.bumptech.glide.Priority, o.evaluate, java.util.Map, boolean, boolean, o.MotionHelper, boolean, boolean, boolean, boolean, o.getDescendantRect, java.util.concurrent.Executor):o.setDebugMode$length");
    }

    public static void setMin(fireTrigger<?> firetrigger) {
        if (firetrigger instanceof onNewStateAttachHandlers) {
            ((onNewStateAttachHandlers) firetrigger).equals();
            return;
        }
        throw new IllegalArgumentException("Cannot release anything but an EngineResource");
    }

    public final synchronized void setMin(setScene<?> setscene, setPivotY setpivoty, onNewStateAttachHandlers<?> onnewstateattachhandlers) {
        Map<setPivotY, setScene<?>> map;
        if (onnewstateattachhandlers != null) {
            if (onnewstateattachhandlers.getMax()) {
                this.toFloatRange.getMax(setpivoty, onnewstateattachhandlers);
            }
        }
        setTransitionListener settransitionlistener = this.getMax;
        if (setscene.length()) {
            map = settransitionlistener.getMin;
        } else {
            map = settransitionlistener.setMin;
        }
        if (setscene.equals(map.get(setpivoty))) {
            map.remove(setpivoty);
        }
    }

    public final synchronized void length(setScene<?> setscene, setPivotY setpivoty) {
        Map<setPivotY, setScene<?>> map;
        setTransitionListener settransitionlistener = this.getMax;
        if (setscene.length()) {
            map = settransitionlistener.getMin;
        } else {
            map = settransitionlistener.setMin;
        }
        if (setscene.equals(map.get(setpivoty))) {
            map.remove(setpivoty);
        }
    }

    public final void getMin(@NonNull fireTrigger<?> firetrigger) {
        this.isInside.setMax(firetrigger, true);
    }

    public final void setMax(setPivotY setpivoty, onNewStateAttachHandlers<?> onnewstateattachhandlers) {
        this.toFloatRange.setMin(setpivoty);
        if (onnewstateattachhandlers.getMax()) {
            this.getMin.setMin(setpivoty, onnewstateattachhandlers);
        } else {
            this.isInside.setMax(onnewstateattachhandlers, false);
        }
    }

    public class length {
        public final getDescendantRect getMax;
        public final setScene<?> getMin;

        length(getDescendantRect getdescendantrect, setScene<?> setscene) {
            this.getMax = getdescendantrect;
            this.getMin = setscene;
        }
    }

    static class getMin implements DecodeJob.getMin {
        private final getConstraintSetNames.setMin getMax;
        private volatile getConstraintSetNames length;

        getMin(getConstraintSetNames.setMin setmin) {
            this.getMax = setmin;
        }

        public final getConstraintSetNames getMin() {
            if (this.length == null) {
                synchronized (this) {
                    if (this.length == null) {
                        this.length = this.getMax.setMax();
                    }
                    if (this.length == null) {
                        this.length = new disableAutoTransition();
                    }
                }
            }
            return this.length;
        }
    }

    @VisibleForTesting
    static class setMin {
        final DecodeJob.getMin getMax;
        int getMin;
        final setPositiveButtonIcon.length<DecodeJob<?>> setMin = addPreDrawListener.getMin(150, new addPreDrawListener.getMax<DecodeJob<?>>() {
            public final /* synthetic */ Object setMax() {
                return new DecodeJob(setMin.this.getMax, setMin.this.setMin);
            }
        });

        setMin(DecodeJob.getMin getmin) {
            this.getMax = getmin;
        }
    }

    @VisibleForTesting
    static class getMax {
        final setPositiveButtonIcon.length<setScene<?>> equals = addPreDrawListener.getMin(150, new addPreDrawListener.getMax<setScene<?>>() {
            public final /* synthetic */ Object setMax() {
                return new setScene(getMax.this.getMin, getMax.this.length, getMax.this.setMin, getMax.this.setMax, getMax.this.getMax, getMax.this.toIntRange, getMax.this.equals);
            }
        });
        final getTransitionTimeMs getMax;
        final access$500 getMin;
        final access$500 length;
        final access$500 setMax;
        final access$500 setMin;
        final onNewStateAttachHandlers.length toIntRange;

        getMax(access$500 access_500, access$500 access_5002, access$500 access_5003, access$500 access_5004, getTransitionTimeMs gettransitiontimems, onNewStateAttachHandlers.length length2) {
            this.getMin = access_500;
            this.length = access_5002;
            this.setMin = access_5003;
            this.setMax = access_5004;
            this.getMax = gettransitiontimems;
            this.toIntRange = length2;
        }
    }
}

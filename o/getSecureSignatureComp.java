package o;

import io.reactivex.annotations.NonNull;
import java.util.concurrent.Callable;
import java.util.concurrent.Executor;

public final class getSecureSignatureComp {
    @NonNull
    static final hasCornerMarking getMax = getAssetManager.setMin();
    @NonNull
    static final hasCornerMarking getMin;
    @NonNull
    static final hasCornerMarking length;
    @NonNull
    static final hasCornerMarking setMax;
    @NonNull
    static final hasCornerMarking setMin;

    static final class equals {
        static final hasCornerMarking getMin = new getPackageInfo();

        equals() {
        }
    }

    static final class setMin {
        static final hasCornerMarking getMax = new performLastSegItemChecked();

        setMin() {
        }
    }

    static final class getMin {
        static final hasCornerMarking getMin = new NebulaTabbarUtils();

        getMin() {
        }
    }

    static final class getMax {
        static final hasCornerMarking length = new setViewVisibility();

        getMax() {
        }
    }

    static {
        hasCornerMarking hascornermarking;
        hasCornerMarking hascornermarking2;
        hasCornerMarking hascornermarking3;
        hasCornerMarking hascornermarking4;
        isInside isinside = new isInside();
        setRefreshAnimation.getMax(isinside, "Scheduler Callable can't be null");
        RedDotDrawable<? super Callable<hasCornerMarking>, ? extends hasCornerMarking> redDotDrawable = SecuritySignature.length;
        if (redDotDrawable == null) {
            hascornermarking = SecuritySignature.getMax((Callable<hasCornerMarking>) isinside);
        } else {
            hascornermarking = (hasCornerMarking) setRefreshAnimation.getMax(SecuritySignature.getMax(redDotDrawable, isinside), "Scheduler Callable result can't be null");
        }
        setMax = hascornermarking;
        setMax setmax = new setMax();
        setRefreshAnimation.getMax(setmax, "Scheduler Callable can't be null");
        RedDotDrawable<? super Callable<hasCornerMarking>, ? extends hasCornerMarking> redDotDrawable2 = SecuritySignature.setMin;
        if (redDotDrawable2 == null) {
            hascornermarking2 = SecuritySignature.getMax((Callable<hasCornerMarking>) setmax);
        } else {
            hascornermarking2 = (hasCornerMarking) setRefreshAnimation.getMax(SecuritySignature.getMax(redDotDrawable2, setmax), "Scheduler Callable result can't be null");
        }
        setMin = hascornermarking2;
        length length2 = new length();
        setRefreshAnimation.getMax(length2, "Scheduler Callable can't be null");
        RedDotDrawable<? super Callable<hasCornerMarking>, ? extends hasCornerMarking> redDotDrawable3 = SecuritySignature.getMin;
        if (redDotDrawable3 == null) {
            hascornermarking3 = SecuritySignature.getMax((Callable<hasCornerMarking>) length2);
        } else {
            hascornermarking3 = (hasCornerMarking) setRefreshAnimation.getMax(SecuritySignature.getMax(redDotDrawable3, length2), "Scheduler Callable result can't be null");
        }
        getMin = hascornermarking3;
        IsOverlapping isOverlapping = new IsOverlapping();
        setRefreshAnimation.getMax(isOverlapping, "Scheduler Callable can't be null");
        RedDotDrawable<? super Callable<hasCornerMarking>, ? extends hasCornerMarking> redDotDrawable4 = SecuritySignature.isInside;
        if (redDotDrawable4 == null) {
            hascornermarking4 = SecuritySignature.getMax((Callable<hasCornerMarking>) isOverlapping);
        } else {
            hascornermarking4 = (hasCornerMarking) setRefreshAnimation.getMax(SecuritySignature.getMax(redDotDrawable4, isOverlapping), "Scheduler Callable result can't be null");
        }
        length = hascornermarking4;
    }

    @NonNull
    public static hasCornerMarking getMin() {
        hasCornerMarking hascornermarking = setMin;
        RedDotDrawable<? super hasCornerMarking, ? extends hasCornerMarking> redDotDrawable = SecuritySignature.toIntRange;
        if (redDotDrawable == null) {
            return hascornermarking;
        }
        return (hasCornerMarking) SecuritySignature.getMax(redDotDrawable, hascornermarking);
    }

    @NonNull
    public static hasCornerMarking setMin() {
        hasCornerMarking hascornermarking = getMin;
        RedDotDrawable<? super hasCornerMarking, ? extends hasCornerMarking> redDotDrawable = SecuritySignature.IsOverlapping;
        if (redDotDrawable == null) {
            return hascornermarking;
        }
        return (hasCornerMarking) SecuritySignature.getMax(redDotDrawable, hascornermarking);
    }

    @NonNull
    public static hasCornerMarking getMax() {
        return getMax;
    }

    @NonNull
    public static hasCornerMarking length() {
        hasCornerMarking hascornermarking = length;
        RedDotDrawable<? super hasCornerMarking, ? extends hasCornerMarking> redDotDrawable = SecuritySignature.equals;
        if (redDotDrawable == null) {
            return hascornermarking;
        }
        return (hasCornerMarking) SecuritySignature.getMax(redDotDrawable, hascornermarking);
    }

    @NonNull
    public static hasCornerMarking setMax() {
        hasCornerMarking hascornermarking = setMax;
        RedDotDrawable<? super hasCornerMarking, ? extends hasCornerMarking> redDotDrawable = SecuritySignature.toFloatRange;
        if (redDotDrawable == null) {
            return hascornermarking;
        }
        return (hasCornerMarking) SecuritySignature.getMax(redDotDrawable, hascornermarking);
    }

    @NonNull
    public static hasCornerMarking setMin(@NonNull Executor executor) {
        return new H5ViewStubUtil(executor);
    }

    static final class length implements Callable<hasCornerMarking> {
        length() {
        }

        public final /* bridge */ /* synthetic */ Object call() throws Exception {
            return getMin.getMin;
        }
    }

    static final class IsOverlapping implements Callable<hasCornerMarking> {
        IsOverlapping() {
        }

        public final /* bridge */ /* synthetic */ Object call() throws Exception {
            return getMax.length;
        }
    }

    static final class isInside implements Callable<hasCornerMarking> {
        isInside() {
        }

        public final /* bridge */ /* synthetic */ Object call() throws Exception {
            return equals.getMin;
        }
    }

    static final class setMax implements Callable<hasCornerMarking> {
        setMax() {
        }

        public final /* bridge */ /* synthetic */ Object call() throws Exception {
            return setMin.getMax;
        }
    }
}

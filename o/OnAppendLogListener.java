package o;

import androidx.annotation.NonNull;
import java.util.ArrayList;
import java.util.List;
import kotlin.text.Typography;
import org.commonmark.ext.gfm.tables.TableCell;
import ru.noties.markwon.spans.TableRowSpan;

public final class OnAppendLogListener extends getThreadPool {
    private boolean IsOverlapping;
    private int equals;
    private final maybeForceBuilderInitialization getMax;
    private final appendFlushLog getMin;
    private int isInside;
    private final DiagnoseLogAppender length;
    private final getCurrentLogsDir setMax;
    private final EncryptAppender setMin;
    private int toFloatRange;
    private List<TableRowSpan.getMin> toIntRange;

    public OnAppendLogListener(@NonNull appendFlushLog appendflushlog, @NonNull DiagnoseLogAppender diagnoseLogAppender) {
        this.getMin = appendflushlog;
        this.length = diagnoseLogAppender;
        this.setMin = appendflushlog.toIntRange;
        this.getMax = appendflushlog.setMax;
        this.setMax = appendflushlog.isInside;
    }

    public final void setMin(encodeBytesToBytes encodebytestobytes) {
        super.setMin(encodebytestobytes);
        this.getMin.equals.getMax(this.getMin, this.length, this.setMin);
    }

    public final void setMax(WSContextUtil wSContextUtil) {
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        diagnoseLogAppender.setMin.append(wSContextUtil.getMin);
    }

    public final void length(utf8Bytes utf8bytes) {
        int length2 = this.length.length();
        Base64$OutputStream base64$OutputStream = utf8bytes.toIntRange;
        while (base64$OutputStream != null) {
            Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
            base64$OutputStream.setMax(this);
            base64$OutputStream = base64$OutputStream2;
        }
        Object length3 = this.setMax.length();
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender, length3, length2, diagnoseLogAppender.length());
    }

    public final void length(decode4to3 decode4to3) {
        int length2 = this.length.length();
        Base64$OutputStream base64$OutputStream = decode4to3.toIntRange;
        while (base64$OutputStream != null) {
            Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
            base64$OutputStream.setMax(this);
            base64$OutputStream = base64$OutputStream2;
        }
        Object min = this.setMax.getMin();
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender, min, length2, diagnoseLogAppender.length());
    }

    public final void setMax(getAlphabet getalphabet) {
        getMax();
        if (this.toFloatRange != 0) {
            this.length.setMin.append(10);
        }
        int length2 = this.length.length();
        this.toFloatRange++;
        Base64$OutputStream base64$OutputStream = getalphabet.toIntRange;
        while (base64$OutputStream != null) {
            Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
            base64$OutputStream.setMax(this);
            base64$OutputStream = base64$OutputStream2;
        }
        Object min = this.setMax.getMin(this.getMax);
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender, min, length2, diagnoseLogAppender.length());
        this.toFloatRange--;
        if (getMin((Base64$OutputStream) getalphabet)) {
            getMax();
            if (this.toFloatRange == 0) {
                this.length.setMin.append(10);
            }
        }
    }

    public final void setMax(encode3to4 encode3to4) {
        int length2 = this.length.length();
        this.length.setMin.append(Typography.nbsp);
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        diagnoseLogAppender.setMin.append(encode3to4.length);
        this.length.setMin.append(Typography.nbsp);
        Object length3 = this.setMax.length(this.getMax, false);
        DiagnoseLogAppender diagnoseLogAppender2 = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender2, length3, length2, diagnoseLogAppender2.length());
    }

    private void getMin(@NonNull String str, @NonNull Base64$OutputStream base64$OutputStream) {
        getMax();
        int length2 = this.length.length();
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        diagnoseLogAppender.setMin.append(Typography.nbsp);
        diagnoseLogAppender.setMin.append(10);
        DiagnoseLogAppender diagnoseLogAppender2 = this.length;
        CharSequence min = this.getMin.length.getMin(str);
        diagnoseLogAppender2.getMax(diagnoseLogAppender2.length(), min);
        diagnoseLogAppender2.setMin.append(min);
        getMax();
        this.length.setMin.append(Typography.nbsp);
        Object length3 = this.setMax.length(this.getMax, true);
        DiagnoseLogAppender diagnoseLogAppender3 = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender3, length3, length2, diagnoseLogAppender3.length());
        if (getMin(base64$OutputStream)) {
            getMax();
            this.length.setMin.append(10);
        }
    }

    public final void getMax(encodeObject encodeobject) {
        length((Base64$OutputStream) encodeobject);
    }

    public final void setMin(Charsetfunctions charsetfunctions) {
        length((Base64$OutputStream) charsetfunctions);
    }

    private void length(Base64$OutputStream base64$OutputStream) {
        getMax();
        Base64$OutputStream base64$OutputStream2 = base64$OutputStream.toIntRange;
        while (base64$OutputStream2 != null) {
            Base64$OutputStream base64$OutputStream3 = base64$OutputStream2.IsOverlapping;
            base64$OutputStream2.setMax(this);
            base64$OutputStream2 = base64$OutputStream3;
        }
        if (getMin(base64$OutputStream)) {
            getMax();
            if (this.equals == 0 && this.toFloatRange == 0) {
                this.length.setMin.append(10);
            }
        }
    }

    public final void length(flushBase64 flushbase64) {
        int length2 = this.length.length();
        this.toFloatRange++;
        this.equals++;
        SCNetworkAsyncTaskExecutorFactory length3 = flushbase64.length();
        if (length3 instanceof Charsetfunctions) {
            Charsetfunctions charsetfunctions = (Charsetfunctions) length3;
            int i = charsetfunctions.length;
            Base64$OutputStream base64$OutputStream = flushbase64.toIntRange;
            while (base64$OutputStream != null) {
                Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
                base64$OutputStream.setMax(this);
                base64$OutputStream = base64$OutputStream2;
            }
            Object length4 = this.setMax.length(this.getMax, i);
            DiagnoseLogAppender diagnoseLogAppender = this.length;
            DiagnoseLogAppender.getMax(diagnoseLogAppender, length4, length2, diagnoseLogAppender.length());
            charsetfunctions.length++;
        } else {
            Base64$OutputStream base64$OutputStream3 = flushbase64.toIntRange;
            while (base64$OutputStream3 != null) {
                Base64$OutputStream base64$OutputStream4 = base64$OutputStream3.IsOverlapping;
                base64$OutputStream3.setMax(this);
                base64$OutputStream3 = base64$OutputStream4;
            }
            Object min = this.setMax.setMin(this.getMax, this.equals - 1);
            DiagnoseLogAppender diagnoseLogAppender2 = this.length;
            DiagnoseLogAppender.getMax(diagnoseLogAppender2, min, length2, diagnoseLogAppender2.length());
        }
        this.toFloatRange--;
        this.equals--;
        if (getMin((Base64$OutputStream) flushbase64)) {
            getMax();
        }
    }

    public final void getMax(stringUtf8 stringutf8) {
        getMax();
        int length2 = this.length.length();
        this.length.setMin.append(Typography.nbsp);
        Object min = this.setMax.setMin(this.getMax);
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender, min, length2, diagnoseLogAppender.length());
        if (getMin((Base64$OutputStream) stringutf8)) {
            getMax();
            this.length.setMin.append(10);
        }
    }

    public final void getMin(encodeToFile encodetofile) {
        getMax();
        int length2 = this.length.length();
        Base64$OutputStream base64$OutputStream = encodetofile.toIntRange;
        while (base64$OutputStream != null) {
            Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
            base64$OutputStream.setMax(this);
            base64$OutputStream = base64$OutputStream2;
        }
        Object max = this.setMax.setMax(this.getMax, encodetofile.setMin);
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender, max, length2, diagnoseLogAppender.length());
        if (getMin((Base64$OutputStream) encodetofile)) {
            getMax();
            this.length.setMin.append(10);
        }
    }

    public final void length(resumeEncoding resumeencoding) {
        if (this.getMin.getMax()) {
            getMax();
        } else {
            this.length.setMin.append(' ');
        }
    }

    public final void getMax(decodeToFile decodetofile) {
        getMax();
    }

    public final void setMin(getDecodabet getdecodabet) {
        if (getdecodabet instanceof clearAppVersion) {
            this.toFloatRange++;
            Base64$OutputStream base64$OutputStream = getdecodabet.toIntRange;
            while (base64$OutputStream != null) {
                Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
                base64$OutputStream.setMax(this);
                base64$OutputStream = base64$OutputStream2;
            }
            this.toFloatRange--;
            if (getMin((Base64$OutputStream) getdecodabet)) {
                getMax();
                this.length.setMin.append(10);
                return;
            }
            return;
        }
        super.setMin(getdecodabet);
    }

    public final void setMin(encodeBytes encodebytes) {
        if (encodebytes instanceof appendSSLTime) {
            int length2 = this.length.length();
            Base64$OutputStream base64$OutputStream = encodebytes.toIntRange;
            while (base64$OutputStream != null) {
                Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
                base64$OutputStream.setMax(this);
                base64$OutputStream = base64$OutputStream2;
            }
            Object max = this.setMax.setMax();
            DiagnoseLogAppender diagnoseLogAppender = this.length;
            DiagnoseLogAppender.getMax(diagnoseLogAppender, max, length2, diagnoseLogAppender.length());
        } else if (encodebytes instanceof ConfigChangeBroadCastReceiver) {
            ConfigChangeBroadCastReceiver configChangeBroadCastReceiver = (ConfigChangeBroadCastReceiver) encodebytes;
            int length3 = this.length.length();
            this.toFloatRange += configChangeBroadCastReceiver.getMax;
            Base64$OutputStream base64$OutputStream3 = encodebytes.toIntRange;
            while (base64$OutputStream3 != null) {
                Base64$OutputStream base64$OutputStream4 = base64$OutputStream3.IsOverlapping;
                base64$OutputStream3.setMax(this);
                base64$OutputStream3 = base64$OutputStream4;
            }
            Object min = this.setMax.getMin(this.getMax, this.toFloatRange, configChangeBroadCastReceiver.getMax());
            DiagnoseLogAppender diagnoseLogAppender2 = this.length;
            DiagnoseLogAppender.getMax(diagnoseLogAppender2, min, length3, diagnoseLogAppender2.length());
            if (getMin((Base64$OutputStream) encodebytes)) {
                getMax();
            }
            this.toFloatRange -= configChangeBroadCastReceiver.getMax;
        } else if (!getMin(encodebytes)) {
            super.setMin(encodebytes);
        }
    }

    private boolean getMin(encodeBytes encodebytes) {
        int i = 0;
        if (encodebytes instanceof appendTargetHost) {
            Base64$OutputStream base64$OutputStream = encodebytes.toIntRange;
            while (base64$OutputStream != null) {
                Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
                base64$OutputStream.setMax(this);
                base64$OutputStream = base64$OutputStream2;
            }
            this.isInside = 0;
            if (getMin((Base64$OutputStream) encodebytes)) {
                getMax();
                this.length.setMin.append(10);
            }
        } else if ((encodebytes instanceof PlatformUtil) || (encodebytes instanceof SimpleStatistical)) {
            int length2 = this.length.length();
            Base64$OutputStream base64$OutputStream3 = encodebytes.toIntRange;
            while (base64$OutputStream3 != null) {
                Base64$OutputStream base64$OutputStream4 = base64$OutputStream3.IsOverlapping;
                base64$OutputStream3.setMax(this);
                base64$OutputStream3 = base64$OutputStream4;
            }
            if (this.toIntRange != null) {
                int length3 = this.length.length();
                boolean z = length3 > 0 && 10 != this.length.charAt(length3 - 1);
                if (z) {
                    this.length.setMin.append(10);
                }
                this.length.setMin.append(Typography.nbsp);
                Object max = this.setMax.setMax(this.getMax, this.toIntRange, this.IsOverlapping, this.isInside % 2 == 1);
                if (!this.IsOverlapping) {
                    i = this.isInside + 1;
                }
                this.isInside = i;
                if (z) {
                    length2++;
                }
                DiagnoseLogAppender diagnoseLogAppender = this.length;
                DiagnoseLogAppender.getMax(diagnoseLogAppender, max, length2, diagnoseLogAppender.length());
                this.toIntRange = null;
            }
        } else if (!(encodebytes instanceof TableCell)) {
            return false;
        } else {
            TableCell tableCell = (TableCell) encodebytes;
            int length4 = this.length.length();
            Base64$OutputStream base64$OutputStream5 = tableCell.toIntRange;
            while (base64$OutputStream5 != null) {
                Base64$OutputStream base64$OutputStream6 = base64$OutputStream5.IsOverlapping;
                base64$OutputStream5.setMax(this);
                base64$OutputStream5 = base64$OutputStream6;
            }
            if (this.toIntRange == null) {
                this.toIntRange = new ArrayList(2);
            }
            List<TableRowSpan.getMin> list = this.toIntRange;
            TableCell.Alignment alignment = tableCell.getMin;
            if (alignment != null) {
                int i2 = AnonymousClass5.getMin[alignment.ordinal()];
                if (i2 == 1) {
                    i = 1;
                } else if (i2 == 2) {
                    i = 2;
                }
            }
            list.add(new TableRowSpan.getMin(i, this.length.getMax(length4)));
            this.IsOverlapping = tableCell.setMax();
        }
        return true;
    }

    public final void setMax(suspendEncoding suspendencoding) {
        boolean min = setMin(suspendencoding);
        if (!min) {
            getMax();
        }
        int length2 = this.length.length();
        Base64$OutputStream base64$OutputStream = suspendencoding.toIntRange;
        while (base64$OutputStream != null) {
            Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
            base64$OutputStream.setMax(this);
            base64$OutputStream = base64$OutputStream2;
        }
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender, (Object) null, length2, diagnoseLogAppender.length());
        if (getMin((Base64$OutputStream) suspendencoding) && !min) {
            getMax();
            if (this.toFloatRange == 0) {
                this.length.setMin.append(10);
            }
        }
    }

    public final void setMax(Base64$InputStream base64$InputStream) {
        int length2 = this.length.length();
        Base64$OutputStream base64$OutputStream = base64$InputStream.toIntRange;
        while (base64$OutputStream != null) {
            Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
            base64$OutputStream.setMax(this);
            base64$OutputStream = base64$OutputStream2;
        }
        if (length2 == this.length.length()) {
            this.length.setMin.append(65532);
        }
        Base64$OutputStream min = base64$InputStream.getMin();
        Object max = this.setMax.setMax(this.getMax, this.getMin.getMin.setMax(base64$InputStream.getMin), this.getMin.setMin, this.getMin.toFloatRange, (getUploadFile) null, min != null && (min instanceof decodeFileToFile));
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender, max, length2, diagnoseLogAppender.length());
    }

    public final void getMax(decodeFileToFile decodefiletofile) {
        int length2 = this.length.length();
        Base64$OutputStream base64$OutputStream = decodefiletofile.toIntRange;
        while (base64$OutputStream != null) {
            Base64$OutputStream base64$OutputStream2 = base64$OutputStream.IsOverlapping;
            base64$OutputStream.setMax(this);
            base64$OutputStream = base64$OutputStream2;
        }
        Object min = this.setMax.setMin(this.getMax, this.getMin.getMin.setMax(decodefiletofile.getMax), this.getMin.getMax);
        DiagnoseLogAppender diagnoseLogAppender = this.length;
        DiagnoseLogAppender.getMax(diagnoseLogAppender, min, length2, diagnoseLogAppender.length());
    }

    private void getMax() {
        if (this.length.length() > 0 && 10 != this.length.getMin()) {
            this.length.setMin.append(10);
        }
    }

    private static boolean setMin(suspendEncoding suspendencoding) {
        Base64$OutputStream min;
        SCNetworkAsyncTaskExecutorFactory length2 = suspendencoding.length();
        if (length2 == null || (min = length2.getMin()) == null || !(min instanceof Base64$1)) {
            return false;
        }
        return ((Base64$1) min).getMax();
    }

    /* renamed from: o.OnAppendLogListener$5  reason: invalid class name */
    static /* synthetic */ class AnonymousClass5 {
        static final /* synthetic */ int[] getMin;

        /* JADX WARNING: Can't wrap try/catch for region: R(6:0|1|2|3|4|6) */
        /* JADX WARNING: Code restructure failed: missing block: B:7:?, code lost:
            return;
         */
        /* JADX WARNING: Failed to process nested try/catch */
        /* JADX WARNING: Missing exception handler attribute for start block: B:3:0x0012 */
        static {
            /*
                org.commonmark.ext.gfm.tables.TableCell$Alignment[] r0 = org.commonmark.ext.gfm.tables.TableCell.Alignment.values()
                int r0 = r0.length
                int[] r0 = new int[r0]
                getMin = r0
                org.commonmark.ext.gfm.tables.TableCell$Alignment r1 = org.commonmark.ext.gfm.tables.TableCell.Alignment.CENTER     // Catch:{ NoSuchFieldError -> 0x0012 }
                int r1 = r1.ordinal()     // Catch:{ NoSuchFieldError -> 0x0012 }
                r2 = 1
                r0[r1] = r2     // Catch:{ NoSuchFieldError -> 0x0012 }
            L_0x0012:
                int[] r0 = getMin     // Catch:{ NoSuchFieldError -> 0x001d }
                org.commonmark.ext.gfm.tables.TableCell$Alignment r1 = org.commonmark.ext.gfm.tables.TableCell.Alignment.RIGHT     // Catch:{ NoSuchFieldError -> 0x001d }
                int r1 = r1.ordinal()     // Catch:{ NoSuchFieldError -> 0x001d }
                r2 = 2
                r0[r1] = r2     // Catch:{ NoSuchFieldError -> 0x001d }
            L_0x001d:
                return
            */
            throw new UnsupportedOperationException("Method not decompiled: o.OnAppendLogListener.AnonymousClass5.<clinit>():void");
        }
    }

    public final void setMax(decodeToObject decodetoobject) {
        getMin(decodetoobject.getMin, decodetoobject);
    }

    public final void getMin(encodeFromFile encodefromfile) {
        getMin(encodefromfile.getMin, encodefromfile);
    }

    public final void getMax(decodeFromFile decodefromfile) {
        String str = decodefromfile.length;
        if (str != null) {
            this.setMin.setMin(this.length, str);
        }
    }

    public final void getMax(encodeFileToFile encodefiletofile) {
        String str = encodefiletofile.length;
        if (str != null) {
            this.setMin.setMin(this.length, str);
        }
    }

    private static boolean getMin(@NonNull Base64$OutputStream base64$OutputStream) {
        return base64$OutputStream.IsOverlapping != null;
    }
}

package o;

import androidx.annotation.NonNull;
import com.bumptech.glide.load.DataSource;
import java.io.File;
import java.util.List;
import o.SolverVariable$Type;
import o.getViewVelocity;
import o.isUseOnHide;

public final class addTransitionListener implements getViewVelocity, isUseOnHide.getMin<Object> {
    private File IsOverlapping;
    private volatile SolverVariable$Type.setMax<?> equals;
    private final requestLayout<?> getMax;
    private setPivotY getMin;
    private List<SolverVariable$Type<File, ?>> isInside;
    private int length = -1;
    private final getViewVelocity.setMin setMax;
    private int setMin;
    private onViewRemoved toFloatRange;
    private int toIntRange;

    public addTransitionListener(requestLayout<?> requestlayout, getViewVelocity.setMin setmin) {
        this.getMax = requestlayout;
        this.setMax = setmin;
    }

    public final boolean setMax() {
        List<setPivotY> max = this.getMax.setMax();
        boolean z = false;
        if (max.isEmpty()) {
            return false;
        }
        requestLayout<?> requestlayout = this.getMax;
        List<Class<?>> min = requestlayout.setMax.length.getMin(requestlayout.getMin.getClass(), requestlayout.equals, requestlayout.values);
        if (!min.isEmpty()) {
            while (true) {
                if (this.isInside == null || !getMin()) {
                    int i = this.length + 1;
                    this.length = i;
                    if (i >= min.size()) {
                        int i2 = this.setMin + 1;
                        this.setMin = i2;
                        if (i2 >= max.size()) {
                            return false;
                        }
                        this.length = 0;
                    }
                    setPivotY setpivoty = max.get(this.setMin);
                    Class cls = min.get(this.length);
                    setPivotY setpivoty2 = setpivoty;
                    this.toFloatRange = new onViewRemoved(this.getMax.setMax.setMax, setpivoty2, this.getMax.hashCode, this.getMax.getMax, this.getMax.toFloatRange, this.getMax.getMin(cls), cls, this.getMax.isInside);
                    File min2 = this.getMax.IsOverlapping.getMin().getMin(this.toFloatRange);
                    this.IsOverlapping = min2;
                    if (min2 != null) {
                        this.getMin = setpivoty;
                        this.isInside = this.getMax.setMax.length.getMax(min2);
                        this.toIntRange = 0;
                    }
                } else {
                    this.equals = null;
                    while (!z && getMin()) {
                        List<SolverVariable$Type<File, ?>> list = this.isInside;
                        int i3 = this.toIntRange;
                        this.toIntRange = i3 + 1;
                        this.equals = list.get(i3).setMin(this.IsOverlapping, this.getMax.getMax, this.getMax.toFloatRange, this.getMax.isInside);
                        if (this.equals != null && this.getMax.getMax(this.equals.getMax.setMax())) {
                            this.equals.getMax.getMin(this.getMax.toString, this);
                            z = true;
                        }
                    }
                    return z;
                }
            }
        } else if (File.class.equals(this.getMax.values)) {
            return false;
        } else {
            StringBuilder sb = new StringBuilder("Failed to find any load path from ");
            sb.append(this.getMax.getMin.getClass());
            sb.append(" to ");
            sb.append(this.getMax.values);
            throw new IllegalStateException(sb.toString());
        }
    }

    private boolean getMin() {
        return this.toIntRange < this.isInside.size();
    }

    public final void getMax() {
        SolverVariable$Type.setMax<?> setmax = this.equals;
        if (setmax != null) {
            setmax.getMax.getMax();
        }
    }

    public final void getMax(Object obj) {
        this.setMax.setMin(this.getMin, obj, this.equals.getMax, DataSource.RESOURCE_DISK_CACHE, this.toFloatRange);
    }

    public final void setMax(@NonNull Exception exc) {
        this.setMax.setMin(this.toFloatRange, exc, this.equals.getMax, DataSource.RESOURCE_DISK_CACHE);
    }
}

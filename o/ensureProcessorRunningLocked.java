package o;

import android.content.Context;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import androidx.annotation.AttrRes;
import androidx.annotation.Nullable;
import androidx.annotation.StyleRes;
import androidx.annotation.VisibleForTesting;
import com.facebook.infer.annotation.ThreadConfined;
import com.facebook.litho.ComponentTree;
import com.facebook.litho.ComponentsLogger;
import o.dispatchNestedPreFling;

public class ensureProcessorRunningLocked {
    public static final sendAccessibilityEvent length = new ViewCompat$NestedScrollType();
    @StyleRes
    @ThreadConfined("ANY")
    int FastBitmap$CoordinateSystem;
    @ThreadConfined("ANY")
    public isStopped IsOverlapping;
    @ThreadConfined("ANY")
    final getTopFadingEdgeStrength equals;
    @Nullable
    final onScrollChanged getMax;
    public final ComponentsLogger getMin;
    @ThreadConfined("ANY")
    public int hashCode;
    @ThreadConfined("ANY")
    public int isInside;
    final String setMax;
    public final Context setMin;
    @ThreadConfined("ANY")
    @Nullable
    public computeVerticalScrollExtent toDoubleRange;
    @Nullable
    final getActionList toFloatRange;
    public String toIntRange;
    @ThreadConfined("ANY")
    public ComponentTree toString;
    @AttrRes
    @ThreadConfined("ANY")
    int values;

    private ensureProcessorRunningLocked(Context context, byte b) {
        this.FastBitmap$CoordinateSystem = 0;
        this.values = 0;
        this.setMin = context;
        this.equals = getTopFadingEdgeStrength.setMax(context.getResources().getConfiguration());
        this.toDoubleRange = null;
        this.getMin = null;
        this.setMax = null;
        this.getMax = null;
        this.toFloatRange = null;
    }

    public ensureProcessorRunningLocked(ensureProcessorRunningLocked ensureprocessorrunninglocked, @Nullable onScrollChanged onscrollchanged, @Nullable getActionList getactionlist, @Nullable computeVerticalScrollExtent computeverticalscrollextent) {
        this.FastBitmap$CoordinateSystem = 0;
        this.values = 0;
        this.setMin = ensureprocessorrunninglocked.setMin;
        this.equals = ensureprocessorrunninglocked.equals;
        this.isInside = ensureprocessorrunninglocked.isInside;
        this.hashCode = ensureprocessorrunninglocked.hashCode;
        this.IsOverlapping = ensureprocessorrunninglocked.IsOverlapping;
        this.toString = ensureprocessorrunninglocked.toString;
        this.getMin = ensureprocessorrunninglocked.getMin;
        this.setMax = ensureprocessorrunninglocked.setMax;
        this.getMax = onscrollchanged == null ? ensureprocessorrunninglocked.getMax : onscrollchanged;
        this.toFloatRange = getactionlist == null ? ensureprocessorrunninglocked.toFloatRange : getactionlist;
        this.toDoubleRange = computeverticalscrollextent == null ? ensureprocessorrunninglocked.toDoubleRange : computeverticalscrollextent;
    }

    public ensureProcessorRunningLocked(ensureProcessorRunningLocked ensureprocessorrunninglocked) {
        this(ensureprocessorrunninglocked, ensureprocessorrunninglocked.getMax, ensureprocessorrunninglocked.toFloatRange, ensureprocessorrunninglocked.toDoubleRange);
    }

    public ensureProcessorRunningLocked(Context context) {
        this(context, (byte) 0);
    }

    public static ensureProcessorRunningLocked setMin(ensureProcessorRunningLocked ensureprocessorrunninglocked, ComponentTree componentTree) {
        ensureProcessorRunningLocked ensureprocessorrunninglocked2 = new ensureProcessorRunningLocked(ensureprocessorrunninglocked, NotificationCompatSideChannelService.toFloatRange(), (getActionList) null, (computeVerticalScrollExtent) null);
        ensureprocessorrunninglocked2.toString = componentTree;
        return ensureprocessorrunninglocked2;
    }

    /* access modifiers changed from: package-private */
    public final sendAccessibilityEvent length(isStopped isstopped) {
        sendAccessibilityEvent sendaccessibilityevent = isstopped.Mean$Arithmetic;
        isstopped.Mean$Arithmetic = null;
        if (sendaccessibilityevent != null) {
            return sendaccessibilityevent;
        }
        if (isstopped.IsOverlapping != null && isstopped.IsOverlapping.getAndSet(true)) {
            isstopped = isstopped.getMax();
        }
        isstopped.setMin(this);
        if (keyToDirection.getMax) {
            RemoteInput$EditChoicesBeforeSending.setMin(this, isstopped);
        }
        sendAccessibilityEvent max = isstopped.setMax(isstopped.FastBitmap$CoordinateSystem, false);
        if (max != length) {
            setMin(max, 0, 0);
        }
        return max;
    }

    public final sendAccessibilityEvent getMax(isStopped isstopped) {
        setInterruptIfStopped setinterruptifstopped;
        sendAccessibilityEvent sendaccessibilityevent = isstopped.Mean$Arithmetic;
        isstopped.Mean$Arithmetic = null;
        if (sendaccessibilityevent != null) {
            return sendaccessibilityevent;
        }
        if (isstopped.IsOverlapping != null && isstopped.IsOverlapping.getAndSet(true)) {
            isstopped = isstopped.getMax();
        }
        isstopped.setMin(this, true);
        if (keyToDirection.getMax) {
            RemoteInput$EditChoicesBeforeSending.setMin(this, isstopped);
        }
        sendAccessibilityEvent sendaccessibilityevent2 = (sendAccessibilityEvent) isstopped.setMax(isstopped.FastBitmap$CoordinateSystem);
        if (isstopped.length() && (setinterruptifstopped = isstopped.toDoubleRange) != null) {
            setinterruptifstopped.length(isstopped.FastBitmap$CoordinateSystem, sendaccessibilityevent2);
        }
        return sendaccessibilityevent2;
    }

    /* access modifiers changed from: package-private */
    public final void setMin(sendAccessibilityEvent sendaccessibilityevent, @AttrRes int i, @StyleRes int i2) {
        if (i != 0 || i2 != 0) {
            this.values = i;
            this.FastBitmap$CoordinateSystem = i2;
            TypedArray obtainStyledAttributes = this.setMin.obtainStyledAttributes((AttributeSet) null, dispatchNestedPreFling.setMin.getMax, i, i2);
            sendaccessibilityevent.getMin(obtainStyledAttributes);
            obtainStyledAttributes.recycle();
            this.values = 0;
            this.FastBitmap$CoordinateSystem = 0;
        }
    }

    @VisibleForTesting(otherwise = 3)
    public static ensureProcessorRunningLocked getMin(ensureProcessorRunningLocked ensureprocessorrunninglocked, isStopped isstopped) {
        ensureProcessorRunningLocked ensureprocessorrunninglocked2 = new ensureProcessorRunningLocked(ensureprocessorrunninglocked);
        ensureprocessorrunninglocked2.IsOverlapping = isstopped;
        ensureprocessorrunninglocked2.toString = ensureprocessorrunninglocked.toString;
        return ensureprocessorrunninglocked2;
    }

    public final boolean length() {
        ComponentTree componentTree = this.toString;
        if (componentTree != null) {
            return componentTree.IsOverlapping();
        }
        return false;
    }
}

package o;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.recyclerview.widget.RecyclerView;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.Executor;
import o.changeMenuMode;
import o.setExclusiveItemChecked;
import o.setShortcutsVisible;

public final class removeItemAt<T> {
    public setExclusiveItemChecked<T> IsOverlapping;
    int equals;
    final List<setMin<T>> getMax = new CopyOnWriteArrayList();
    boolean getMin;
    setExclusiveItemChecked.length isInside = new setExclusiveItemChecked.length() {
        public final void setMax(int i, int i2) {
            removeItemAt.this.setMin.setMax(i, i2);
        }

        public final void getMax(int i, int i2) {
            removeItemAt.this.setMin.length(i, i2);
        }

        public final void setMin(int i, int i2) {
            removeItemAt.this.setMin.getMax(i, i2, (Object) null);
        }
    };
    final setShortcutsVisible<T> length;
    Executor setMax = skipToQueueItem.setMin();
    final stopDispatchingItemsChanged setMin;
    public setExclusiveItemChecked<T> toFloatRange;

    public interface setMin<T> {
    }

    public removeItemAt(@NonNull RecyclerView.Adapter adapter, @NonNull changeMenuMode.setMin<T> setmin) {
        this.setMin = new isShortcutKey(adapter);
        this.length = new setShortcutsVisible.setMax(setmin).setMin();
    }

    /* access modifiers changed from: package-private */
    public final void getMax(@Nullable Runnable runnable) {
        Iterator<setMin<T>> it = this.getMax.iterator();
        while (it.hasNext()) {
            it.next();
        }
        if (runnable != null) {
            runnable.run();
        }
    }
}

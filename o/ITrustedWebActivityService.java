package o;

import android.content.Context;
import android.content.res.Configuration;
import android.location.Location;
import android.location.LocationManager;
import android.util.LongSparseArray;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import androidx.annotation.NonNull;
import androidx.annotation.RequiresApi;
import androidx.annotation.RequiresPermission;
import androidx.annotation.StringRes;
import androidx.annotation.VisibleForTesting;
import androidx.appcompat.app.ActionBar;
import androidx.appcompat.graphics.drawable.DrawerArrowDrawable;
import androidx.appcompat.widget.Toolbar;
import androidx.core.content.PermissionChecker;
import androidx.core.view.ViewCompat;
import androidx.drawerlayout.widget.DrawerLayout;
import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
import id.dana.utils.permission.ManifestPermission;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Calendar;
import o.MediaMetadataCompat;
import o.onEvent;
import o.onQueueTitleChanged;

public final class ITrustedWebActivityService implements DrawerLayout.getMin {
    private final int IsOverlapping;
    private final int getMax;
    private boolean getMin;
    private DrawerArrowDrawable length;
    private final setMin setMax;
    boolean setMin;

    public interface setMin {
        void getMin(@StringRes int i);
    }

    public final class Stub {
        public static Field getMax;
        private static Class<?> getMin;
        private static boolean isInside;
        public static boolean length;
        public static Field setMax;
        public static boolean setMin;
        private static boolean toFloatRange;
        private static Field toIntRange;

        public final class Proxy extends ActionBar {
            private final Toolbar.setMax IsOverlapping = new Toolbar.setMax() {
                public final boolean length(MenuItem menuItem) {
                    return Proxy.this.getMax.onMenuItemSelected(0, menuItem);
                }
            };
            public Window.Callback getMax;
            getMetadata getMin;
            private ArrayList<Object> isInside = new ArrayList<>();
            private boolean length;
            private boolean setMax;
            boolean setMin;
            private final Runnable toFloatRange = new Runnable() {
                public final void run() {
                    Proxy proxy = Proxy.this;
                    Menu doubleRange = proxy.toDoubleRange();
                    onEvent onevent = doubleRange instanceof onEvent ? (onEvent) doubleRange : null;
                    if (onevent != null) {
                        onevent.stopDispatchingItemsChanged();
                    }
                    try {
                        doubleRange.clear();
                        if (!proxy.getMax.onCreatePanelMenu(0, doubleRange) || !proxy.getMax.onPreparePanel(0, (View) null, doubleRange)) {
                            doubleRange.clear();
                        }
                    } finally {
                        if (onevent != null) {
                            onevent.startDispatchingItemsChanged();
                        }
                    }
                }
            };

            public final void getMax(boolean z) {
            }

            public final void getMin(boolean z) {
            }

            public Proxy(Toolbar toolbar, CharSequence charSequence, Window.Callback callback) {
                this.getMin = new prepareFromMediaId(toolbar, false);
                setMax setmax = new setMax(callback);
                this.getMax = setmax;
                this.getMin.setMax((Window.Callback) setmax);
                toolbar.setOnMenuItemClickListener(this.IsOverlapping);
                this.getMin.setMin(charSequence);
            }

            public final Context getMax() {
                return this.getMin.getMin();
            }

            public final void getMax(int i) {
                this.getMin.setMin(i);
            }

            public final void length(Configuration configuration) {
                super.length(configuration);
            }

            public final void getMin(CharSequence charSequence) {
                this.getMin.length(charSequence);
            }

            public final void setMin(CharSequence charSequence) {
                this.getMin.setMin(charSequence);
            }

            public final int getMin() {
                return this.getMin.valueOf();
            }

            public final int length() {
                return this.getMin.Grayscale$Algorithm();
            }

            public final boolean equals() {
                return this.getMin.FastBitmap$CoordinateSystem();
            }

            public final boolean toIntRange() {
                return this.getMin.toDoubleRange();
            }

            public final boolean IsOverlapping() {
                this.getMin.setMax().removeCallbacks(this.toFloatRange);
                ViewCompat.getMax((View) this.getMin.setMax(), this.toFloatRange);
                return true;
            }

            public final boolean isInside() {
                if (!this.getMin.length()) {
                    return false;
                }
                this.getMin.getMax();
                return true;
            }

            public final boolean getMin(KeyEvent keyEvent) {
                if (keyEvent.getAction() == 1) {
                    equals();
                }
                return true;
            }

            public final boolean setMin(int i, KeyEvent keyEvent) {
                Menu doubleRange = toDoubleRange();
                if (doubleRange == null) {
                    return false;
                }
                boolean z = true;
                if (KeyCharacterMap.load(keyEvent != null ? keyEvent.getDeviceId() : -1).getKeyboardType() == 1) {
                    z = false;
                }
                doubleRange.setQwertyMode(z);
                return doubleRange.performShortcut(i, keyEvent, 0);
            }

            public final void toFloatRange() {
                this.getMin.setMax().removeCallbacks(this.toFloatRange);
            }

            public final void length(boolean z) {
                if (z != this.length) {
                    this.length = z;
                    int size = this.isInside.size();
                    for (int i = 0; i < size; i++) {
                        this.isInside.get(i);
                    }
                }
            }

            class setMax extends MediaMetadataCompat.RatingKey {
                public setMax(Window.Callback callback) {
                    super(callback);
                }

                public final boolean onPreparePanel(int i, View view, Menu menu) {
                    boolean onPreparePanel = super.onPreparePanel(i, view, menu);
                    if (onPreparePanel && !Proxy.this.setMin) {
                        Proxy.this.getMin.values();
                        Proxy.this.setMin = true;
                    }
                    return onPreparePanel;
                }

                public final View onCreatePanelView(int i) {
                    if (i == 0) {
                        return new View(Proxy.this.getMin.getMin());
                    }
                    return super.onCreatePanelView(i);
                }
            }

            /* access modifiers changed from: package-private */
            public final Menu toDoubleRange() {
                if (!this.setMax) {
                    this.getMin.getMax(new getMin(), new setMin());
                    this.setMax = true;
                }
                return this.getMin.invokeSuspend();
            }

            final class getMin implements onQueueTitleChanged.setMax {
                private boolean length;

                getMin() {
                }

                public final boolean setMax(@NonNull onEvent onevent) {
                    if (Proxy.this.getMax == null) {
                        return false;
                    }
                    Proxy.this.getMax.onMenuOpened(108, onevent);
                    return true;
                }

                public final void getMax(@NonNull onEvent onevent, boolean z) {
                    if (!this.length) {
                        this.length = true;
                        Proxy.this.getMin.invoke();
                        if (Proxy.this.getMax != null) {
                            Proxy.this.getMax.onPanelClosed(108, onevent);
                        }
                        this.length = false;
                    }
                }
            }

            final class setMin implements onEvent.length {
                public final boolean onMenuItemSelected(@NonNull onEvent onevent, @NonNull MenuItem menuItem) {
                    return false;
                }

                setMin() {
                }

                public final void onMenuModeChange(@NonNull onEvent onevent) {
                    if (Proxy.this.getMax == null) {
                        return;
                    }
                    if (Proxy.this.getMin.toIntRange()) {
                        Proxy.this.getMax.onPanelClosed(108, onevent);
                    } else if (Proxy.this.getMax.onPreparePanel(0, (View) null, onevent)) {
                        Proxy.this.getMax.onMenuOpened(108, onevent);
                    }
                }
            }

            public final void setMax() {
                this.getMin.getMin((this.getMin.valueOf() & -9) | 0);
            }
        }

        @RequiresApi(16)
        public static void length(@NonNull Object obj) {
            if (!isInside) {
                try {
                    getMin = Class.forName("android.content.res.ThemedResourceCache");
                } catch (ClassNotFoundException unused) {
                }
                isInside = true;
            }
            Class<?> cls = getMin;
            if (cls != null) {
                if (!toFloatRange) {
                    try {
                        Field declaredField = cls.getDeclaredField("mUnthemedEntries");
                        toIntRange = declaredField;
                        declaredField.setAccessible(true);
                    } catch (NoSuchFieldException unused2) {
                    }
                    toFloatRange = true;
                }
                Field field = toIntRange;
                if (field != null) {
                    LongSparseArray longSparseArray = null;
                    try {
                        longSparseArray = (LongSparseArray) field.get(obj);
                    } catch (IllegalAccessException unused3) {
                    }
                    if (longSparseArray != null) {
                        longSparseArray.clear();
                    }
                }
            }
        }
    }

    public final class Default {
        public static Default setMin;
        private final LocationManager getMin;
        private final Context length;
        private final getMax setMax = new getMax();

        @VisibleForTesting
        public Default(@NonNull Context context, @NonNull LocationManager locationManager) {
            this.length = context;
            this.getMin = locationManager;
        }

        public final boolean setMin() {
            long j;
            getMax getmax = this.setMax;
            if (getMax()) {
                return getmax.setMax;
            }
            Location location = null;
            Location max = PermissionChecker.setMin(this.length, ManifestPermission.ACCESS_COARSE_LOCATION) == 0 ? setMax("network") : null;
            if (PermissionChecker.setMin(this.length, "android.permission.ACCESS_FINE_LOCATION") == 0) {
                location = setMax("gps");
            }
            if (location == null || max == null ? location != null : location.getTime() > max.getTime()) {
                max = location;
            }
            boolean z = false;
            if (max != null) {
                getMax getmax2 = this.setMax;
                long currentTimeMillis = System.currentTimeMillis();
                if (notify.getMax == null) {
                    notify.getMax = new notify();
                }
                notify notify = notify.getMax;
                notify.getMax(currentTimeMillis - 86400000, max.getLatitude(), max.getLongitude());
                long j2 = notify.setMax;
                notify notify2 = notify;
                notify.getMax(currentTimeMillis, max.getLatitude(), max.getLongitude());
                if (notify2.setMin == 1) {
                    z = true;
                }
                long j3 = notify2.length;
                long j4 = notify2.setMax;
                notify2.getMax(currentTimeMillis + 86400000, max.getLatitude(), max.getLongitude());
                long j5 = notify2.length;
                if (j3 == -1 || j4 == -1) {
                    j = 43200000 + currentTimeMillis;
                } else {
                    j = (currentTimeMillis > j4 ? 0 + j5 : currentTimeMillis > j3 ? 0 + j4 : 0 + j3) + DefaultLoadErrorHandlingPolicy.DEFAULT_TRACK_BLACKLIST_MS;
                }
                getmax2.setMax = z;
                getmax2.setMin = j2;
                getmax2.getMax = j3;
                getmax2.getMin = j4;
                getmax2.length = j5;
                getmax2.toFloatRange = j;
                return getmax.setMax;
            }
            int i = Calendar.getInstance().get(11);
            return i < 6 || i >= 22;
        }

        @RequiresPermission(anyOf = {"android.permission.ACCESS_COARSE_LOCATION", "android.permission.ACCESS_FINE_LOCATION"})
        private Location setMax(String str) {
            try {
                if (this.getMin.isProviderEnabled(str)) {
                    return this.getMin.getLastKnownLocation(str);
                }
                return null;
            } catch (Exception unused) {
                return null;
            }
        }

        private boolean getMax() {
            return this.setMax.toFloatRange > System.currentTimeMillis();
        }

        static class getMax {
            long getMax;
            long getMin;
            long length;
            boolean setMax;
            long setMin;
            long toFloatRange;

            getMax() {
            }
        }
    }

    public final void getMin(float f) {
        if (this.getMin) {
            getMax(Math.min(1.0f, Math.max(0.0f, f)));
        } else {
            getMax(0.0f);
        }
    }

    public final void getMin() {
        getMax(1.0f);
        if (this.setMin) {
            this.setMax.getMin(this.IsOverlapping);
        }
    }

    public final void getMax() {
        getMax(0.0f);
        if (this.setMin) {
            this.setMax.getMin(this.getMax);
        }
    }

    private void getMax(float f) {
        if (f == 1.0f) {
            DrawerArrowDrawable drawerArrowDrawable = this.length;
            if (!drawerArrowDrawable.setMin) {
                drawerArrowDrawable.setMin = true;
                drawerArrowDrawable.invalidateSelf();
            }
        } else if (f == 0.0f) {
            DrawerArrowDrawable drawerArrowDrawable2 = this.length;
            if (drawerArrowDrawable2.setMin) {
                drawerArrowDrawable2.setMin = false;
                drawerArrowDrawable2.invalidateSelf();
            }
        }
        DrawerArrowDrawable drawerArrowDrawable3 = this.length;
        if (drawerArrowDrawable3.getMax != f) {
            drawerArrowDrawable3.getMax = f;
            drawerArrowDrawable3.invalidateSelf();
        }
    }
}

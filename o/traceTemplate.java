package o;

import com.alibaba.ariver.kernel.api.extension.bridge.BridgeDSL;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import o.CircleFrameLayout;
import o.PromptTextView;
import o.SecureQwertyKeyboard;
import org.mozilla.javascript.Token;
import org.mozilla.javascript.ast.FunctionNode;

public class traceTemplate {
    private getPublicKeyFromX509 FastBitmap$CoordinateSystem;
    private boolean Grayscale$Algorithm;
    private boolean ICustomTabsCallback;
    List<setWidgetListener> IsOverlapping;
    private int Mean$Arithmetic;
    private getFaceRegion b;
    private List<getFaceRegion> create;
    List<AlgorithmInfoPattern> equals;
    private String extraCallback;
    private setDeepLiveness getCause;
    boolean getMax;
    protected int getMin;
    private String hashCode;
    private switchOn invoke;
    private int invokeSuspend;
    int isInside;
    SecureQwertyKeyboard.AnonymousClass2 length;
    private int onMessageChannelReady;
    /* access modifiers changed from: private */
    public boolean onNavigationEvent;
    private int onRelationshipValidationResult;
    protected boolean setMax;
    getCricleColor setMin;
    private char[] toDoubleRange;
    Map<String, setDeepLiveness> toFloatRange;
    setRoundColor toIntRange;
    private getDeepLiveness toString;
    private int valueOf;
    boolean values;

    private static final boolean length(int i, int i2, int i3) {
        return (i & i3) != i3 && (i2 & i3) == i3;
    }

    static class length extends RuntimeException {
        static final long serialVersionUID = 5882582646773765630L;

        private length() {
        }
    }

    public traceTemplate() {
        this(new Object() {
            private boolean FastBitmap$CoordinateSystem;
            private boolean Grayscale$Algorithm;
            private boolean IsOverlapping;
            private boolean equals;
            private boolean getMax;
            public int getMin;
            private boolean hashCode;
            private boolean invokeSuspend;
            private boolean isInside;
            Set<String> length;
            getPublicKeyFromX509 setMax;
            public int setMin;
            private boolean toDoubleRange;
            private boolean toFloatRange;
            private boolean toIntRange;
            private boolean toString;
            private boolean valueOf;
            private boolean values;

            public final boolean setMax(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.setMax():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.setMax():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean getMax(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.getMax():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.getMax():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean setMin(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.setMin():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.setMin():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean getMin(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.getMin():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.getMin():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean length(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.length():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.length():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean equals(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.equals():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.equals():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean IsOverlapping(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.IsOverlapping():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.IsOverlapping():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean toIntRange(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.toIntRange():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.toIntRange():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean toFloatRange(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.toFloatRange():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.toFloatRange():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean isInside(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.isInside():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.isInside():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean FastBitmap$CoordinateSystem(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.FastBitmap$CoordinateSystem():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.FastBitmap$CoordinateSystem():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean toDoubleRange(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.toDoubleRange():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.toDoubleRange():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final boolean values(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.values():boolean, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.values():boolean, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/

            public final void getMin(
/*
Method generation error in method: o.SecureQwertyKeyboard.2.getMin(o.SecureQwertyKeyboard$1):void, dex: classes6.dex
            jadx.core.utils.exceptions.JadxRuntimeException: Method args not loaded: o.SecureQwertyKeyboard.2.getMin(o.SecureQwertyKeyboard$1):void, class status: UNLOADED
            	at jadx.core.dex.nodes.MethodNode.getArgRegs(MethodNode.java:278)
            	at jadx.core.codegen.MethodGen.addDefinition(MethodGen.java:116)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:313)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.InsnGen.inlineAnonymousConstructor(InsnGen.java:676)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:607)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:231)
            	at jadx.core.codegen.InsnGen.addWrappedArg(InsnGen.java:123)
            	at jadx.core.codegen.InsnGen.addArg(InsnGen.java:107)
            	at jadx.core.codegen.InsnGen.generateMethodArguments(InsnGen.java:787)
            	at jadx.core.codegen.InsnGen.makeConstructor(InsnGen.java:640)
            	at jadx.core.codegen.InsnGen.makeInsnBody(InsnGen.java:364)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:250)
            	at jadx.core.codegen.InsnGen.makeInsn(InsnGen.java:221)
            	at jadx.core.codegen.RegionGen.makeSimpleBlock(RegionGen.java:109)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:55)
            	at jadx.core.codegen.RegionGen.makeSimpleRegion(RegionGen.java:92)
            	at jadx.core.codegen.RegionGen.makeRegion(RegionGen.java:58)
            	at jadx.core.codegen.MethodGen.addRegionInsns(MethodGen.java:211)
            	at jadx.core.codegen.MethodGen.addInstructions(MethodGen.java:204)
            	at jadx.core.codegen.ClassGen.addMethodCode(ClassGen.java:318)
            	at jadx.core.codegen.ClassGen.addMethod(ClassGen.java:271)
            	at jadx.core.codegen.ClassGen.lambda$addInnerClsAndMethods$2(ClassGen.java:240)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
            	at java.util.ArrayList.forEach(ArrayList.java:1259)
            	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395)
            	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)
            	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483)
            	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
            	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
            	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
            	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
            	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)
            	at jadx.core.codegen.ClassGen.addInnerClsAndMethods(ClassGen.java:236)
            	at jadx.core.codegen.ClassGen.addClassBody(ClassGen.java:227)
            	at jadx.core.codegen.ClassGen.addClassCode(ClassGen.java:112)
            	at jadx.core.codegen.ClassGen.makeClass(ClassGen.java:78)
            	at jadx.core.codegen.CodeGen.wrapCodeGen(CodeGen.java:44)
            	at jadx.core.codegen.CodeGen.generateJavaCode(CodeGen.java:33)
            	at jadx.core.codegen.CodeGen.generate(CodeGen.java:21)
            	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
            	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:273)
            
*/
        });
    }

    public traceTemplate(SecureQwertyKeyboard.AnonymousClass2 r2, getPublicKeyFromX509 getpublickeyfromx509) {
        this.invokeSuspend = 0;
        this.extraCallback = "";
        this.length = r2;
        this.FastBitmap$CoordinateSystem = getpublickeyfromx509;
        if (getpublickeyfromx509 instanceof getDeepLiveness) {
            this.toString = (getDeepLiveness) getpublickeyfromx509;
        }
    }

    private void length(String str, String str2) {
        setMax(str, str2);
    }

    /* access modifiers changed from: package-private */
    public final void setMax(String str, String str2) {
        String str3;
        int i;
        String str4;
        int i2;
        this.Mean$Arithmetic++;
        if (str2 == null) {
            str3 = LogItem.getMax(str);
        } else {
            str3 = LogItem.getMin(str, (Object) str2);
        }
        String str5 = str3;
        if (this.toString == null) {
            switchOn switchon = this.invoke;
            if (switchon != null) {
                int i3 = switchon.isInside;
                String intRange = this.invoke.toIntRange();
                switchOn switchon2 = this.invoke;
                int i4 = switchon2.equals - switchon2.getMax;
                if (switchon2.getMin >= 0) {
                    i4--;
                }
                str4 = intRange;
                i = i4;
                i2 = i3;
            } else {
                str4 = "";
                i2 = 1;
                i = 1;
            }
            this.FastBitmap$CoordinateSystem.length(str5, this.hashCode, i2, str4, i);
        }
    }

    private void setMin(String str, String str2, int i, String str3, int i2) {
        if (this.length.IsOverlapping()) {
            LogItem.getMin(str, (Object) str2);
            if (this.length.toIntRange()) {
                this.Mean$Arithmetic++;
                String min = LogItem.getMin(str, (Object) str2);
                if (this.toString == null) {
                    this.FastBitmap$CoordinateSystem.length(min, this.hashCode, i, str3, i2);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public final void length(String str) {
        getMax(str, (String) null);
    }

    /* access modifiers changed from: package-private */
    public final void getMax(String str, String str2) {
        if (this.invoke == null) {
            setMax(str, str2);
            if (!this.length.toDoubleRange()) {
                throw new length();
            }
            return;
        }
        setMax(str, str2);
        if (!this.length.toDoubleRange()) {
            throw new length();
        }
    }

    private static int toIntRange(String str) {
        int i = 0;
        for (int length2 = str.length() - 1; length2 >= 0; length2--) {
            if (str.charAt(length2) == 10) {
                i++;
            }
        }
        return i;
    }

    private int getMin() throws IOException {
        String str;
        if (this.invokeSuspend != 0) {
            return this.valueOf;
        }
        int i = this.invoke.isInside;
        int IsOverlapping2 = this.invoke.IsOverlapping();
        int i2 = 0;
        boolean z = false;
        while (true) {
            if (IsOverlapping2 != 1 && IsOverlapping2 != 162) {
                break;
            }
            if (IsOverlapping2 == 1) {
                i++;
                z = true;
            } else if (this.length.isInside()) {
                switchOn switchon = this.invoke;
                if (switchon.toIntRange != null) {
                    if (switchon.toDoubleRange()) {
                        getStyleId.setMin();
                    }
                    str = switchon.toIntRange.substring(switchon.values, switchon.toString);
                } else {
                    if (!switchon.toDoubleRange()) {
                        getStyleId.setMin();
                    }
                    StringBuilder sb = new StringBuilder(switchon.hashCode);
                    sb.append(switchon.IsOverlapping, switchon.FastBitmap$CoordinateSystem, (switchon.toString - switchon.values) - switchon.hashCode.length());
                    switchon.FastBitmap$CoordinateSystem = -1;
                    str = sb.toString();
                }
                if (this.create == null) {
                    this.create = new ArrayList();
                }
                int i3 = this.invoke.values;
                switchOn switchon2 = this.invoke;
                getFaceRegion getfaceregion = new getFaceRegion(i3, switchon2.toString - switchon2.values, this.invoke.toDoubleRange, str);
                if (this.invoke.toDoubleRange == Token.CommentType.JSDOC && this.length.FastBitmap$CoordinateSystem()) {
                    this.b = getfaceregion;
                }
                getfaceregion.setMin(i);
                this.create.add(getfaceregion);
                i += toIntRange(str);
            }
            IsOverlapping2 = this.invoke.IsOverlapping();
        }
        this.valueOf = IsOverlapping2;
        if (z) {
            i2 = 65536;
        }
        this.invokeSuspend = IsOverlapping2 | i2;
        return this.valueOf;
    }

    private int setMax() throws IOException {
        int min = getMin();
        this.invokeSuspend = 0;
        return min;
    }

    private boolean setMin(int i) throws IOException {
        if (getMin() != i) {
            return false;
        }
        this.invokeSuspend = 0;
        return true;
    }

    private boolean length(int i, String str) throws IOException {
        int max = dispatchOnCancelled.setMax(i);
        if (i != max) {
            onCanceled oncanceled = new onCanceled(i, max, 1);
            onCancelLoad.setMax(634013639, oncanceled);
            onCancelLoad.getMin(634013639, oncanceled);
        }
        return getMax(i, str);
    }

    private boolean getMax(int i, String str) throws IOException {
        if (setMin(i)) {
            return true;
        }
        setMax(str, (String) null);
        if (this.length.toDoubleRange()) {
            return false;
        }
        throw new length();
    }

    private boolean length() {
        return this.getMin != 0;
    }

    /* access modifiers changed from: package-private */
    public final void setMin(setRoundColor setroundcolor) {
        setRoundColor asInterface = setroundcolor.asInterface();
        if (asInterface == null) {
            this.toIntRange.length(setroundcolor);
        } else if (asInterface != this.toIntRange) {
            ITrustedWebActivityCallback();
        }
        this.toIntRange = setroundcolor;
    }

    private void setMin(setWidgetListener setwidgetlistener) {
        if (this.IsOverlapping == null) {
            this.IsOverlapping = new ArrayList();
        }
        this.IsOverlapping.add(setwidgetlistener);
        if (this.equals == null) {
            this.equals = new ArrayList();
        }
        this.equals.add(setwidgetlistener);
        setMin((setRoundColor) setwidgetlistener);
        setDeepLiveness setdeepliveness = this.getCause;
        if (setdeepliveness != null) {
            setdeepliveness.equals = setwidgetlistener;
            setwidgetlistener.getMax(setdeepliveness);
            this.getCause.isInside.get(0).length(setwidgetlistener);
            setwidgetlistener.toFloatRange(-this.getCause.Mean$Arithmetic());
        }
    }

    private void toIntRange() {
        List<setWidgetListener> list = this.IsOverlapping;
        setWidgetListener remove = list.remove(list.size() - 1);
        List<AlgorithmInfoPattern> list2 = this.equals;
        list2.remove(list2.size() - 1);
        if (remove.onNavigationEvent() != null) {
            remove.toFloatRange(remove.onNavigationEvent().Mean$Arithmetic());
        }
        this.toIntRange = this.toIntRange.asInterface();
    }

    /* JADX WARNING: Can't wrap try/catch for region: R(3:11|12|13) */
    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0023, code lost:
        r2 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:13:0x002a, code lost:
        throw new java.lang.IllegalStateException();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:14:0x002b, code lost:
        r1.Grayscale$Algorithm = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:15:0x002d, code lost:
        throw r2;
     */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Missing exception handler attribute for start block: B:11:0x0025 */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public final o.setHasFace getMin(java.lang.String r2, java.lang.String r3) {
        /*
            r1 = this;
            boolean r0 = r1.Grayscale$Algorithm
            if (r0 != 0) goto L_0x002e
            r1.hashCode = r3
            o.SecureQwertyKeyboard$2 r3 = r1.length
            boolean r3 = r3.values()
            if (r3 == 0) goto L_0x0014
            char[] r3 = r2.toCharArray()
            r1.toDoubleRange = r3
        L_0x0014:
            o.switchOn r3 = new o.switchOn
            r0 = 1
            r3.<init>(r1, r2, r0)
            r1.invoke = r3
            o.setHasFace r2 = r1.IsOverlapping()     // Catch:{ IOException -> 0x0025 }
            r1.Grayscale$Algorithm = r0
            return r2
        L_0x0023:
            r2 = move-exception
            goto L_0x002b
        L_0x0025:
            java.lang.IllegalStateException r2 = new java.lang.IllegalStateException     // Catch:{ all -> 0x0023 }
            r2.<init>()     // Catch:{ all -> 0x0023 }
            throw r2     // Catch:{ all -> 0x0023 }
        L_0x002b:
            r1.Grayscale$Algorithm = r0
            throw r2
        L_0x002e:
            java.lang.IllegalStateException r2 = new java.lang.IllegalStateException
            java.lang.String r3 = "parser reused"
            r2.<init>(r3)
            throw r2
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.getMin(java.lang.String, java.lang.String):o.setHasFace");
    }

    public final setHasFace getMax(String str) throws IOException {
        if (this.Grayscale$Algorithm) {
            throw new IllegalStateException("parser reused");
        } else if (this.length.values()) {
            return getMin(ICustomTabsService$Stub(), str);
        } else {
            try {
                this.hashCode = str;
                this.invoke = new switchOn(this, (String) null, 1);
                return IsOverlapping();
            } finally {
                this.Grayscale$Algorithm = true;
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:26:0x004e A[Catch:{ StackOverflowError -> 0x0072, all -> 0x006f }] */
    /* JADX WARNING: Removed duplicated region for block: B:27:0x0050 A[Catch:{ StackOverflowError -> 0x0072, all -> 0x006f }] */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.setHasFace IsOverlapping() throws java.io.IOException {
        /*
            r10 = this;
            o.setHasFace r0 = new o.setHasFace
            r1 = 0
            r0.<init>(r1)
            r10.setMin = r0
            r10.toIntRange = r0
            o.switchOn r2 = r10.invoke
            int r6 = r2.isInside
            boolean r2 = r10.setMax
            boolean r3 = r10.values
            r10.setMax = r3
            r4 = 1
            if (r3 == 0) goto L_0x0019
            r0.getDefaultImpl = r4
        L_0x0019:
            r3 = 1
            r5 = 0
        L_0x001b:
            int r7 = r10.getMin()     // Catch:{ StackOverflowError -> 0x0072 }
            if (r7 <= 0) goto L_0x006c
            r8 = 110(0x6e, float:1.54E-43)
            if (r7 != r8) goto L_0x0033
            r10.invokeSuspend = r1     // Catch:{ StackOverflowError -> 0x0072 }
            boolean r7 = r10.getMax     // Catch:{ length -> 0x006c }
            if (r7 == 0) goto L_0x002d
            r7 = 2
            goto L_0x002e
        L_0x002d:
            r7 = 1
        L_0x002e:
            org.mozilla.javascript.ast.FunctionNode r7 = r10.setMax((int) r7)     // Catch:{ length -> 0x006c }
            goto L_0x005c
        L_0x0033:
            o.isHasFace r7 = r10.isInside()     // Catch:{ StackOverflowError -> 0x0072 }
            if (r3 == 0) goto L_0x005c
            boolean r8 = r7 instanceof o.setIntegrity     // Catch:{ StackOverflowError -> 0x0072 }
            if (r8 == 0) goto L_0x004b
            r8 = r7
            o.setIntegrity r8 = (o.setIntegrity) r8     // Catch:{ StackOverflowError -> 0x0072 }
            o.isHasFace r8 = r8.toIntRange     // Catch:{ StackOverflowError -> 0x0072 }
            boolean r9 = r8 instanceof o.paintStroke     // Catch:{ StackOverflowError -> 0x0072 }
            if (r9 == 0) goto L_0x004b
            o.paintStroke r8 = (o.paintStroke) r8     // Catch:{ StackOverflowError -> 0x0072 }
            java.lang.String r8 = r8.toFloatRange     // Catch:{ StackOverflowError -> 0x0072 }
            goto L_0x004c
        L_0x004b:
            r8 = 0
        L_0x004c:
            if (r8 != 0) goto L_0x0050
            r3 = 0
            goto L_0x005c
        L_0x0050:
            java.lang.String r9 = "use strict"
            boolean r8 = r8.equals(r9)     // Catch:{ StackOverflowError -> 0x0072 }
            if (r8 == 0) goto L_0x005c
            r10.setMax = r4     // Catch:{ StackOverflowError -> 0x0072 }
            r0.getDefaultImpl = r4     // Catch:{ StackOverflowError -> 0x0072 }
        L_0x005c:
            int r8 = r7.Mean$Arithmetic()     // Catch:{ StackOverflowError -> 0x0072 }
            int r5 = r7.create()     // Catch:{ StackOverflowError -> 0x0072 }
            int r5 = r5 + r8
            r0.getMax((o.LogFactory) r7)     // Catch:{ StackOverflowError -> 0x0072 }
            r7.getMax(r0)     // Catch:{ StackOverflowError -> 0x0072 }
            goto L_0x001b
        L_0x006c:
            r10.setMax = r2
            goto L_0x0081
        L_0x006f:
            r0 = move-exception
            goto L_0x0124
        L_0x0072:
            java.lang.String r3 = "msg.too.deep.parser.recursion"
            java.lang.String r3 = o.LogItem.getMax((java.lang.String) r3)     // Catch:{ all -> 0x006f }
            o.SecureQwertyKeyboard$2 r7 = r10.length     // Catch:{ all -> 0x006f }
            boolean r7 = r7.values()     // Catch:{ all -> 0x006f }
            if (r7 == 0) goto L_0x0119
            goto L_0x006c
        L_0x0081:
            int r2 = r10.Mean$Arithmetic
            if (r2 == 0) goto L_0x00ab
            java.lang.String r2 = java.lang.String.valueOf(r2)
            java.lang.String r3 = "msg.got.syntax.errors"
            if (r2 != 0) goto L_0x0092
            java.lang.String r2 = o.LogItem.getMax((java.lang.String) r3)
            goto L_0x0096
        L_0x0092:
            java.lang.String r2 = o.LogItem.getMin((java.lang.String) r3, (java.lang.Object) r2)
        L_0x0096:
            o.SecureQwertyKeyboard$2 r3 = r10.length
            boolean r3 = r3.values()
            if (r3 == 0) goto L_0x009f
            goto L_0x00ab
        L_0x009f:
            o.getPublicKeyFromX509 r3 = r10.FastBitmap$CoordinateSystem
            java.lang.String r5 = r10.hashCode
            r7 = 0
            r8 = 0
            r4 = r2
            org.mozilla.javascript.EvaluatorException r0 = r3.getMax(r4, r5, r6, r7, r8)
            throw r0
        L_0x00ab:
            java.util.List<o.getFaceRegion> r2 = r10.create
            if (r2 == 0) goto L_0x00fe
            int r2 = r2.size()
            int r2 = r2 - r4
            java.util.List<o.getFaceRegion> r3 = r10.create
            java.lang.Object r2 = r3.get(r2)
            o.isHasFace r2 = (o.isHasFace) r2
            int r3 = r2.Mean$Arithmetic()
            int r2 = r2.create()
            int r3 = r3 + r2
            int r5 = java.lang.Math.max(r5, r3)
            java.util.List<o.getFaceRegion> r2 = r10.create
            java.util.Iterator r2 = r2.iterator()
        L_0x00cf:
            boolean r3 = r2.hasNext()
            if (r3 == 0) goto L_0x00fe
            java.lang.Object r3 = r2.next()
            o.getFaceRegion r3 = (o.getFaceRegion) r3
            if (r3 == 0) goto L_0x00f6
            java.util.SortedSet<o.getFaceRegion> r4 = r0.toIntRange
            if (r4 != 0) goto L_0x00ed
            java.util.TreeSet r4 = new java.util.TreeSet
            o.isHasFace$length r7 = new o.isHasFace$length
            r7.<init>()
            r4.<init>(r7)
            r0.toIntRange = r4
        L_0x00ed:
            java.util.SortedSet<o.getFaceRegion> r4 = r0.toIntRange
            r4.add(r3)
            r3.getMax(r0)
            goto L_0x00cf
        L_0x00f6:
            java.lang.IllegalArgumentException r0 = new java.lang.IllegalArgumentException
            java.lang.String r1 = "arg cannot be null"
            r0.<init>(r1)
            throw r0
        L_0x00fe:
            int r5 = r5 - r1
            r0.equals(r5)
            java.lang.String r1 = r10.hashCode
            r0.extraCallbackWithResult = r1
            r0.hashCode(r6)
            o.switchOn r1 = r10.invoke
            int r1 = r1.isInside
            if (r1 < 0) goto L_0x0113
            int r2 = r0.ICustomTabsCallback$Stub
            if (r2 < 0) goto L_0x0116
        L_0x0113:
            o.getCricleColor.ICustomTabsCallback()
        L_0x0116:
            r0.ICustomTabsCallback$Stub = r1
            return r0
        L_0x0119:
            java.lang.String r0 = r10.hashCode     // Catch:{ all -> 0x006f }
            o.switchOn r1 = r10.invoke     // Catch:{ all -> 0x006f }
            int r1 = r1.isInside     // Catch:{ all -> 0x006f }
            org.mozilla.javascript.EvaluatorException r0 = o.SecureQwertyKeyboard.AnonymousClass1.getMin((java.lang.String) r3, (java.lang.String) r0, (int) r1)     // Catch:{ all -> 0x006f }
            throw r0     // Catch:{ all -> 0x006f }
        L_0x0124:
            r10.setMax = r2
            goto L_0x0128
        L_0x0127:
            throw r0
        L_0x0128:
            goto L_0x0127
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.IsOverlapping():o.setHasFace");
    }

    /* JADX WARNING: Removed duplicated region for block: B:10:0x0023  */
    /* JADX WARNING: Removed duplicated region for block: B:13:0x003f A[SYNTHETIC, Splitter:B:13:0x003f] */
    /* JADX WARNING: Removed duplicated region for block: B:18:0x0069 A[Catch:{ length -> 0x00c4, all -> 0x00bb }] */
    /* JADX WARNING: Removed duplicated region for block: B:34:0x0094 A[Catch:{ length -> 0x00c4, all -> 0x00bb }] */
    /* JADX WARNING: Removed duplicated region for block: B:35:0x0096 A[Catch:{ length -> 0x00c4, all -> 0x00bb }] */
    /* JADX WARNING: Removed duplicated region for block: B:9:0x0021  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.isHasFace length(int r12, org.mozilla.javascript.ast.FunctionNode r13) throws java.io.IOException {
        /*
            r11 = this;
            r0 = 86
            boolean r0 = r11.setMin((int) r0)
            r1 = 4
            r2 = 0
            r3 = 0
            r4 = 1
            if (r0 != 0) goto L_0x001e
            o.SecureQwertyKeyboard$2 r0 = r11.length
            int r0 = r0.setMin
            r5 = 180(0xb4, float:2.52E-43)
            if (r0 >= r5) goto L_0x001c
            if (r12 == r1) goto L_0x001c
            java.lang.String r0 = "msg.no.brace.body"
            r11.getMax((java.lang.String) r0, (java.lang.String) r2)
            goto L_0x001e
        L_0x001c:
            r0 = 1
            goto L_0x001f
        L_0x001e:
            r0 = 0
        L_0x001f:
            if (r12 != r1) goto L_0x0023
            r12 = 1
            goto L_0x0024
        L_0x0023:
            r12 = 0
        L_0x0024:
            int r1 = r11.getMin
            int r1 = r1 + r4
            r11.getMin = r1
            o.switchOn r1 = r11.invoke
            int r1 = r1.values
            o.AlgorithmInfo r5 = new o.AlgorithmInfo
            r5.<init>(r1)
            boolean r6 = r11.setMax
            o.switchOn r7 = r11.invoke
            int r7 = r7.isInside
            r5.setMin((int) r7)
            r7 = 87
            if (r0 == 0) goto L_0x0069
            o.isHasFace r13 = r11.onMessageChannelReady()     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            o.setTextSpan r3 = new o.setTextSpan     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            int r8 = r13.Mean$Arithmetic()     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            int r9 = r13.create()     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            r3.<init>(r8, r9, r13)     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            java.lang.Boolean r13 = java.lang.Boolean.TRUE     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            r8 = 25
            r3.setMax((int) r8, (java.lang.Object) r13)     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            java.lang.Boolean r13 = java.lang.Boolean.TRUE     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            r5.setMax((int) r8, (java.lang.Object) r13)     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            if (r12 == 0) goto L_0x0065
            r12 = 27
            java.lang.Boolean r13 = java.lang.Boolean.TRUE     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            r3.setMax((int) r12, (java.lang.Object) r13)     // Catch:{ length -> 0x00c4, all -> 0x00bb }
        L_0x0065:
            r5.length(r3)     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            goto L_0x00c4
        L_0x0069:
            r12 = 1
        L_0x006a:
            int r8 = r11.getMin()     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            r9 = -1
            if (r8 == r9) goto L_0x00c4
            if (r8 == 0) goto L_0x00c4
            if (r8 == r7) goto L_0x00c4
            r9 = 110(0x6e, float:1.54E-43)
            if (r8 == r9) goto L_0x00b1
            o.isHasFace r8 = r11.isInside()     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            if (r12 == 0) goto L_0x00b7
            boolean r9 = r8 instanceof o.setIntegrity     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            if (r9 == 0) goto L_0x0091
            r9 = r8
            o.setIntegrity r9 = (o.setIntegrity) r9     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            o.isHasFace r9 = r9.toIntRange     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            boolean r10 = r9 instanceof o.paintStroke     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            if (r10 == 0) goto L_0x0091
            o.paintStroke r9 = (o.paintStroke) r9     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            java.lang.String r9 = r9.toFloatRange     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            goto L_0x0092
        L_0x0091:
            r9 = r2
        L_0x0092:
            if (r9 != 0) goto L_0x0096
            r12 = 0
            goto L_0x00b7
        L_0x0096:
            java.lang.String r10 = "use strict"
            boolean r9 = r9.equals(r10)     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            if (r9 == 0) goto L_0x00b7
            r11.setMax = r4     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            r13.getDefaultImpl = r4     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            if (r6 != 0) goto L_0x00b7
            boolean r9 = r11.length()     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            if (r9 == 0) goto L_0x00b7
            o.getCricleColor r9 = r11.setMin     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            org.mozilla.javascript.ast.FunctionNode r9 = (org.mozilla.javascript.ast.FunctionNode) r9     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            r9.Mean$Arithmetic = r4     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            goto L_0x00b7
        L_0x00b1:
            r11.invokeSuspend = r3     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            org.mozilla.javascript.ast.FunctionNode r8 = r11.setMax((int) r4)     // Catch:{ length -> 0x00c4, all -> 0x00bb }
        L_0x00b7:
            r5.length(r8)     // Catch:{ length -> 0x00c4, all -> 0x00bb }
            goto L_0x006a
        L_0x00bb:
            r12 = move-exception
            int r13 = r11.getMin
            int r13 = r13 - r4
            r11.getMin = r13
            r11.setMax = r6
            throw r12
        L_0x00c4:
            int r12 = r11.getMin
            int r12 = r12 - r4
            r11.getMin = r12
            r11.setMax = r6
            o.switchOn r12 = r11.invoke
            int r12 = r12.toString
            r11.b = r2
            if (r0 != 0) goto L_0x00df
            java.lang.String r13 = "msg.no.brace.after.body"
            boolean r13 = r11.length((int) r7, (java.lang.String) r13)
            if (r13 == 0) goto L_0x00df
            o.switchOn r12 = r11.invoke
            int r12 = r12.toString
        L_0x00df:
            int r12 = r12 - r1
            r5.equals(r12)
            return r5
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.length(int, org.mozilla.javascript.ast.FunctionNode):o.isHasFace");
    }

    /* JADX WARNING: Removed duplicated region for block: B:101:0x0207 A[Catch:{ all -> 0x0254 }] */
    /* JADX WARNING: Removed duplicated region for block: B:102:0x020a A[Catch:{ all -> 0x0254 }] */
    /* JADX WARNING: Removed duplicated region for block: B:105:0x0214 A[Catch:{ all -> 0x0254 }] */
    /* JADX WARNING: Removed duplicated region for block: B:120:0x024a A[LOOP:0: B:50:0x00d2->B:120:0x024a, LOOP_END] */
    /* JADX WARNING: Removed duplicated region for block: B:124:0x0174 A[EDGE_INSN: B:124:0x0174->B:79:0x0174 ?: BREAK  , SYNTHETIC] */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private org.mozilla.javascript.ast.FunctionNode setMax(int r20) throws java.io.IOException {
        /*
            r19 = this;
            r1 = r19
            r0 = r20
            o.switchOn r2 = r1.invoke
            int r2 = r2.isInside
            o.switchOn r3 = r1.invoke
            int r3 = r3.values
            r4 = 39
            boolean r5 = r1.setMin((int) r4)
            java.lang.String r6 = "arguments"
            java.lang.String r7 = "msg.bad.id.strict"
            java.lang.String r8 = "msg.no.paren.parms"
            java.lang.String r9 = "eval"
            r10 = 0
            r11 = 88
            r12 = 0
            if (r5 == 0) goto L_0x0057
            r5 = 1
            o.CircleFrameLayout$WidgetListener r5 = r1.setMax((boolean) r5, (int) r4)
            boolean r13 = r1.setMax
            if (r13 == 0) goto L_0x003a
            java.lang.String r13 = r5.equals
            boolean r14 = r9.equals(r13)
            if (r14 != 0) goto L_0x0037
            boolean r14 = r6.equals(r13)
            if (r14 == 0) goto L_0x003a
        L_0x0037:
            r1.getMax((java.lang.String) r7, (java.lang.String) r13)
        L_0x003a:
            boolean r13 = r1.setMin((int) r11)
            if (r13 != 0) goto L_0x0054
            o.SecureQwertyKeyboard$2 r13 = r1.length
            boolean r13 = r13.setMin()
            if (r13 == 0) goto L_0x004e
            o.isHasFace r5 = r1.setMax((boolean) r12, (o.isHasFace) r5)
            r13 = r10
            goto L_0x0050
        L_0x004e:
            r13 = r5
            r5 = r10
        L_0x0050:
            r1.length((int) r11, (java.lang.String) r8)
            goto L_0x0072
        L_0x0054:
            r13 = r5
            r5 = r10
            goto L_0x0072
        L_0x0057:
            boolean r5 = r1.setMin((int) r11)
            if (r5 != 0) goto L_0x0070
            o.SecureQwertyKeyboard$2 r5 = r1.length
            boolean r5 = r5.setMin()
            if (r5 == 0) goto L_0x006a
            o.isHasFace r5 = r1.getMax((boolean) r12)
            goto L_0x006b
        L_0x006a:
            r5 = r10
        L_0x006b:
            r1.length((int) r11, (java.lang.String) r8)
            r13 = r10
            goto L_0x0072
        L_0x0070:
            r5 = r10
            r13 = r5
        L_0x0072:
            int r8 = r1.valueOf
            r14 = -1
            if (r8 != r11) goto L_0x007c
            o.switchOn r8 = r1.invoke
            int r8 = r8.values
            goto L_0x007d
        L_0x007c:
            r8 = -1
        L_0x007d:
            r15 = 2
            if (r5 == 0) goto L_0x0082
            r11 = 2
            goto L_0x0083
        L_0x0082:
            r11 = r0
        L_0x0083:
            if (r11 == r15) goto L_0x009c
            if (r13 == 0) goto L_0x009c
            java.lang.String r11 = r13.equals
            if (r11 != 0) goto L_0x008d
            r11 = 0
            goto L_0x0093
        L_0x008d:
            java.lang.String r11 = r13.equals
            int r11 = r11.length()
        L_0x0093:
            if (r11 <= 0) goto L_0x009c
            java.lang.String r11 = r13.equals
            r15 = 110(0x6e, float:1.54E-43)
            r1.length((int) r15, (java.lang.String) r11, (boolean) r12)
        L_0x009c:
            org.mozilla.javascript.ast.FunctionNode r11 = new org.mozilla.javascript.ast.FunctionNode
            r11.<init>(r3, r13)
            r11.invokeSuspend = r0
            if (r8 == r14) goto L_0x00a8
            int r8 = r8 - r3
            r11.toDoubleRange = r8
        L_0x00a8:
            o.getFaceRegion r8 = r1.b
            r1.b = r10
            r11.getMax((o.getFaceRegion) r8)
            o.traceTemplate$getMax r8 = new o.traceTemplate$getMax
            r8.<init>(r11)
            r14 = 89
            boolean r15 = r1.setMin((int) r14)     // Catch:{ all -> 0x0254 }
            if (r15 == 0) goto L_0x00cb
            o.switchOn r4 = r1.invoke     // Catch:{ all -> 0x0254 }
            int r4 = r4.values     // Catch:{ all -> 0x0254 }
            int r6 = r11.Mean$Arithmetic()     // Catch:{ all -> 0x0254 }
            int r4 = r4 - r6
            r11.toIntRange(r4)     // Catch:{ all -> 0x0254 }
            r7 = 0
            goto L_0x01c9
        L_0x00cb:
            java.util.HashSet r15 = new java.util.HashSet     // Catch:{ all -> 0x0254 }
            r15.<init>()     // Catch:{ all -> 0x0254 }
            r16 = r10
        L_0x00d2:
            int r14 = r19.getMin()     // Catch:{ all -> 0x0254 }
            r10 = 84
            if (r14 == r10) goto L_0x0133
            r10 = 86
            if (r14 != r10) goto L_0x00df
            goto L_0x0133
        L_0x00df:
            java.lang.String r10 = "msg.no.parm"
            boolean r10 = r1.length((int) r4, (java.lang.String) r10)     // Catch:{ all -> 0x0254 }
            if (r10 == 0) goto L_0x0123
            o.CircleFrameLayout$WidgetListener r10 = r1.setMax((boolean) r12, (int) r4)     // Catch:{ all -> 0x0254 }
            o.getFaceRegion r14 = r1.b     // Catch:{ all -> 0x0254 }
            r4 = 0
            r1.b = r4     // Catch:{ all -> 0x0254 }
            if (r14 == 0) goto L_0x00f5
            r10.getMax((o.getFaceRegion) r14)     // Catch:{ all -> 0x0254 }
        L_0x00f5:
            r11.getMin(r10)     // Catch:{ all -> 0x0254 }
            o.switchOn r10 = r1.invoke     // Catch:{ all -> 0x0254 }
            java.lang.String r10 = r10.setMin     // Catch:{ all -> 0x0254 }
            r14 = 88
            r1.length((int) r14, (java.lang.String) r10, (boolean) r12)     // Catch:{ all -> 0x0254 }
            boolean r14 = r1.setMax     // Catch:{ all -> 0x0254 }
            if (r14 == 0) goto L_0x012b
            boolean r14 = r9.equals(r10)     // Catch:{ all -> 0x0254 }
            if (r14 != 0) goto L_0x0111
            boolean r14 = r6.equals(r10)     // Catch:{ all -> 0x0254 }
            if (r14 == 0) goto L_0x0114
        L_0x0111:
            r1.getMax((java.lang.String) r7, (java.lang.String) r10)     // Catch:{ all -> 0x0254 }
        L_0x0114:
            boolean r14 = r15.contains(r10)     // Catch:{ all -> 0x0254 }
            if (r14 == 0) goto L_0x011f
            java.lang.String r14 = "msg.dup.param.strict"
            r1.length((java.lang.String) r14, (java.lang.String) r10)     // Catch:{ all -> 0x0254 }
        L_0x011f:
            r15.add(r10)     // Catch:{ all -> 0x0254 }
            goto L_0x012b
        L_0x0123:
            r4 = 0
            o.getLeftEyeBlinkRatio r10 = r19.IPostMessageService()     // Catch:{ all -> 0x0254 }
            r11.getMin(r10)     // Catch:{ all -> 0x0254 }
        L_0x012b:
            r17 = r6
            r18 = r7
            r6 = 88
            r7 = 0
            goto L_0x016c
        L_0x0133:
            r4 = 0
            o.isHasFace r10 = r19.mayLaunchUrl()     // Catch:{ all -> 0x0254 }
            getMax((o.isHasFace) r10)     // Catch:{ all -> 0x0254 }
            r11.getMin(r10)     // Catch:{ all -> 0x0254 }
            if (r16 != 0) goto L_0x0145
            java.util.HashMap r16 = new java.util.HashMap     // Catch:{ all -> 0x0254 }
            r16.<init>()     // Catch:{ all -> 0x0254 }
        L_0x0145:
            r14 = r16
            o.getCricleColor r4 = r1.setMin     // Catch:{ all -> 0x0254 }
            java.lang.StringBuilder r12 = new java.lang.StringBuilder     // Catch:{ all -> 0x0254 }
            r17 = r6
            java.lang.String r6 = "$"
            r12.<init>(r6)     // Catch:{ all -> 0x0254 }
            int r6 = r4.setDefaultImpl     // Catch:{ all -> 0x0254 }
            r18 = r7
            int r7 = r6 + 1
            r4.setDefaultImpl = r7     // Catch:{ all -> 0x0254 }
            r12.append(r6)     // Catch:{ all -> 0x0254 }
            java.lang.String r4 = r12.toString()     // Catch:{ all -> 0x0254 }
            r6 = 88
            r7 = 0
            r1.length((int) r6, (java.lang.String) r4, (boolean) r7)     // Catch:{ all -> 0x0254 }
            r14.put(r4, r10)     // Catch:{ all -> 0x0254 }
            r16 = r14
        L_0x016c:
            r4 = 90
            boolean r10 = r1.setMin((int) r4)     // Catch:{ all -> 0x0254 }
            if (r10 != 0) goto L_0x024a
            if (r16 == 0) goto L_0x01b3
            o.LogFactory r6 = new o.LogFactory     // Catch:{ all -> 0x0254 }
            r6.<init>(r4)     // Catch:{ all -> 0x0254 }
            java.util.Set r4 = r16.entrySet()     // Catch:{ all -> 0x0254 }
            java.util.Iterator r4 = r4.iterator()     // Catch:{ all -> 0x0254 }
        L_0x0183:
            boolean r9 = r4.hasNext()     // Catch:{ all -> 0x0254 }
            if (r9 == 0) goto L_0x01ae
            java.lang.Object r9 = r4.next()     // Catch:{ all -> 0x0254 }
            java.util.Map$Entry r9 = (java.util.Map.Entry) r9     // Catch:{ all -> 0x0254 }
            r10 = 123(0x7b, float:1.72E-43)
            java.lang.Object r12 = r9.getValue()     // Catch:{ all -> 0x0254 }
            o.LogFactory r12 = (o.LogFactory) r12     // Catch:{ all -> 0x0254 }
            java.lang.Object r9 = r9.getKey()     // Catch:{ all -> 0x0254 }
            java.lang.String r9 = (java.lang.String) r9     // Catch:{ all -> 0x0254 }
            r14 = 39
            r1.getMin((java.lang.String) r9, (int) r14)     // Catch:{ all -> 0x0254 }
            o.LogFactory r9 = o.LogFactory.length((int) r14, (java.lang.String) r9)     // Catch:{ all -> 0x0254 }
            o.LogFactory r9 = r1.getMax((int) r10, (o.LogFactory) r12, (o.LogFactory) r9)     // Catch:{ all -> 0x0254 }
            r6.getMax((o.LogFactory) r9)     // Catch:{ all -> 0x0254 }
            goto L_0x0183
        L_0x01ae:
            r4 = 23
            r11.setMax((int) r4, (java.lang.Object) r6)     // Catch:{ all -> 0x0254 }
        L_0x01b3:
            java.lang.String r4 = "msg.no.paren.after.parms"
            r10 = 89
            boolean r4 = r1.length((int) r10, (java.lang.String) r4)     // Catch:{ all -> 0x0254 }
            if (r4 == 0) goto L_0x01c9
            o.switchOn r4 = r1.invoke     // Catch:{ all -> 0x0254 }
            int r4 = r4.values     // Catch:{ all -> 0x0254 }
            int r6 = r11.Mean$Arithmetic()     // Catch:{ all -> 0x0254 }
            int r4 = r4 - r6
            r11.toIntRange(r4)     // Catch:{ all -> 0x0254 }
        L_0x01c9:
            o.isHasFace r0 = r1.length((int) r0, (org.mozilla.javascript.ast.FunctionNode) r11)     // Catch:{ all -> 0x0254 }
            r11.setMax(r0)     // Catch:{ all -> 0x0254 }
            o.switchOn r0 = r1.invoke     // Catch:{ all -> 0x0254 }
            int r0 = r0.toString     // Catch:{ all -> 0x0254 }
            r11.extraCallback = r3     // Catch:{ all -> 0x0254 }
            r11.onRelationshipValidationResult = r0     // Catch:{ all -> 0x0254 }
            o.switchOn r0 = r1.invoke     // Catch:{ all -> 0x0254 }
            int r0 = r0.toString     // Catch:{ all -> 0x0254 }
            int r0 = r0 - r3
            r11.equals(r0)     // Catch:{ all -> 0x0254 }
            o.SecureQwertyKeyboard$2 r0 = r1.length     // Catch:{ all -> 0x0254 }
            boolean r0 = r0.IsOverlapping()     // Catch:{ all -> 0x0254 }
            if (r0 == 0) goto L_0x0217
            o.isHasFace r0 = r11.isInside     // Catch:{ all -> 0x0254 }
            boolean r0 = r0.FastBitmap$CoordinateSystem()     // Catch:{ all -> 0x0254 }
            if (r0 != 0) goto L_0x0217
            if (r13 == 0) goto L_0x0203
            java.lang.String r0 = r13.equals     // Catch:{ all -> 0x0254 }
            if (r0 != 0) goto L_0x01f8
            r12 = 0
            goto L_0x01fe
        L_0x01f8:
            java.lang.String r0 = r13.equals     // Catch:{ all -> 0x0254 }
            int r12 = r0.length()     // Catch:{ all -> 0x0254 }
        L_0x01fe:
            if (r12 <= 0) goto L_0x0203
            java.lang.String r0 = "msg.no.return.value"
            goto L_0x0205
        L_0x0203:
            java.lang.String r0 = "msg.anon.no.return.value"
        L_0x0205:
            if (r13 != 0) goto L_0x020a
            java.lang.String r3 = ""
            goto L_0x020c
        L_0x020a:
            java.lang.String r3 = r13.equals     // Catch:{ all -> 0x0254 }
        L_0x020c:
            o.SecureQwertyKeyboard$2 r4 = r1.length     // Catch:{ all -> 0x0254 }
            boolean r4 = r4.IsOverlapping()     // Catch:{ all -> 0x0254 }
            if (r4 == 0) goto L_0x0217
            r1.setMin((java.lang.String) r0, (java.lang.String) r3)     // Catch:{ all -> 0x0254 }
        L_0x0217:
            r8.getMin()
            if (r5 == 0) goto L_0x0226
            o.getStyleId.setMin()
            r11.create = r5
            if (r5 == 0) goto L_0x0226
            r5.getMax(r11)
        L_0x0226:
            java.lang.String r0 = r1.hashCode
            r11.extraCallbackWithResult = r0
            r11.hashCode(r2)
            o.switchOn r0 = r1.invoke
            int r0 = r0.isInside
            if (r0 < 0) goto L_0x0237
            int r2 = r11.ICustomTabsCallback$Stub
            if (r2 < 0) goto L_0x023a
        L_0x0237:
            o.getCricleColor.ICustomTabsCallback()
        L_0x023a:
            r11.ICustomTabsCallback$Stub = r0
            o.SecureQwertyKeyboard$2 r0 = r1.length
            boolean r0 = r0.values()
            if (r0 == 0) goto L_0x0249
            o.setRoundColor r0 = r1.toIntRange
            r11.setMax(r0)
        L_0x0249:
            return r11
        L_0x024a:
            r6 = r17
            r7 = r18
            r4 = 39
            r10 = 0
            r12 = 0
            goto L_0x00d2
        L_0x0254:
            r0 = move-exception
            r8.getMin()
            goto L_0x025a
        L_0x0259:
            throw r0
        L_0x025a:
            goto L_0x0259
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.setMax(int):org.mozilla.javascript.ast.FunctionNode");
    }

    /* JADX INFO: finally extract failed */
    private isHasFace setMax(isHasFace ishasface) throws IOException {
        int i = this.invoke.isInside;
        int Mean$Arithmetic2 = ishasface != null ? ishasface.Mean$Arithmetic() : -1;
        FunctionNode functionNode = new FunctionNode(Mean$Arithmetic2);
        functionNode.invokeSuspend = 4;
        getFaceRegion getfaceregion = this.b;
        this.b = null;
        functionNode.getMax(getfaceregion);
        HashMap hashMap = new HashMap();
        HashSet hashSet = new HashSet();
        getMax getmax = new getMax(functionNode);
        try {
            if (ishasface instanceof PromptTextView.AnonymousClass1) {
                int create2 = ishasface.create();
                functionNode.toDoubleRange = 0;
                functionNode.Grayscale$Algorithm = create2;
                isHasFace ishasface2 = ((PromptTextView.AnonymousClass1) ishasface).equals;
                if (!(ishasface2 instanceof getPitch)) {
                    getMin(functionNode, ishasface2, hashMap, hashSet);
                }
            } else {
                getMin(functionNode, ishasface, hashMap, hashSet);
            }
            if (!hashMap.isEmpty()) {
                LogFactory logFactory = new LogFactory(90);
                for (Map.Entry entry : hashMap.entrySet()) {
                    String str = (String) entry.getKey();
                    getMin(str, 39);
                    logFactory.getMax(getMax(123, (LogFactory) entry.getValue(), LogFactory.length(39, str)));
                }
                functionNode.setMax(23, (Object) logFactory);
            }
            functionNode.setMax(length(4, functionNode));
            int i2 = this.invoke.toString;
            functionNode.extraCallback = Mean$Arithmetic2;
            functionNode.onRelationshipValidationResult = i2;
            functionNode.equals(this.invoke.toString - Mean$Arithmetic2);
            getmax.getMin();
            if (functionNode.invokeSuspend()) {
                getMax("msg.arrowfunction.generator", (String) null);
                return IPostMessageService();
            }
            functionNode.extraCallbackWithResult = this.hashCode;
            functionNode.hashCode(i);
            int i3 = this.invoke.isInside;
            if (i3 < 0 || functionNode.ICustomTabsCallback$Stub >= 0) {
                getCricleColor.ICustomTabsCallback();
            }
            functionNode.ICustomTabsCallback$Stub = i3;
            return functionNode;
        } catch (Throwable th) {
            getmax.getMin();
            throw th;
        }
    }

    private void getMin(FunctionNode functionNode, isHasFace ishasface, Map<String, LogFactory> map, Set<String> set) {
        while (!(ishasface instanceof setFaceId) && !(ishasface instanceof LoadingProgressDialog)) {
            if ((ishasface instanceof getRightEyeBlinkRatio) && ishasface.length() == 90) {
                getRightEyeBlinkRatio getrighteyeblinkratio = (getRightEyeBlinkRatio) ishasface;
                getMin(functionNode, getrighteyeblinkratio.Grayscale$Algorithm(), map, set);
                ishasface = getrighteyeblinkratio.invokeSuspend();
            } else if (ishasface instanceof CircleFrameLayout.WidgetListener) {
                functionNode.getMin(ishasface);
                String str = ((CircleFrameLayout.WidgetListener) ishasface).equals;
                length(88, str, false);
                if (this.setMax) {
                    if ("eval".equals(str) || "arguments".equals(str)) {
                        getMax("msg.bad.id.strict", str);
                    }
                    if (set.contains(str)) {
                        length("msg.dup.param.strict", str);
                    }
                    set.add(str);
                    return;
                }
                return;
            } else {
                ishasface.Mean$Arithmetic();
                ishasface.create();
                getMin("msg.no.parm");
                functionNode.getMin(IPostMessageService());
                return;
            }
        }
        getMax(ishasface);
        functionNode.getMin(ishasface);
        getCricleColor getcriclecolor = this.setMin;
        StringBuilder sb = new StringBuilder("$");
        int i = getcriclecolor.setDefaultImpl;
        getcriclecolor.setDefaultImpl = i + 1;
        sb.append(i);
        String obj = sb.toString();
        length(88, obj, false);
        map.put(obj, ishasface);
    }

    private isHasFace getMin(isHasFace ishasface) throws IOException {
        if (this.valueOf != 86 && !this.length.values()) {
            ITrustedWebActivityCallback();
        }
        int i = this.invoke.values;
        if (ishasface == null) {
            ishasface = new AlgorithmInfo(i);
        }
        ishasface.setMin(this.invoke.isInside);
        while (true) {
            int min = getMin();
            if (min <= 0 || min == 87) {
                ishasface.equals(this.invoke.values - i);
            } else {
                ishasface.length(isInside());
            }
        }
        ishasface.equals(this.invoke.values - i);
        return ishasface;
    }

    static class setMin {
        int getMax;
        isHasFace length;
        int setMax;

        private setMin() {
            this.setMax = -1;
            this.getMax = -1;
        }

        /* synthetic */ setMin(byte b) {
            this();
        }
    }

    private setMin equals() throws IOException {
        setMin setmin = new setMin((byte) 0);
        if (length(88, "msg.no.paren.cond")) {
            setmin.setMax = this.invoke.values;
        }
        setmin.length = extraCallbackWithResult();
        if (length(89, "msg.no.paren.after.cond")) {
            setmin.getMax = this.invoke.values;
        }
        if (setmin.length instanceof getFaceId) {
            setmin.length.Mean$Arithmetic();
            setmin.length.create();
            if (this.length.IsOverlapping()) {
                setMin("msg.equal.as.assign", "");
            }
        }
        return setmin;
    }

    /* JADX WARNING: Removed duplicated region for block: B:19:0x0049  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.isHasFace isInside() throws java.io.IOException {
        /*
            r5 = this;
            o.switchOn r0 = r5.invoke
            int r0 = r0.values
            o.isHasFace r1 = r5.toFloatRange()     // Catch:{ length -> 0x003c }
            if (r1 == 0) goto L_0x003d
            o.SecureQwertyKeyboard$2 r2 = r5.length     // Catch:{ length -> 0x003c }
            boolean r2 = r2.IsOverlapping()     // Catch:{ length -> 0x003c }
            if (r2 == 0) goto L_0x003b
            boolean r2 = r1.toDoubleRange()     // Catch:{ length -> 0x003c }
            if (r2 != 0) goto L_0x003b
            int r2 = r1.Mean$Arithmetic()     // Catch:{ length -> 0x003c }
            r5.getMax((int) r2)     // Catch:{ length -> 0x003c }
            boolean r2 = r1 instanceof o.setYaw     // Catch:{ length -> 0x003c }
            if (r2 == 0) goto L_0x0026
            java.lang.String r2 = "msg.extra.trailing.semi"
            goto L_0x0028
        L_0x0026:
            java.lang.String r2 = "msg.no.side.effects"
        L_0x0028:
            java.lang.String r3 = ""
            r1.Mean$Arithmetic()     // Catch:{ length -> 0x003c }
            r1.create()     // Catch:{ length -> 0x003c }
            o.SecureQwertyKeyboard$2 r4 = r5.length     // Catch:{ length -> 0x003c }
            boolean r4 = r4.IsOverlapping()     // Catch:{ length -> 0x003c }
            if (r4 == 0) goto L_0x003b
            r5.setMin((java.lang.String) r2, (java.lang.String) r3)     // Catch:{ length -> 0x003c }
        L_0x003b:
            return r1
        L_0x003c:
        L_0x003d:
            int r1 = r5.getMin()
            int r2 = r5.invokeSuspend
            r3 = 65536(0x10000, float:9.18355E-41)
            r2 = r2 & r3
            r3 = 1
            if (r2 == 0) goto L_0x004a
            r1 = 1
        L_0x004a:
            r2 = 0
            r5.invokeSuspend = r2
            r2 = -1
            if (r1 == r2) goto L_0x0059
            if (r1 == 0) goto L_0x0059
            if (r1 == r3) goto L_0x0059
            r2 = 83
            if (r1 == r2) goto L_0x0059
            goto L_0x003d
        L_0x0059:
            o.setYaw r1 = new o.setYaw
            o.switchOn r2 = r5.invoke
            int r2 = r2.values
            int r2 = r2 - r0
            r1.<init>(r0, r2)
            return r1
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.isInside():o.isHasFace");
    }

    private isHasFace toFloatRange() throws IOException {
        isHasFace ishasface;
        setDeepLiveness setdeepliveness = this.getCause;
        if (!(setdeepliveness == null || setdeepliveness.equals == null)) {
            this.getCause = null;
        }
        int min = getMin();
        if (min != -1) {
            if (min != 4) {
                if (min == 39) {
                    ishasface = onRelationshipValidationResult();
                    if (!(ishasface instanceof setIntegrity)) {
                        return ishasface;
                    }
                } else if (min == 50) {
                    ishasface = invokeSuspend();
                } else if (min != 73) {
                    if (min == 86) {
                        return b();
                    }
                    if (min == 110) {
                        this.invokeSuspend = 0;
                        return setMax(3);
                    } else if (min == 113) {
                        return FastBitmap$CoordinateSystem();
                    } else {
                        if (min == 115) {
                            return values();
                        }
                        if (min == 161) {
                            this.invokeSuspend = 0;
                            ishasface = new showInfo(this.invoke.values, this.invoke.toString - this.invoke.values, min);
                            ishasface.setMin(this.invoke.isInside);
                        } else if (min == 82) {
                            return Mean$Arithmetic();
                        } else {
                            if (min == 83) {
                                this.invokeSuspend = 0;
                                int i = this.invoke.values;
                                setYaw setyaw = new setYaw(i, this.invoke.toString - i);
                                setyaw.setMin(this.invoke.isInside);
                                return setyaw;
                            } else if (min != 154) {
                                if (min != 155) {
                                    switch (min) {
                                        case 117:
                                            ishasface = onPostMessage();
                                            break;
                                        case 118:
                                            return toDoubleRange();
                                        case 119:
                                            return invoke();
                                        case 120:
                                            return Grayscale$Algorithm();
                                        case 121:
                                            ishasface = onNavigationEvent();
                                            break;
                                        case 122:
                                            ishasface = ICustomTabsCallback();
                                            break;
                                        case 123:
                                            break;
                                        case 124:
                                            if (this.setMax) {
                                                getMax("msg.no.with.strict", (String) null);
                                            }
                                            return create();
                                        default:
                                            int i2 = this.invoke.isInside;
                                            ishasface = new setIntegrity(extraCallbackWithResult(), !length());
                                            ishasface.setMin(i2);
                                            break;
                                    }
                                }
                                this.invokeSuspend = 0;
                                int i3 = this.invoke.isInside;
                                ishasface = setMax(this.valueOf, this.invoke.values, true);
                                ishasface.setMin(i3);
                            } else {
                                ishasface = getCause();
                                if (!(ishasface instanceof getCricleProgressColor) || getMin() != 83) {
                                    return ishasface;
                                }
                            }
                        }
                    }
                }
                setMin(ishasface);
                return ishasface;
            }
            ishasface = setMin(min, false);
            setMin(ishasface);
            return ishasface;
        }
        this.invokeSuspend = 0;
        return IPostMessageService();
    }

    private setLeftEyeBlinkRatio FastBitmap$CoordinateSystem() throws IOException {
        if (this.valueOf != 113) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        int i = this.invoke.values;
        int i2 = this.invoke.isInside;
        int i3 = -1;
        setMin equals2 = equals();
        isHasFace isInside2 = isInside();
        isHasFace ishasface = null;
        if (setMin(114)) {
            i3 = this.invoke.values - i;
            ishasface = isInside();
        }
        isHasFace ishasface2 = ishasface != null ? ishasface : isInside2;
        setLeftEyeBlinkRatio setlefteyeblinkratio = new setLeftEyeBlinkRatio(i, (ishasface2.Mean$Arithmetic() + ishasface2.create()) - i);
        isHasFace ishasface3 = equals2.length;
        if (ishasface3 != null) {
            setlefteyeblinkratio.isInside = ishasface3;
            ishasface3.getMax(setlefteyeblinkratio);
            setlefteyeblinkratio.values = equals2.setMax - i;
            setlefteyeblinkratio.toDoubleRange = equals2.getMax - i;
            if (isInside2 != null) {
                setlefteyeblinkratio.toFloatRange = isInside2;
                isInside2.getMax(setlefteyeblinkratio);
                setlefteyeblinkratio.toIntRange = ishasface;
                if (ishasface != null) {
                    ishasface.getMax(setlefteyeblinkratio);
                }
                setlefteyeblinkratio.equals = i3;
                setlefteyeblinkratio.setMin(i2);
                return setlefteyeblinkratio;
            }
            throw new IllegalArgumentException("arg cannot be null");
        }
        throw new IllegalArgumentException("arg cannot be null");
    }

    /* JADX WARNING: Code restructure failed: missing block: B:25:?, code lost:
        getMax("msg.bad.switch", (java.lang.String) null);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.RoundProgressBar values() throws java.io.IOException {
        /*
            r14 = this;
            int r0 = r14.valueOf
            r1 = 115(0x73, float:1.61E-43)
            if (r0 == r1) goto L_0x0009
            r14.ITrustedWebActivityCallback()
        L_0x0009:
            r0 = 0
            r14.invokeSuspend = r0
            o.switchOn r1 = r14.invoke
            int r1 = r1.values
            o.RoundProgressBar r2 = new o.RoundProgressBar
            r2.<init>(r1)
            r3 = 88
            java.lang.String r4 = "msg.no.paren.switch"
            boolean r3 = r14.length((int) r3, (java.lang.String) r4)
            if (r3 == 0) goto L_0x0026
            o.switchOn r3 = r14.invoke
            int r3 = r3.values
            int r3 = r3 - r1
            r2.toIntRange = r3
        L_0x0026:
            o.switchOn r3 = r14.invoke
            int r3 = r3.isInside
            r2.setMin((int) r3)
            o.isHasFace r3 = r14.extraCallbackWithResult()
            java.lang.String r4 = "arg cannot be null"
            if (r3 == 0) goto L_0x0122
            r2.isInside = r3
            r3.getMax(r2)
            java.util.List<o.AlgorithmInfoPattern> r3 = r14.equals
            if (r3 != 0) goto L_0x0045
            java.util.ArrayList r3 = new java.util.ArrayList
            r3.<init>()
            r14.equals = r3
        L_0x0045:
            java.util.List<o.AlgorithmInfoPattern> r3 = r14.equals
            r3.add(r2)
            r3 = 89
            r5 = 1
            java.lang.String r6 = "msg.no.paren.after.switch"
            boolean r3 = r14.length((int) r3, (java.lang.String) r6)     // Catch:{ all -> 0x0116 }
            if (r3 == 0) goto L_0x005c
            o.switchOn r3 = r14.invoke     // Catch:{ all -> 0x0116 }
            int r3 = r3.values     // Catch:{ all -> 0x0116 }
            int r3 = r3 - r1
            r2.values = r3     // Catch:{ all -> 0x0116 }
        L_0x005c:
            r3 = 86
            java.lang.String r6 = "msg.no.brace.switch"
            r14.length((int) r3, (java.lang.String) r6)     // Catch:{ all -> 0x0116 }
        L_0x0063:
            int r3 = r14.setMax()     // Catch:{ all -> 0x0116 }
            o.switchOn r6 = r14.invoke     // Catch:{ all -> 0x0116 }
            int r6 = r6.values     // Catch:{ all -> 0x0116 }
            o.switchOn r7 = r14.invoke     // Catch:{ all -> 0x0116 }
            int r7 = r7.isInside     // Catch:{ all -> 0x0116 }
            r8 = 87
            if (r3 == r8) goto L_0x0103
            java.lang.String r9 = "msg.no.colon.case"
            r10 = 104(0x68, float:1.46E-43)
            r11 = 117(0x75, float:1.64E-43)
            r12 = 116(0x74, float:1.63E-43)
            r13 = 0
            if (r3 == r12) goto L_0x0093
            if (r3 == r11) goto L_0x0087
            java.lang.String r0 = "msg.bad.switch"
            r14.getMax((java.lang.String) r0, (java.lang.String) r13)     // Catch:{ all -> 0x0116 }
            goto L_0x010b
        L_0x0087:
            if (r0 == 0) goto L_0x008e
            java.lang.String r0 = "msg.double.switch.default"
            r14.getMax((java.lang.String) r0, (java.lang.String) r13)     // Catch:{ all -> 0x0116 }
        L_0x008e:
            r14.length((int) r10, (java.lang.String) r9)     // Catch:{ all -> 0x0116 }
            r0 = 1
            goto L_0x009a
        L_0x0093:
            o.isHasFace r13 = r14.extraCallbackWithResult()     // Catch:{ all -> 0x0116 }
            r14.length((int) r10, (java.lang.String) r9)     // Catch:{ all -> 0x0116 }
        L_0x009a:
            o.setCricleColor r3 = new o.setCricleColor     // Catch:{ all -> 0x0116 }
            r3.<init>(r6)     // Catch:{ all -> 0x0116 }
            r3.toIntRange = r13     // Catch:{ all -> 0x0116 }
            if (r13 == 0) goto L_0x00a6
            r13.getMax(r3)     // Catch:{ all -> 0x0116 }
        L_0x00a6:
            o.switchOn r6 = r14.invoke     // Catch:{ all -> 0x0116 }
            int r6 = r6.toString     // Catch:{ all -> 0x0116 }
            int r6 = r6 - r1
            r3.equals(r6)     // Catch:{ all -> 0x0116 }
            r3.setMin((int) r7)     // Catch:{ all -> 0x0116 }
        L_0x00b1:
            int r6 = r14.getMin()     // Catch:{ all -> 0x0116 }
            if (r6 == r8) goto L_0x00ee
            if (r6 == r12) goto L_0x00ee
            if (r6 == r11) goto L_0x00ee
            if (r6 == 0) goto L_0x00ee
            o.isHasFace r6 = r14.isInside()     // Catch:{ all -> 0x0116 }
            if (r6 == 0) goto L_0x00e8
            java.util.List<o.isHasFace> r7 = r3.equals     // Catch:{ all -> 0x0116 }
            if (r7 != 0) goto L_0x00ce
            java.util.ArrayList r7 = new java.util.ArrayList     // Catch:{ all -> 0x0116 }
            r7.<init>()     // Catch:{ all -> 0x0116 }
            r3.equals = r7     // Catch:{ all -> 0x0116 }
        L_0x00ce:
            int r7 = r6.Mean$Arithmetic()     // Catch:{ all -> 0x0116 }
            int r9 = r6.create()     // Catch:{ all -> 0x0116 }
            int r7 = r7 + r9
            int r9 = r3.Mean$Arithmetic()     // Catch:{ all -> 0x0116 }
            int r7 = r7 - r9
            r3.equals(r7)     // Catch:{ all -> 0x0116 }
            java.util.List<o.isHasFace> r7 = r3.equals     // Catch:{ all -> 0x0116 }
            r7.add(r6)     // Catch:{ all -> 0x0116 }
            r6.getMax(r3)     // Catch:{ all -> 0x0116 }
            goto L_0x00b1
        L_0x00e8:
            java.lang.IllegalArgumentException r0 = new java.lang.IllegalArgumentException     // Catch:{ all -> 0x0116 }
            r0.<init>(r4)     // Catch:{ all -> 0x0116 }
            throw r0     // Catch:{ all -> 0x0116 }
        L_0x00ee:
            java.util.List<o.setCricleColor> r6 = r2.equals     // Catch:{ all -> 0x0116 }
            if (r6 != 0) goto L_0x00f9
            java.util.ArrayList r6 = new java.util.ArrayList     // Catch:{ all -> 0x0116 }
            r6.<init>()     // Catch:{ all -> 0x0116 }
            r2.equals = r6     // Catch:{ all -> 0x0116 }
        L_0x00f9:
            java.util.List<o.setCricleColor> r6 = r2.equals     // Catch:{ all -> 0x0116 }
            r6.add(r3)     // Catch:{ all -> 0x0116 }
            r3.getMax(r2)     // Catch:{ all -> 0x0116 }
            goto L_0x0063
        L_0x0103:
            o.switchOn r0 = r14.invoke     // Catch:{ all -> 0x0116 }
            int r0 = r0.toString     // Catch:{ all -> 0x0116 }
            int r0 = r0 - r1
            r2.equals(r0)     // Catch:{ all -> 0x0116 }
        L_0x010b:
            java.util.List<o.AlgorithmInfoPattern> r0 = r14.equals
            int r1 = r0.size()
            int r1 = r1 - r5
            r0.remove(r1)
            return r2
        L_0x0116:
            r0 = move-exception
            java.util.List<o.AlgorithmInfoPattern> r1 = r14.equals
            int r2 = r1.size()
            int r2 = r2 - r5
            r1.remove(r2)
            throw r0
        L_0x0122:
            java.lang.IllegalArgumentException r0 = new java.lang.IllegalArgumentException
            r0.<init>(r4)
            goto L_0x0129
        L_0x0128:
            throw r0
        L_0x0129:
            goto L_0x0128
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.values():o.RoundProgressBar");
    }

    private getWaveShiftRatio toDoubleRange() throws IOException {
        if (this.valueOf != 118) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        int i = this.invoke.values;
        getWaveShiftRatio getwaveshiftratio = new getWaveShiftRatio(i);
        getwaveshiftratio.setMin(this.invoke.isInside);
        setMin((setWidgetListener) getwaveshiftratio);
        try {
            setMin equals2 = equals();
            isHasFace ishasface = equals2.length;
            if (ishasface != null) {
                getwaveshiftratio.isInside = ishasface;
                ishasface.getMax(getwaveshiftratio);
                getwaveshiftratio.getMin(equals2.setMax - i, equals2.getMax - i);
                isHasFace isInside2 = isInside();
                getwaveshiftratio.equals((isInside2.Mean$Arithmetic() + isInside2.create()) - i);
                getwaveshiftratio.setMin(isInside2);
                return getwaveshiftratio;
            }
            throw new IllegalArgumentException("arg cannot be null");
        } finally {
            toIntRange();
        }
    }

    /* JADX INFO: finally extract failed */
    private setPitch invoke() throws IOException {
        if (this.valueOf != 119) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        int i = this.invoke.values;
        setPitch setpitch = new setPitch(i);
        setpitch.setMin(this.invoke.isInside);
        setMin((setWidgetListener) setpitch);
        try {
            isHasFace isInside2 = isInside();
            length(118, "msg.no.while.do");
            setpitch.toIntRange = this.invoke.values - i;
            setMin equals2 = equals();
            isHasFace ishasface = equals2.length;
            if (ishasface != null) {
                setpitch.toFloatRange = ishasface;
                ishasface.getMax(setpitch);
                setpitch.getMin(equals2.setMax - i, equals2.getMax - i);
                int Mean$Arithmetic2 = isInside2.Mean$Arithmetic() + isInside2.create();
                setpitch.setMin(isInside2);
                toIntRange();
                if (setMin(83)) {
                    Mean$Arithmetic2 = this.invoke.toString;
                }
                setpitch.equals(Mean$Arithmetic2 - i);
                return setpitch;
            }
            throw new IllegalArgumentException("arg cannot be null");
        } catch (Throwable th) {
            toIntRange();
            throw th;
        }
    }

    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r0v4, resolved type: o.getMotion} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r0v7, resolved type: o.setMotion} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r0v13, resolved type: o.getMotion} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r0v14, resolved type: o.getMotion} */
    /* JADX WARNING: Multi-variable type inference failed */
    /* JADX WARNING: Removed duplicated region for block: B:17:0x004a A[Catch:{ all -> 0x0192, all -> 0x0197 }] */
    /* JADX WARNING: Removed duplicated region for block: B:18:0x0050 A[Catch:{ all -> 0x0192, all -> 0x0197 }] */
    /* JADX WARNING: Removed duplicated region for block: B:21:0x0063 A[Catch:{ all -> 0x0192, all -> 0x0197 }] */
    /* JADX WARNING: Removed duplicated region for block: B:23:0x0073 A[Catch:{ all -> 0x0192, all -> 0x0197 }] */
    /* JADX WARNING: Removed duplicated region for block: B:41:0x00e9 A[Catch:{ all -> 0x0192, all -> 0x0197 }] */
    /* JADX WARNING: Removed duplicated region for block: B:42:0x00ef A[Catch:{ all -> 0x0192, all -> 0x0197 }] */
    /* JADX WARNING: Removed duplicated region for block: B:44:0x00f2 A[Catch:{ all -> 0x0192, all -> 0x0197 }] */
    /* JADX WARNING: Removed duplicated region for block: B:77:0x0185  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.setWidgetListener Grayscale$Algorithm() throws java.io.IOException {
        /*
            r16 = this;
            r1 = r16
            int r0 = r1.valueOf
            r2 = 120(0x78, float:1.68E-43)
            if (r0 == r2) goto L_0x000b
            r16.ITrustedWebActivityCallback()
        L_0x000b:
            r0 = 0
            r1.invokeSuspend = r0
            o.switchOn r2 = r1.invoke
            int r2 = r2.values
            o.switchOn r3 = r1.invoke
            int r3 = r3.isInside
            o.setRoundColor r4 = new o.setRoundColor
            r4.<init>()
            r1.setMin((o.setRoundColor) r4)
            r5 = 39
            boolean r6 = r1.setMin((int) r5)     // Catch:{ all -> 0x0197 }
            java.lang.String r7 = "msg.no.paren.for"
            r8 = 0
            r10 = 1
            if (r6 == 0) goto L_0x0040
            java.lang.String r6 = "each"
            o.switchOn r11 = r1.invoke     // Catch:{ all -> 0x0197 }
            java.lang.String r11 = r11.setMin     // Catch:{ all -> 0x0197 }
            boolean r6 = r6.equals(r11)     // Catch:{ all -> 0x0197 }
            if (r6 == 0) goto L_0x003d
            o.switchOn r6 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r6 = r6.values     // Catch:{ all -> 0x0197 }
            int r6 = r6 - r2
            r11 = 1
            goto L_0x0042
        L_0x003d:
            r1.getMax((java.lang.String) r7, (java.lang.String) r8)     // Catch:{ all -> 0x0197 }
        L_0x0040:
            r6 = -1
            r11 = 0
        L_0x0042:
            r12 = 88
            boolean r7 = r1.length((int) r12, (java.lang.String) r7)     // Catch:{ all -> 0x0197 }
            if (r7 == 0) goto L_0x0050
            o.switchOn r7 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r7 = r7.values     // Catch:{ all -> 0x0197 }
            int r7 = r7 - r2
            goto L_0x0051
        L_0x0050:
            r7 = -1
        L_0x0051:
            int r12 = r16.getMin()     // Catch:{ all -> 0x0197 }
            o.isHasFace r12 = r1.getMin((int) r12)     // Catch:{ all -> 0x0197 }
            r13 = 52
            boolean r13 = r1.setMin((int) r13)     // Catch:{ all -> 0x0197 }
            r14 = 89
            if (r13 == 0) goto L_0x0073
            o.switchOn r5 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r5 = r5.values     // Catch:{ all -> 0x0197 }
            int r5 = r5 - r2
            o.isHasFace r13 = r16.extraCallbackWithResult()     // Catch:{ all -> 0x0197 }
            r9 = r8
            r15 = r13
            r0 = 1
            r13 = r5
        L_0x0070:
            r5 = 0
            goto L_0x00e1
        L_0x0073:
            o.SecureQwertyKeyboard$2 r13 = r1.length     // Catch:{ all -> 0x0197 }
            int r13 = r13.setMin     // Catch:{ all -> 0x0197 }
            r15 = 200(0xc8, float:2.8E-43)
            if (r13 < r15) goto L_0x009b
            boolean r5 = r1.setMin((int) r5)     // Catch:{ all -> 0x0197 }
            if (r5 == 0) goto L_0x009b
            java.lang.String r5 = "of"
            o.switchOn r13 = r1.invoke     // Catch:{ all -> 0x0197 }
            java.lang.String r13 = r13.setMin     // Catch:{ all -> 0x0197 }
            boolean r5 = r5.equals(r13)     // Catch:{ all -> 0x0197 }
            if (r5 == 0) goto L_0x009b
            o.switchOn r5 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r5 = r5.values     // Catch:{ all -> 0x0197 }
            int r5 = r5 - r2
            o.isHasFace r13 = r16.extraCallbackWithResult()     // Catch:{ all -> 0x0197 }
            r9 = r8
            r15 = r13
            r13 = r5
            r5 = 1
            goto L_0x00e1
        L_0x009b:
            java.lang.String r5 = "msg.no.semi.for"
            r13 = 83
            r1.length((int) r13, (java.lang.String) r5)     // Catch:{ all -> 0x0197 }
            int r5 = r16.getMin()     // Catch:{ all -> 0x0197 }
            if (r5 != r13) goto L_0x00b9
            o.getPitch r5 = new o.getPitch     // Catch:{ all -> 0x0197 }
            o.switchOn r15 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r15 = r15.values     // Catch:{ all -> 0x0197 }
            r5.<init>(r15, r10)     // Catch:{ all -> 0x0197 }
            o.switchOn r15 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r15 = r15.isInside     // Catch:{ all -> 0x0197 }
            r5.setMin((int) r15)     // Catch:{ all -> 0x0197 }
            goto L_0x00bd
        L_0x00b9:
            o.isHasFace r5 = r16.extraCallbackWithResult()     // Catch:{ all -> 0x0197 }
        L_0x00bd:
            java.lang.String r15 = "msg.no.semi.for.cond"
            r1.length((int) r13, (java.lang.String) r15)     // Catch:{ all -> 0x0197 }
            o.switchOn r13 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r13 = r13.toString     // Catch:{ all -> 0x0197 }
            int r15 = r16.getMin()     // Catch:{ all -> 0x0197 }
            if (r15 != r14) goto L_0x00d9
            o.getPitch r15 = new o.getPitch     // Catch:{ all -> 0x0197 }
            r15.<init>(r13, r10)     // Catch:{ all -> 0x0197 }
            o.switchOn r13 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r13 = r13.isInside     // Catch:{ all -> 0x0197 }
            r15.setMin((int) r13)     // Catch:{ all -> 0x0197 }
            goto L_0x00dd
        L_0x00d9:
            o.isHasFace r15 = r16.extraCallbackWithResult()     // Catch:{ all -> 0x0197 }
        L_0x00dd:
            r9 = r15
            r13 = -1
            r15 = r5
            goto L_0x0070
        L_0x00e1:
            java.lang.String r8 = "msg.no.paren.for.ctrl"
            boolean r8 = r1.length((int) r14, (java.lang.String) r8)     // Catch:{ all -> 0x0197 }
            if (r8 == 0) goto L_0x00ef
            o.switchOn r8 = r1.invoke     // Catch:{ all -> 0x0197 }
            int r8 = r8.values     // Catch:{ all -> 0x0197 }
            int r8 = r8 - r2
            goto L_0x00f0
        L_0x00ef:
            r8 = -1
        L_0x00f0:
            if (r0 != 0) goto L_0x0124
            if (r5 == 0) goto L_0x00f5
            goto L_0x0124
        L_0x00f5:
            o.setMotion r0 = new o.setMotion     // Catch:{ all -> 0x0197 }
            r0.<init>(r2)     // Catch:{ all -> 0x0197 }
            java.lang.String r5 = "arg cannot be null"
            if (r12 == 0) goto L_0x011e
            r0.isInside = r12     // Catch:{ all -> 0x0197 }
            r12.getMax(r0)     // Catch:{ all -> 0x0197 }
            if (r15 == 0) goto L_0x0118
            r0.equals = r15     // Catch:{ all -> 0x0197 }
            r15.getMax(r0)     // Catch:{ all -> 0x0197 }
            if (r9 == 0) goto L_0x0112
            r0.toFloatRange = r9     // Catch:{ all -> 0x0197 }
            r9.getMax(r0)     // Catch:{ all -> 0x0197 }
            goto L_0x015a
        L_0x0112:
            java.lang.IllegalArgumentException r0 = new java.lang.IllegalArgumentException     // Catch:{ all -> 0x0197 }
            r0.<init>(r5)     // Catch:{ all -> 0x0197 }
            throw r0     // Catch:{ all -> 0x0197 }
        L_0x0118:
            java.lang.IllegalArgumentException r0 = new java.lang.IllegalArgumentException     // Catch:{ all -> 0x0197 }
            r0.<init>(r5)     // Catch:{ all -> 0x0197 }
            throw r0     // Catch:{ all -> 0x0197 }
        L_0x011e:
            java.lang.IllegalArgumentException r0 = new java.lang.IllegalArgumentException     // Catch:{ all -> 0x0197 }
            r0.<init>(r5)     // Catch:{ all -> 0x0197 }
            throw r0     // Catch:{ all -> 0x0197 }
        L_0x0124:
            o.getMotion r0 = new o.getMotion     // Catch:{ all -> 0x0197 }
            r0.<init>(r2)     // Catch:{ all -> 0x0197 }
            boolean r9 = r12 instanceof o.getCricleProgressColor     // Catch:{ all -> 0x0197 }
            if (r9 == 0) goto L_0x013e
            r9 = r12
            o.getCricleProgressColor r9 = (o.getCricleProgressColor) r9     // Catch:{ all -> 0x0197 }
            java.util.List<o.getWaterLevelRatio> r9 = r9.isInside     // Catch:{ all -> 0x0197 }
            int r9 = r9.size()     // Catch:{ all -> 0x0197 }
            if (r9 <= r10) goto L_0x013e
            java.lang.String r9 = "msg.mult.index"
            r10 = 0
            r1.getMax((java.lang.String) r9, (java.lang.String) r10)     // Catch:{ all -> 0x0197 }
        L_0x013e:
            if (r5 == 0) goto L_0x0148
            if (r11 == 0) goto L_0x0148
            java.lang.String r9 = "msg.invalid.for.each"
            r10 = 0
            r1.getMax((java.lang.String) r9, (java.lang.String) r10)     // Catch:{ all -> 0x0197 }
        L_0x0148:
            r0.getMin((o.isHasFace) r12)     // Catch:{ all -> 0x0197 }
            r0.setMax((o.isHasFace) r15)     // Catch:{ all -> 0x0197 }
            r0.toIntRange(r13)     // Catch:{ all -> 0x0197 }
            r0.setMax((boolean) r11)     // Catch:{ all -> 0x0197 }
            r0.toDoubleRange(r6)     // Catch:{ all -> 0x0197 }
            r0.getMin((boolean) r5)     // Catch:{ all -> 0x0197 }
        L_0x015a:
            o.setRoundColor r5 = r1.toIntRange     // Catch:{ all -> 0x0197 }
            r5.setMin((o.setRoundColor) r0)     // Catch:{ all -> 0x0197 }
            o.setRoundColor r5 = r1.toIntRange     // Catch:{ all -> 0x0197 }
            o.setRoundColor r5 = r5.asInterface()     // Catch:{ all -> 0x0197 }
            r1.toIntRange = r5     // Catch:{ all -> 0x0197 }
            r1.setMin((o.setWidgetListener) r0)     // Catch:{ all -> 0x0197 }
            o.isHasFace r5 = r16.isInside()     // Catch:{ all -> 0x0192 }
            int r6 = r5.Mean$Arithmetic()     // Catch:{ all -> 0x0192 }
            int r9 = r5.create()     // Catch:{ all -> 0x0192 }
            int r6 = r6 + r9
            int r6 = r6 - r2
            r0.equals(r6)     // Catch:{ all -> 0x0192 }
            r0.setMin(r5)     // Catch:{ all -> 0x0192 }
            r16.toIntRange()     // Catch:{ all -> 0x0197 }
            o.setRoundColor r2 = r1.toIntRange
            if (r2 != r4) goto L_0x018b
            o.setRoundColor r2 = r2.asInterface()
            r1.toIntRange = r2
        L_0x018b:
            r0.getMin(r7, r8)
            r0.setMin((int) r3)
            return r0
        L_0x0192:
            r0 = move-exception
            r16.toIntRange()     // Catch:{ all -> 0x0197 }
            throw r0     // Catch:{ all -> 0x0197 }
        L_0x0197:
            r0 = move-exception
            o.setRoundColor r2 = r1.toIntRange
            if (r2 != r4) goto L_0x01a2
            o.setRoundColor r2 = r2.asInterface()
            r1.toIntRange = r2
        L_0x01a2:
            goto L_0x01a4
        L_0x01a3:
            throw r0
        L_0x01a4:
            goto L_0x01a3
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.Grayscale$Algorithm():o.setWidgetListener");
    }

    /* JADX INFO: finally extract failed */
    private isHasFace getMin(int i) throws IOException {
        isHasFace ishasface;
        try {
            this.onNavigationEvent = true;
            if (i == 83) {
                ishasface = new getPitch(this.invoke.values, 1);
                ishasface.setMin(this.invoke.isInside);
            } else {
                if (i != 123) {
                    if (i != 154) {
                        ishasface = extraCallbackWithResult();
                        getMax(ishasface);
                    }
                }
                this.invokeSuspend = 0;
                ishasface = setMax(i, this.invoke.values, false);
            }
            this.onNavigationEvent = false;
            return ishasface;
        } catch (Throwable th) {
            this.onNavigationEvent = false;
            throw th;
        }
    }

    /* JADX WARNING: type inference failed for: r3v0 */
    /* JADX WARNING: type inference failed for: r3v7, types: [java.lang.String, o.getFaceRegion] */
    /* JADX WARNING: type inference failed for: r3v12 */
    private setCricleProgressColor Mean$Arithmetic() throws IOException {
        ArrayList arrayList;
        int i;
        isHasFace ishasface;
        int i2;
        isHasFace ishasface2;
        int i3;
        if (this.valueOf != 82) {
            ITrustedWebActivityCallback();
        }
        boolean z = false;
        this.invokeSuspend = 0;
        getFaceRegion getfaceregion = this.b;
        ? r3 = 0;
        this.b = null;
        int i4 = this.invoke.values;
        int i5 = this.invoke.isInside;
        if (getMin() != 86) {
            getMax("msg.no.brace.try", (String) null);
        }
        isHasFace isInside2 = isInside();
        int Mean$Arithmetic2 = isInside2.Mean$Arithmetic() + isInside2.create();
        int min = getMin();
        int i6 = 125;
        if (min == 125) {
            arrayList = null;
            boolean z2 = false;
            while (setMin(i6)) {
                int i7 = this.invoke.isInside;
                if (z2) {
                    getMax("msg.catch.unreachable", (String) r3);
                }
                int i8 = this.invoke.values;
                int i9 = length(88, "msg.no.paren.catch") ? this.invoke.values : -1;
                length(39, "msg.bad.catchcond");
                CircleFrameLayout.WidgetListener max = setMax(z, 39);
                getFaceRegion getfaceregion2 = this.b;
                this.b = r3;
                if (getfaceregion2 != null) {
                    max.getMax(getfaceregion2);
                }
                String str = max.equals;
                if (this.setMax && ("eval".equals(str) || "arguments".equals(str))) {
                    getMax("msg.bad.id.strict", str);
                }
                if (setMin(113)) {
                    i3 = this.invoke.values;
                    ishasface2 = extraCallbackWithResult();
                } else {
                    z2 = true;
                    i3 = -1;
                    ishasface2 = null;
                }
                int i10 = length(89, "msg.bad.catchcond") ? this.invoke.values : -1;
                boolean z3 = z2;
                length(86, "msg.no.brace.catchblock");
                AlgorithmInfo algorithmInfo = (AlgorithmInfo) getMin((isHasFace) null);
                int Mean$Arithmetic3 = algorithmInfo.Mean$Arithmetic() + algorithmInfo.create();
                setEyeBlink seteyeblink = new setEyeBlink(i8);
                seteyeblink.toIntRange = max;
                max.getMax(seteyeblink);
                seteyeblink.equals = ishasface2;
                if (ishasface2 != null) {
                    ishasface2.getMax(seteyeblink);
                }
                if (algorithmInfo != null) {
                    seteyeblink.toFloatRange = algorithmInfo;
                    algorithmInfo.getMax(seteyeblink);
                    if (i3 != -1) {
                        seteyeblink.isInside = i3 - i8;
                    }
                    seteyeblink.values = i9;
                    seteyeblink.toDoubleRange = i10;
                    seteyeblink.setMin(i7);
                    Mean$Arithmetic2 = length(87, "msg.no.brace.after.body") ? this.invoke.toString : Mean$Arithmetic3;
                    seteyeblink.equals(Mean$Arithmetic2 - i8);
                    if (arrayList == null) {
                        arrayList = new ArrayList();
                    }
                    arrayList.add(seteyeblink);
                    z2 = z3;
                    z = false;
                    r3 = 0;
                    i6 = 125;
                } else {
                    throw new IllegalArgumentException("arg cannot be null");
                }
            }
            i = 126;
        } else {
            i = 126;
            if (min != 126) {
                length(126, "msg.try.no.catchfinally");
            }
            arrayList = null;
        }
        if (setMin(i)) {
            int i11 = this.invoke.values;
            isHasFace isInside3 = isInside();
            Mean$Arithmetic2 = isInside3.create() + isInside3.Mean$Arithmetic();
            int i12 = i11;
            ishasface = isInside3;
            i2 = i12;
        } else {
            i2 = -1;
            ishasface = null;
        }
        setCricleProgressColor setcricleprogresscolor = new setCricleProgressColor(i4, Mean$Arithmetic2 - i4);
        if (isInside2 != null) {
            setcricleprogresscolor.isInside = isInside2;
            isInside2.getMax(setcricleprogresscolor);
            setcricleprogresscolor.length(arrayList);
            setcricleprogresscolor.toFloatRange = ishasface;
            if (ishasface != null) {
                ishasface.getMax(setcricleprogresscolor);
            }
            if (i2 != -1) {
                setcricleprogresscolor.toDoubleRange = i2 - i4;
            }
            setcricleprogresscolor.setMin(i5);
            if (getfaceregion != null) {
                setcricleprogresscolor.getMax(getfaceregion);
            }
            return setcricleprogresscolor;
        }
        throw new IllegalArgumentException("arg cannot be null");
    }

    private setRoundWidth invokeSuspend() throws IOException {
        if (this.valueOf != 50) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        int i = this.invoke.values;
        int i2 = this.invoke.isInside;
        int min = getMin();
        if ((this.invokeSuspend & 65536) != 0) {
            min = 1;
        }
        if (min == 1) {
            getMax("msg.bad.throw.eol", (String) null);
        }
        isHasFace extraCallbackWithResult = extraCallbackWithResult();
        setRoundWidth setroundwidth = new setRoundWidth(i, extraCallbackWithResult.Mean$Arithmetic() + extraCallbackWithResult.create(), extraCallbackWithResult);
        setroundwidth.setMin(i2);
        return setroundwidth;
    }

    private getYaw onNavigationEvent() throws IOException {
        int i;
        CircleFrameLayout.WidgetListener widgetListener;
        AlgorithmInfoPattern algorithmInfoPattern;
        if (this.valueOf != 121) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        int i2 = this.invoke.isInside;
        int i3 = this.invoke.values;
        int i4 = this.invoke.toString;
        int min = getMin();
        if ((this.invokeSuspend & 65536) != 0) {
            min = 1;
        }
        if (min == 39) {
            widgetListener = setMax(false, 39);
            i = widgetListener.Mean$Arithmetic() + widgetListener.create();
        } else {
            i = i4;
            widgetListener = null;
        }
        setDeepLiveness valueOf2 = valueOf();
        if (valueOf2 == null) {
            algorithmInfoPattern = null;
        } else {
            algorithmInfoPattern = valueOf2.isInside.get(0);
        }
        if (algorithmInfoPattern == null && widgetListener == null) {
            List<AlgorithmInfoPattern> list = this.equals;
            if (list != null && list.size() != 0) {
                List<AlgorithmInfoPattern> list2 = this.equals;
                algorithmInfoPattern = list2.get(list2.size() - 1);
            } else if (widgetListener == null) {
                setMax("msg.bad.break", (String) null);
                if (!this.length.toDoubleRange()) {
                    throw new length();
                }
            }
        }
        getYaw getyaw = new getYaw(i3, i - i3);
        getyaw.equals = widgetListener;
        if (widgetListener != null) {
            widgetListener.getMax(getyaw);
        }
        if (algorithmInfoPattern != null) {
            if (algorithmInfoPattern != null) {
                getyaw.toIntRange = algorithmInfoPattern;
                getyaw.setMin(algorithmInfoPattern);
            } else {
                throw new IllegalArgumentException("arg cannot be null");
            }
        }
        getyaw.setMin(i2);
        return getyaw;
    }

    /* JADX WARNING: Removed duplicated region for block: B:29:0x0085  */
    /* JADX WARNING: Removed duplicated region for block: B:35:0x0099  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.setFaceRegion ICustomTabsCallback() throws java.io.IOException {
        /*
            r8 = this;
            int r0 = r8.valueOf
            r1 = 122(0x7a, float:1.71E-43)
            if (r0 == r1) goto L_0x0009
            r8.ITrustedWebActivityCallback()
        L_0x0009:
            r0 = 0
            r8.invokeSuspend = r0
            o.switchOn r1 = r8.invoke
            int r1 = r1.isInside
            o.switchOn r2 = r8.invoke
            int r2 = r2.values
            o.switchOn r3 = r8.invoke
            int r3 = r3.toString
            int r4 = r8.getMin()
            int r5 = r8.invokeSuspend
            r6 = 65536(0x10000, float:9.18355E-41)
            r5 = r5 & r6
            r6 = 1
            if (r5 == 0) goto L_0x0025
            r4 = 1
        L_0x0025:
            r5 = 39
            r7 = 0
            if (r4 != r5) goto L_0x0038
            o.CircleFrameLayout$WidgetListener r0 = r8.setMax((boolean) r0, (int) r5)
            int r3 = r0.Mean$Arithmetic()
            int r4 = r0.create()
            int r3 = r3 + r4
            goto L_0x0039
        L_0x0038:
            r0 = r7
        L_0x0039:
            o.setDeepLiveness r4 = r8.valueOf()
            if (r4 != 0) goto L_0x0060
            if (r0 != 0) goto L_0x0060
            java.util.List<o.setWidgetListener> r4 = r8.IsOverlapping
            if (r4 == 0) goto L_0x005a
            int r4 = r4.size()
            if (r4 != 0) goto L_0x004c
            goto L_0x005a
        L_0x004c:
            java.util.List<o.setWidgetListener> r4 = r8.IsOverlapping
            int r5 = r4.size()
            int r5 = r5 - r6
            java.lang.Object r4 = r4.get(r5)
            o.setWidgetListener r4 = (o.setWidgetListener) r4
            goto L_0x007c
        L_0x005a:
            java.lang.String r4 = "msg.continue.outside"
            r8.getMax((java.lang.String) r4, (java.lang.String) r7)
            goto L_0x007d
        L_0x0060:
            if (r4 == 0) goto L_0x0068
            o.isHasFace r5 = r4.equals
            boolean r5 = r5 instanceof o.setWidgetListener
            if (r5 != 0) goto L_0x0075
        L_0x0068:
            java.lang.String r5 = "msg.continue.nonloop"
            r8.setMax((java.lang.String) r5, (java.lang.String) r7)
            o.SecureQwertyKeyboard$2 r5 = r8.length
            boolean r5 = r5.toDoubleRange()
            if (r5 == 0) goto L_0x00a0
        L_0x0075:
            if (r4 != 0) goto L_0x0078
            goto L_0x007d
        L_0x0078:
            o.isHasFace r4 = r4.equals
            o.setWidgetListener r4 = (o.setWidgetListener) r4
        L_0x007c:
            r7 = r4
        L_0x007d:
            o.setFaceRegion r4 = new o.setFaceRegion
            int r3 = r3 - r2
            r4.<init>(r2, r3)
            if (r7 == 0) goto L_0x0095
            if (r7 == 0) goto L_0x008d
            r4.toIntRange = r7
            r4.setMin(r7)
            goto L_0x0095
        L_0x008d:
            java.lang.IllegalArgumentException r0 = new java.lang.IllegalArgumentException
            java.lang.String r1 = "arg cannot be null"
            r0.<init>(r1)
            throw r0
        L_0x0095:
            r4.isInside = r0
            if (r0 == 0) goto L_0x009c
            r0.getMax(r4)
        L_0x009c:
            r4.setMin((int) r1)
            return r4
        L_0x00a0:
            o.traceTemplate$length r0 = new o.traceTemplate$length
            r0.<init>()
            throw r0
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.ICustomTabsCallback():o.setFaceRegion");
    }

    private setWaveShiftRatio create() throws IOException {
        if (this.valueOf != 124) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        getFaceRegion getfaceregion = this.b;
        this.b = null;
        int i = this.invoke.isInside;
        int i2 = this.invoke.values;
        int i3 = -1;
        int i4 = length(88, "msg.no.paren.with") ? this.invoke.values : -1;
        isHasFace extraCallbackWithResult = extraCallbackWithResult();
        if (length(89, "msg.no.paren.after.with")) {
            i3 = this.invoke.values;
        }
        isHasFace isInside2 = isInside();
        setWaveShiftRatio setwaveshiftratio = new setWaveShiftRatio(i2, (isInside2.Mean$Arithmetic() + isInside2.create()) - i2);
        setwaveshiftratio.getMax(getfaceregion);
        if (extraCallbackWithResult != null) {
            setwaveshiftratio.equals = extraCallbackWithResult;
            extraCallbackWithResult.getMax(setwaveshiftratio);
            if (isInside2 != null) {
                setwaveshiftratio.isInside = isInside2;
                isInside2.getMax(setwaveshiftratio);
                setwaveshiftratio.toFloatRange = i4;
                setwaveshiftratio.toIntRange = i3;
                setwaveshiftratio.setMin(i);
                return setwaveshiftratio;
            }
            throw new IllegalArgumentException("arg cannot be null");
        }
        throw new IllegalArgumentException("arg cannot be null");
    }

    private isHasFace getCause() throws IOException {
        isHasFace ishasface;
        if (this.valueOf != 154) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        int i = this.invoke.isInside;
        int i2 = this.invoke.values;
        if (getMin() == 88) {
            ishasface = setMin(true, i2);
        } else {
            ishasface = setMax(154, i2, true);
        }
        ishasface.setMin(i);
        return ishasface;
    }

    private isHasFace setMin(int i, boolean z) throws IOException {
        int i2;
        isHasFace ishasface;
        isHasFace ishasface2;
        int i3 = 4;
        if (!length()) {
            getMax(i == 4 ? "msg.bad.return" : "msg.bad.yield", (String) null);
        }
        int i4 = 0;
        this.invokeSuspend = 0;
        int i5 = this.invoke.isInside;
        int i6 = this.invoke.values;
        int i7 = this.invoke.toString;
        int min = getMin();
        if ((this.invokeSuspend & 65536) != 0) {
            min = 1;
        }
        if (min == -1 || min == 0 || min == 1 || min == 73 || min == 83 || min == 85 || min == 87 || min == 89) {
            i2 = i7;
            ishasface = null;
        } else {
            ishasface = extraCallbackWithResult();
            i2 = ishasface.Mean$Arithmetic() + ishasface.create();
        }
        int i8 = this.isInside;
        if (i == 4) {
            if (ishasface == null) {
                i3 = 2;
            }
            this.isInside = i8 | i3;
            ishasface2 = new setTextSpan(i6, i2 - i6, ishasface);
            if (length(i8, this.isInside, 6) && this.length.IsOverlapping()) {
                setMin("msg.return.inconsistent", "");
            }
        } else {
            if (!length()) {
                getMax("msg.bad.yield", (String) null);
            }
            this.isInside |= 8;
            ishasface2 = new setBorder(i6, i2 - i6, ishasface);
            if (length()) {
                ((FunctionNode) this.setMin).Mean$Arithmetic = true;
            }
            if (length()) {
                ((FunctionNode) this.setMin).invoke = true;
            }
            if (!z) {
                ishasface2 = new setIntegrity(ishasface2);
            }
        }
        if (length() && length(i8, this.isInside, 12)) {
            CircleFrameLayout.WidgetListener widgetListener = ((FunctionNode) this.setMin).toIntRange;
            if (widgetListener != null) {
                if (widgetListener.equals != null) {
                    i4 = widgetListener.equals.length();
                }
                if (i4 != 0) {
                    setMax("msg.generator.returns", widgetListener.equals);
                }
            }
            setMax("msg.anon.generator.returns", "");
        }
        ishasface2.setMin(i5);
        return ishasface2;
    }

    private isHasFace b() throws IOException {
        if (this.valueOf != 86) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        int i = this.invoke.values;
        setRoundColor setroundcolor = new setRoundColor(i);
        setroundcolor.setMin(this.invoke.isInside);
        setMin(setroundcolor);
        try {
            getMin((isHasFace) setroundcolor);
            length(87, "msg.no.brace.block");
            setroundcolor.equals(this.invoke.toString - i);
            return setroundcolor;
        } finally {
            this.toIntRange = this.toIntRange.asInterface();
        }
    }

    private isHasFace onPostMessage() throws IOException {
        if (this.valueOf != 117) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        if (!this.length.getMin()) {
            getMax("msg.XML.not.available", (String) null);
        }
        if (length()) {
            ((FunctionNode) this.setMin).Mean$Arithmetic = true;
        }
        int i = this.invoke.isInside;
        int i2 = this.invoke.values;
        if (!setMin(39) || !"xml".equals(this.invoke.setMin)) {
            getMax("msg.bad.namespace", (String) null);
        }
        if (!setMin(39) || !BridgeDSL.NAME_SPACE.equals(this.invoke.setMin)) {
            getMax("msg.bad.namespace", (String) null);
        }
        if (!setMin(91)) {
            getMax("msg.bad.namespace", (String) null);
        }
        isHasFace extraCallbackWithResult = extraCallbackWithResult();
        WaveView waveView = new WaveView(i2, (extraCallbackWithResult.Mean$Arithmetic() + extraCallbackWithResult.create()) - i2);
        if (Token.getMin(75)) {
            waveView.setMax(75);
            if (extraCallbackWithResult != null) {
                waveView.equals = extraCallbackWithResult;
                extraCallbackWithResult.getMax(waveView);
                waveView.setMin(i);
                return new setIntegrity(waveView, true);
            }
            throw new IllegalArgumentException("arg cannot be null");
        }
        throw new IllegalArgumentException("Invalid token: 75");
    }

    private void length(CircleFrameLayout circleFrameLayout, setDeepLiveness setdeepliveness) throws IOException {
        if (getMin() != 104) {
            ITrustedWebActivityCallback();
        }
        this.invokeSuspend = 0;
        String str = circleFrameLayout.isInside;
        Map<String, setDeepLiveness> map = this.toFloatRange;
        if (map == null) {
            this.toFloatRange = new HashMap();
        } else {
            setDeepLiveness setdeepliveness2 = map.get(str);
            if (setdeepliveness2 != null) {
                if (this.length.values()) {
                    CircleFrameLayout max = setdeepliveness2.getMax(str);
                    max.b();
                    max.create();
                    getMin("msg.dup.label");
                }
                circleFrameLayout.Mean$Arithmetic();
                circleFrameLayout.create();
                getMin("msg.dup.label");
            }
        }
        if (circleFrameLayout != null) {
            setdeepliveness.isInside.add(circleFrameLayout);
            circleFrameLayout.getMax(setdeepliveness);
            this.toFloatRange.put(str, setdeepliveness);
            return;
        }
        throw new IllegalArgumentException("arg cannot be null");
    }

    /*  JADX ERROR: StackOverflow in pass: MarkFinallyVisitor
        jadx.core.utils.exceptions.JadxOverflowException: 
        	at jadx.core.utils.ErrorsCounter.addError(ErrorsCounter.java:47)
        	at jadx.core.utils.ErrorsCounter.methodError(ErrorsCounter.java:81)
        */
    private o.isHasFace onRelationshipValidationResult() throws java.io.IOException {
        /*
            r8 = this;
            int r0 = r8.valueOf
            r1 = 39
            if (r0 != r1) goto L_0x00d9
            o.switchOn r0 = r8.invoke
            int r0 = r0.values
            int r2 = r8.invokeSuspend
            r3 = 131072(0x20000, float:1.83671E-40)
            r2 = r2 | r3
            r8.invokeSuspend = r2
            o.isHasFace r2 = r8.extraCallbackWithResult()
            int r4 = r2.length()
            r5 = 131(0x83, float:1.84E-43)
            if (r4 == r5) goto L_0x002d
            o.setIntegrity r0 = new o.setIntegrity
            boolean r1 = r8.length()
            r1 = r1 ^ 1
            r0.<init>(r2, r1)
            int r1 = r2.setMax
            r0.setMax = r1
            return r0
        L_0x002d:
            o.setDeepLiveness r4 = new o.setDeepLiveness
            r4.<init>(r0)
            o.CircleFrameLayout r2 = (o.CircleFrameLayout) r2
            r8.length((o.CircleFrameLayout) r2, (o.setDeepLiveness) r4)
            o.switchOn r2 = r8.invoke
            int r2 = r2.isInside
            r4.setMin((int) r2)
        L_0x003e:
            int r2 = r8.getMin()
            r6 = 0
            if (r2 != r1) goto L_0x0069
            int r2 = r8.invokeSuspend
            r2 = r2 | r3
            r8.invokeSuspend = r2
            o.isHasFace r2 = r8.extraCallbackWithResult()
            int r7 = r2.length()
            if (r7 == r5) goto L_0x0063
            o.setIntegrity r1 = new o.setIntegrity
            boolean r3 = r8.length()
            r3 = r3 ^ 1
            r1.<init>(r2, r3)
            r8.setMin((o.isHasFace) r1)
            goto L_0x006a
        L_0x0063:
            o.CircleFrameLayout r2 = (o.CircleFrameLayout) r2
            r8.length((o.CircleFrameLayout) r2, (o.setDeepLiveness) r4)
            goto L_0x003e
        L_0x0069:
            r1 = r6
        L_0x006a:
            r8.getCause = r4     // Catch:{ all -> 0x00bb }
            if (r1 != 0) goto L_0x0072
            o.isHasFace r1 = r8.toFloatRange()     // Catch:{ all -> 0x00bb }
        L_0x0072:
            r8.getCause = r6
            java.util.List<o.CircleFrameLayout> r2 = r4.isInside
            java.util.Iterator r2 = r2.iterator()
        L_0x007a:
            boolean r3 = r2.hasNext()
            if (r3 == 0) goto L_0x008e
            java.lang.Object r3 = r2.next()
            o.CircleFrameLayout r3 = (o.CircleFrameLayout) r3
            java.util.Map<java.lang.String, o.setDeepLiveness> r5 = r8.toFloatRange
            java.lang.String r3 = r3.isInside
            r5.remove(r3)
            goto L_0x007a
        L_0x008e:
            o.isHasFace r2 = r1.onNavigationEvent()
            if (r2 != 0) goto L_0x009f
            int r2 = r1.Mean$Arithmetic()
            int r3 = r1.create()
            int r2 = r2 + r3
            int r2 = r2 - r0
            goto L_0x00a8
        L_0x009f:
            int r0 = r1.Mean$Arithmetic()
            int r2 = r1.create()
            int r2 = r2 + r0
        L_0x00a8:
            r4.equals(r2)
            if (r1 == 0) goto L_0x00b3
            r4.equals = r1
            r1.getMax(r4)
            return r4
        L_0x00b3:
            java.lang.IllegalArgumentException r0 = new java.lang.IllegalArgumentException
            java.lang.String r1 = "arg cannot be null"
            r0.<init>(r1)
            throw r0
        L_0x00bb:
            r0 = move-exception
            r8.getCause = r6
            java.util.List<o.CircleFrameLayout> r1 = r4.isInside
            java.util.Iterator r1 = r1.iterator()
        L_0x00c4:
            boolean r2 = r1.hasNext()
            if (r2 == 0) goto L_0x00d8
            java.lang.Object r2 = r1.next()
            o.CircleFrameLayout r2 = (o.CircleFrameLayout) r2
            java.util.Map<java.lang.String, o.setDeepLiveness> r3 = r8.toFloatRange
            java.lang.String r2 = r2.isInside
            r3.remove(r2)
            goto L_0x00c4
        L_0x00d8:
            throw r0
        L_0x00d9:
            java.lang.RuntimeException r0 = r8.ITrustedWebActivityCallback()
            goto L_0x00df
        L_0x00de:
            throw r0
        L_0x00df:
            goto L_0x00de
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.onRelationshipValidationResult():o.isHasFace");
    }

    private getCricleProgressColor setMax(int i, int i2, boolean z) throws IOException {
        int i3;
        CircleFrameLayout.WidgetListener widgetListener;
        isHasFace ishasface;
        isHasFace ishasface2;
        getCricleProgressColor getcricleprogresscolor = new getCricleProgressColor(i2);
        getcricleprogresscolor.setMax(i);
        getcricleprogresscolor.setMin(this.invoke.isInside);
        getFaceRegion getfaceregion = this.b;
        this.b = null;
        if (getfaceregion != null) {
            getcricleprogresscolor.getMax(getfaceregion);
        }
        do {
            int min = getMin();
            int i4 = this.invoke.values;
            int i5 = this.invoke.toString;
            if (min == 84 || min == 86) {
                ishasface = mayLaunchUrl();
                int Mean$Arithmetic2 = ishasface.Mean$Arithmetic() + ishasface.create();
                if (!(ishasface instanceof getGaussian)) {
                    setMax("msg.bad.assign.left", (String) null);
                    if (!this.length.toDoubleRange()) {
                        throw new length();
                    }
                }
                getMax(ishasface);
                i3 = Mean$Arithmetic2;
                widgetListener = null;
            } else {
                length(39, "msg.bad.var");
                CircleFrameLayout.WidgetListener max = setMax(false, 39);
                max.setMin(this.invoke.isInside);
                if (this.setMax) {
                    String str = this.invoke.setMin;
                    if ("eval".equals(str) || "arguments".equals(this.invoke.setMin)) {
                        getMax("msg.bad.id.strict", str);
                    }
                }
                length(i, this.invoke.setMin, this.onNavigationEvent);
                i3 = i5;
                widgetListener = max;
                ishasface = null;
            }
            int i6 = this.invoke.isInside;
            getFaceRegion getfaceregion2 = this.b;
            this.b = null;
            if (setMin(91)) {
                isHasFace onMessageChannelReady2 = onMessageChannelReady();
                ishasface2 = onMessageChannelReady2;
                i3 = onMessageChannelReady2.Mean$Arithmetic() + onMessageChannelReady2.create();
            } else {
                ishasface2 = null;
            }
            getWaterLevelRatio getwaterlevelratio = new getWaterLevelRatio(i4, i3 - i4);
            if (ishasface != null) {
                if (ishasface2 == null && !this.onNavigationEvent) {
                    getMax("msg.destruct.assign.no.init", (String) null);
                }
                if (ishasface != null) {
                    getwaterlevelratio.toFloatRange = ishasface;
                    ishasface.getMax(getwaterlevelratio);
                } else {
                    throw new IllegalArgumentException("invalid target arg");
                }
            } else if (widgetListener != null) {
                getwaterlevelratio.toFloatRange = widgetListener;
                widgetListener.getMax(getwaterlevelratio);
            } else {
                throw new IllegalArgumentException("invalid target arg");
            }
            getwaterlevelratio.equals = ishasface2;
            if (ishasface2 != null) {
                ishasface2.getMax(getwaterlevelratio);
            }
            getwaterlevelratio.setMax(i);
            getwaterlevelratio.getMax(getfaceregion2);
            getwaterlevelratio.setMin(i6);
            getcricleprogresscolor.isInside.add(getwaterlevelratio);
            getwaterlevelratio.getMax(getcricleprogresscolor);
        } while (setMin(90));
        getcricleprogresscolor.equals(i3 - i2);
        getcricleprogresscolor.equals = z;
        return getcricleprogresscolor;
    }

    private isHasFace setMin(boolean z, int i) throws IOException {
        initViews initviews = new initViews(i);
        initviews.setMin(this.invoke.isInside);
        if (length(88, "msg.no.paren.after.let")) {
            initviews.toIntRange = this.invoke.values - i;
        }
        setMin((setRoundColor) initviews);
        try {
            getCricleProgressColor max = setMax(154, this.invoke.values, z);
            initviews.toFloatRange = max;
            max.getMax(initviews);
            if (length(89, "msg.no.paren.let")) {
                initviews.isInside = this.invoke.values - i;
            }
            boolean z2 = false;
            if (!z || getMin() != 86) {
                isHasFace extraCallbackWithResult = extraCallbackWithResult();
                initviews.equals((extraCallbackWithResult.Mean$Arithmetic() + extraCallbackWithResult.create()) - i);
                initviews.equals = extraCallbackWithResult;
                if (extraCallbackWithResult != null) {
                    extraCallbackWithResult.getMax(initviews);
                }
                if (z) {
                    if (!length()) {
                        z2 = true;
                    }
                    setIntegrity setintegrity = new setIntegrity(initviews, z2);
                    setintegrity.setMin(initviews.equals());
                    this.toIntRange = this.toIntRange.asInterface();
                    return setintegrity;
                }
            } else {
                this.invokeSuspend = 0;
                int i2 = this.invoke.values;
                isHasFace min = getMin((isHasFace) null);
                length(87, "msg.no.curly.let");
                min.equals(this.invoke.toString - i2);
                initviews.equals(this.invoke.toString - i);
                initviews.equals = min;
                if (min != null) {
                    min.getMax(initviews);
                }
                initviews.setMax(154);
            }
            return initviews;
        } finally {
            this.toIntRange = this.toIntRange.asInterface();
        }
    }

    /* access modifiers changed from: package-private */
    public final void length(int i, String str, boolean z) {
        getRoundWidth getroundwidth;
        int i2;
        if (str == null) {
            if (!this.length.values()) {
                ITrustedWebActivityCallback();
            } else {
                return;
            }
        }
        setRoundColor min = this.toIntRange.setMin(str);
        if (min != null) {
            getroundwidth = min.getMax(str);
        } else {
            getroundwidth = null;
        }
        if (getroundwidth != null) {
            i2 = getroundwidth.setMin;
        } else {
            i2 = -1;
        }
        String str2 = "msg.var.redecl";
        if (getroundwidth != null && (i2 == 155 || i == 155 || (min == this.toIntRange && i2 == 154))) {
            if (i2 == 155) {
                str2 = "msg.const.redecl";
            } else if (i2 == 154) {
                str2 = "msg.let.redecl";
            } else if (i2 != 123) {
                str2 = i2 == 110 ? "msg.fn.redecl" : "msg.parm.redecl";
            }
            setMax(str2, str);
        } else if (i != 88) {
            if (!(i == 110 || i == 123)) {
                if (i != 154) {
                    if (i != 155) {
                        throw ITrustedWebActivityCallback();
                    }
                } else if (z || (this.toIntRange.length() != 113 && !(this.toIntRange instanceof setWidgetListener))) {
                    this.toIntRange.getMax(new getRoundWidth(i, str));
                    return;
                } else {
                    setMax("msg.let.decl.not.in.block", (String) null);
                    return;
                }
            }
            if (getroundwidth == null) {
                this.setMin.getMax(new getRoundWidth(i, str));
            } else if (i2 == 123) {
                if (this.length.IsOverlapping()) {
                    setMin(str2, str);
                }
            } else if (i2 == 88 && this.length.IsOverlapping()) {
                setMin("msg.var.hides.arg", str);
            }
        } else {
            if (getroundwidth != null) {
                setMin("msg.dup.parms", str);
            }
            this.setMin.getMax(new getRoundWidth(i, str));
        }
    }

    private isHasFace extraCallbackWithResult() throws IOException {
        isHasFace onMessageChannelReady2 = onMessageChannelReady();
        onMessageChannelReady2.Mean$Arithmetic();
        while (setMin(90)) {
            int i = this.invoke.values;
            if (this.length.IsOverlapping() && !onMessageChannelReady2.toDoubleRange()) {
                onMessageChannelReady2.Mean$Arithmetic();
                onMessageChannelReady2.create();
                if (this.length.IsOverlapping()) {
                    setMin("msg.no.side.effects", "");
                }
            }
            if (getMin() == 73) {
                getMax("msg.yield.parenthesized", (String) null);
            }
            onMessageChannelReady2 = new getRightEyeBlinkRatio(90, onMessageChannelReady2, onMessageChannelReady(), i);
        }
        return onMessageChannelReady2;
    }

    private isHasFace onMessageChannelReady() throws IOException {
        int min = getMin();
        boolean z = true;
        if (min == 73) {
            return setMin(min, true);
        }
        isHasFace extraCallback2 = extraCallback();
        int min2 = getMin();
        if ((this.invokeSuspend & 65536) != 0) {
            min2 = 1;
        }
        if (min2 == 1) {
            min2 = getMin();
        } else {
            z = false;
        }
        if (91 <= min2 && min2 <= 102) {
            if (this.ICustomTabsCallback) {
                getMax("msg.destruct.default.vals", (String) null);
            }
            this.invokeSuspend = 0;
            getFaceRegion getfaceregion = this.b;
            this.b = null;
            getMax(extraCallback2);
            getFaceId getfaceid = new getFaceId(min2, extraCallback2, onMessageChannelReady(), this.invoke.values);
            if (getfaceregion != null) {
                getfaceid.getMax(getfaceregion);
            }
            return getfaceid;
        } else if (min2 == 83) {
            getFaceRegion getfaceregion2 = this.b;
            if (getfaceregion2 == null) {
                return extraCallback2;
            }
            this.b = null;
            extraCallback2.getMax(getfaceregion2);
            return extraCallback2;
        } else if (z || min2 != 165) {
            return extraCallback2;
        } else {
            this.invokeSuspend = 0;
            return setMax(extraCallback2);
        }
    }

    /* JADX INFO: finally extract failed */
    private isHasFace extraCallback() throws IOException {
        isHasFace asInterface = asInterface();
        if (!setMin(103)) {
            return asInterface;
        }
        int i = this.invoke.isInside;
        int i2 = this.invoke.values;
        int i3 = -1;
        boolean z = this.onNavigationEvent;
        this.onNavigationEvent = false;
        try {
            isHasFace onMessageChannelReady2 = onMessageChannelReady();
            this.onNavigationEvent = z;
            if (length(104, "msg.no.colon.cond")) {
                i3 = this.invoke.values;
            }
            isHasFace onMessageChannelReady3 = onMessageChannelReady();
            int Mean$Arithmetic2 = asInterface.Mean$Arithmetic();
            isEyeBlink iseyeblink = new isEyeBlink(Mean$Arithmetic2, (onMessageChannelReady3.Mean$Arithmetic() + onMessageChannelReady3.create()) - Mean$Arithmetic2);
            iseyeblink.setMin(i);
            if (asInterface != null) {
                iseyeblink.toFloatRange = asInterface;
                asInterface.getMax(iseyeblink);
                if (onMessageChannelReady2 != null) {
                    iseyeblink.isInside = onMessageChannelReady2;
                    onMessageChannelReady2.getMax(iseyeblink);
                    if (onMessageChannelReady3 != null) {
                        iseyeblink.toIntRange = onMessageChannelReady3;
                        onMessageChannelReady3.getMax(iseyeblink);
                        iseyeblink.equals = i2 - Mean$Arithmetic2;
                        iseyeblink.toDoubleRange = i3 - Mean$Arithmetic2;
                        return iseyeblink;
                    }
                    throw new IllegalArgumentException("arg cannot be null");
                }
                throw new IllegalArgumentException("arg cannot be null");
            }
            throw new IllegalArgumentException("arg cannot be null");
        } catch (Throwable th) {
            this.onNavigationEvent = z;
            throw th;
        }
    }

    private isHasFace asInterface() throws IOException {
        isHasFace ICustomTabsCallback$Default = ICustomTabsCallback$Default();
        if (!setMin(105)) {
            return ICustomTabsCallback$Default;
        }
        return new getRightEyeBlinkRatio(105, ICustomTabsCallback$Default, asInterface(), this.invoke.values);
    }

    private isHasFace ICustomTabsCallback$Default() throws IOException {
        isHasFace ICustomTabsCallback$Stub = ICustomTabsCallback$Stub();
        if (!setMin(106)) {
            return ICustomTabsCallback$Stub;
        }
        return new getRightEyeBlinkRatio(106, ICustomTabsCallback$Stub, ICustomTabsCallback$Default(), this.invoke.values);
    }

    private isHasFace ICustomTabsCallback$Stub() throws IOException {
        isHasFace asBinder = asBinder();
        while (setMin(9)) {
            asBinder = new getRightEyeBlinkRatio(9, asBinder, asBinder(), this.invoke.values);
        }
        return asBinder;
    }

    private isHasFace asBinder() throws IOException {
        isHasFace onTransact = onTransact();
        while (setMin(10)) {
            onTransact = new getRightEyeBlinkRatio(10, onTransact, onTransact(), this.invoke.values);
        }
        return onTransact;
    }

    private isHasFace onTransact() throws IOException {
        isHasFace defaultImpl = setDefaultImpl();
        while (setMin(11)) {
            defaultImpl = new getRightEyeBlinkRatio(11, defaultImpl, setDefaultImpl(), this.invoke.values);
        }
        return defaultImpl;
    }

    private isHasFace setDefaultImpl() throws IOException {
        isHasFace defaultImpl = getDefaultImpl();
        while (true) {
            int min = getMin();
            int i = this.invoke.values;
            if (min != 12 && min != 13 && min != 46 && min != 47) {
                return defaultImpl;
            }
            this.invokeSuspend = 0;
            if (this.length.setMin == 120) {
                if (min == 12) {
                    min = 46;
                } else if (min == 13) {
                    min = 47;
                }
            }
            defaultImpl = new getRightEyeBlinkRatio(min, defaultImpl, getDefaultImpl(), i);
        }
    }

    private isHasFace getDefaultImpl() throws IOException {
        isHasFace interfaceDescriptor = getInterfaceDescriptor();
        while (true) {
            int min = getMin();
            int i = this.invoke.values;
            if (min != 52) {
                if (min != 53) {
                    switch (min) {
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                            break;
                    }
                } else {
                    continue;
                }
            } else if (!this.onNavigationEvent) {
            }
            this.invokeSuspend = 0;
            interfaceDescriptor = new getRightEyeBlinkRatio(min, interfaceDescriptor, getInterfaceDescriptor(), i);
        }
        return interfaceDescriptor;
    }

    private isHasFace getInterfaceDescriptor() throws IOException {
        isHasFace ICustomTabsService = ICustomTabsService();
        while (true) {
            int min = getMin();
            int i = this.invoke.values;
            switch (min) {
                case 18:
                case 19:
                case 20:
                    this.invokeSuspend = 0;
                    ICustomTabsService = new getRightEyeBlinkRatio(min, ICustomTabsService, ICustomTabsService(), i);
                default:
                    return ICustomTabsService;
            }
        }
    }

    private isHasFace ICustomTabsService() throws IOException {
        isHasFace ICustomTabsCallback$Stub$Proxy = ICustomTabsCallback$Stub$Proxy();
        while (true) {
            int min = getMin();
            int i = this.invoke.values;
            if (min != 21 && min != 22) {
                return ICustomTabsCallback$Stub$Proxy;
            }
            this.invokeSuspend = 0;
            ICustomTabsCallback$Stub$Proxy = new getRightEyeBlinkRatio(min, ICustomTabsCallback$Stub$Proxy, ICustomTabsCallback$Stub$Proxy(), i);
        }
    }

    private isHasFace ICustomTabsCallback$Stub$Proxy() throws IOException {
        isHasFace extraCommand = extraCommand();
        while (true) {
            int min = getMin();
            int i = this.invoke.values;
            switch (min) {
                case 23:
                case 24:
                case 25:
                    this.invokeSuspend = 0;
                    extraCommand = new getRightEyeBlinkRatio(min, extraCommand, extraCommand(), i);
                default:
                    return extraCommand;
            }
        }
    }

    private isHasFace extraCommand() throws IOException {
        int min = getMin();
        int i = this.invoke.isInside;
        if (min != -1) {
            if (min != 14) {
                if (min != 127) {
                    if (min == 21) {
                        this.invokeSuspend = 0;
                        WaveView waveView = new WaveView(28, this.invoke.values, extraCommand());
                        waveView.setMin(i);
                        return waveView;
                    } else if (min == 22) {
                        this.invokeSuspend = 0;
                        WaveView waveView2 = new WaveView(29, this.invoke.values, extraCommand());
                        waveView2.setMin(i);
                        return waveView2;
                    } else if (!(min == 26 || min == 27)) {
                        if (min == 31) {
                            this.invokeSuspend = 0;
                            WaveView waveView3 = new WaveView(min, this.invoke.values, extraCommand());
                            waveView3.setMin(i);
                            return waveView3;
                        } else if (min != 32) {
                            if (min == 107 || min == 108) {
                                this.invokeSuspend = 0;
                                WaveView waveView4 = new WaveView(min, this.invoke.values, getMax(true));
                                waveView4.setMin(i);
                                getMin(waveView4);
                                return waveView4;
                            }
                        }
                    }
                }
                this.invokeSuspend = 0;
                WaveView waveView5 = new WaveView(min, this.invoke.values, extraCommand());
                waveView5.setMin(i);
                return waveView5;
            } else if (this.length.getMin()) {
                this.invokeSuspend = 0;
                return setMax(true, newSessionWithExtras());
            }
            isHasFace max = getMax(true);
            int min2 = getMin();
            if ((this.invokeSuspend & 65536) != 0) {
                min2 = 1;
            }
            if (min2 != 107 && min2 != 108) {
                return max;
            }
            this.invokeSuspend = 0;
            WaveView waveView6 = new WaveView(min2, this.invoke.values, max, true);
            waveView6.setMin(i);
            getMin(waveView6);
            return waveView6;
        }
        this.invokeSuspend = 0;
        return IPostMessageService();
    }

    private isHasFace newSessionWithExtras() throws IOException {
        isHasFace ishasface;
        if (this.valueOf != 14) {
            ITrustedWebActivityCallback();
        }
        int i = this.invoke.values;
        int equals2 = this.invoke.equals();
        if (equals2 == 146 || equals2 == 149) {
            getWaveLengthRatio getwavelengthratio = new getWaveLengthRatio(i);
            getwavelengthratio.setMin(this.invoke.isInside);
            while (equals2 == 146) {
                createShader createshader = new createShader(this.invoke.values, this.invoke.setMin);
                getwavelengthratio.isInside.add(createshader);
                createshader.getMax(getwavelengthratio);
                length(86, "msg.syntax");
                int i2 = this.invoke.values;
                if (getMin() == 87) {
                    ishasface = new getPitch(i2, this.invoke.toString - i2);
                } else {
                    ishasface = extraCallbackWithResult();
                }
                length(87, "msg.syntax");
                setAmplitudeRatio setamplituderatio = new setAmplitudeRatio(i2, ishasface);
                setamplituderatio.equals = this.invoke.isInside();
                setamplituderatio.equals(this.invoke.toString - i2);
                getwavelengthratio.isInside.add(setamplituderatio);
                setamplituderatio.getMax(getwavelengthratio);
                equals2 = this.invoke.toFloatRange();
            }
            if (equals2 != 149) {
                getMax("msg.syntax", (String) null);
                return IPostMessageService();
            }
            createShader createshader2 = new createShader(this.invoke.values, this.invoke.setMin);
            getwavelengthratio.isInside.add(createshader2);
            createshader2.getMax(getwavelengthratio);
            return getwavelengthratio;
        }
        getMax("msg.syntax", (String) null);
        return IPostMessageService();
    }

    /* JADX INFO: finally extract failed */
    private List<isHasFace> warmup() throws IOException {
        if (setMin(89)) {
            return null;
        }
        ArrayList arrayList = new ArrayList();
        boolean z = this.onNavigationEvent;
        this.onNavigationEvent = false;
        do {
            try {
                if (getMin() == 73) {
                    getMax("msg.yield.parenthesized", (String) null);
                }
                isHasFace onMessageChannelReady2 = onMessageChannelReady();
                if (getMin() == 120) {
                    try {
                        arrayList.add(getMax(onMessageChannelReady2, 0, true));
                    } catch (IOException unused) {
                    }
                } else {
                    arrayList.add(onMessageChannelReady2);
                }
            } catch (Throwable th) {
                this.onNavigationEvent = z;
                throw th;
            }
        } while (setMin(90));
        this.onNavigationEvent = z;
        length(89, "msg.no.paren.arg");
        return arrayList;
    }

    private isHasFace getMax(boolean z) throws IOException {
        isHasFace ishasface;
        int min = getMin();
        int i = this.invoke.isInside;
        if (min != 30) {
            ishasface = requestPostMessageChannel();
        } else {
            this.invokeSuspend = 0;
            int i2 = this.invoke.values;
            PromptTextView promptTextView = new PromptTextView(i2);
            isHasFace max = getMax(false);
            int Mean$Arithmetic2 = max.Mean$Arithmetic() + max.create();
            promptTextView.setMin(max);
            if (setMin(88)) {
                int i3 = this.invoke.values;
                List<isHasFace> warmup = warmup();
                if (warmup != null && warmup.size() > 65536) {
                    getMax("msg.too.many.constructor.args", (String) null);
                }
                int i4 = this.invoke.values;
                int i5 = this.invoke.toString;
                if (warmup != null) {
                    promptTextView.setMin(warmup);
                }
                promptTextView.getMax(i3 - i2, i4 - i2);
                Mean$Arithmetic2 = i5;
            }
            if (setMin(86)) {
                LoadingProgressDialog receiveFile = receiveFile();
                Mean$Arithmetic2 = receiveFile.Mean$Arithmetic() + receiveFile.create();
                promptTextView.toDoubleRange = receiveFile;
                receiveFile.getMax(promptTextView);
            }
            promptTextView.equals(Mean$Arithmetic2 - i2);
            ishasface = promptTextView;
        }
        ishasface.setMin(i);
        return setMax(z, ishasface);
    }

    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r6v0, resolved type: o.setGaussian} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r6v9, resolved type: o.setGaussian} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r6v10, resolved type: o.setGaussian} */
    /* JADX WARNING: Multi-variable type inference failed */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.isHasFace setMax(boolean r9, o.isHasFace r10) throws java.io.IOException {
        /*
            r8 = this;
            if (r10 != 0) goto L_0x0005
            r8.ITrustedWebActivityCallback()
        L_0x0005:
            int r0 = r10.Mean$Arithmetic()
        L_0x0009:
            int r1 = r8.getMin()
            r2 = 84
            r3 = -1
            r4 = 0
            if (r1 == r2) goto L_0x00d5
            r2 = 88
            r5 = 0
            if (r1 == r2) goto L_0x008d
            r2 = 109(0x6d, float:1.53E-43)
            if (r1 == r2) goto L_0x0080
            r2 = 144(0x90, float:2.02E-43)
            if (r1 == r2) goto L_0x0080
            r2 = 147(0x93, float:2.06E-43)
            if (r1 == r2) goto L_0x0026
            goto L_0x00d4
        L_0x0026:
            r8.invokeSuspend = r4
            o.switchOn r1 = r8.invoke
            int r1 = r1.values
            o.switchOn r2 = r8.invoke
            int r2 = r2.isInside
            o.SecureQwertyKeyboard$2 r4 = r8.length
            boolean r4 = r4.getMin()
            if (r4 != 0) goto L_0x003d
            java.lang.String r4 = "msg.XML.not.available"
            r8.getMax((java.lang.String) r4, (java.lang.String) r5)
        L_0x003d:
            boolean r4 = r8.length()
            if (r4 == 0) goto L_0x004a
            o.getCricleColor r4 = r8.setMin
            org.mozilla.javascript.ast.FunctionNode r4 = (org.mozilla.javascript.ast.FunctionNode) r4
            r5 = 1
            r4.Mean$Arithmetic = r5
        L_0x004a:
            o.isHasFace r4 = r8.extraCallbackWithResult()
            int r5 = r4.Mean$Arithmetic()
            int r6 = r4.create()
            int r5 = r5 + r6
            r6 = 89
            java.lang.String r7 = "msg.no.paren"
            boolean r6 = r8.length((int) r6, (java.lang.String) r7)
            if (r6 == 0) goto L_0x0069
            o.switchOn r3 = r8.invoke
            int r3 = r3.values
            o.switchOn r5 = r8.invoke
            int r5 = r5.toString
        L_0x0069:
            o.setWaterLevelRatio r6 = new o.setWaterLevelRatio
            int r5 = r5 - r0
            r6.<init>(r0, r5)
            r6.setMax(r10)
            r6.getMin(r4)
            r6.toIntRange(r1)
            int r3 = r3 - r0
            r6.isInside = r3
            r6.setMin((int) r2)
            goto L_0x011b
        L_0x0080:
            o.switchOn r2 = r8.invoke
            int r2 = r2.isInside
            o.isHasFace r10 = r8.getMax((int) r1, (o.isHasFace) r10)
            r10.setMin((int) r2)
            goto L_0x0009
        L_0x008d:
            if (r9 == 0) goto L_0x00d4
            o.switchOn r1 = r8.invoke
            int r1 = r1.isInside
            r8.invokeSuspend = r4
            r8.length((o.isHasFace) r10)
            o.getIntegrity r2 = new o.getIntegrity
            r2.<init>(r0)
            r2.setMin((o.isHasFace) r10)
            r2.setMin((int) r1)
            o.switchOn r10 = r8.invoke
            int r10 = r10.values
            int r10 = r10 - r0
            r2.toIntRange(r10)
            java.util.List r10 = r8.warmup()
            if (r10 == 0) goto L_0x00be
            int r1 = r10.size()
            r3 = 65536(0x10000, float:9.18355E-41)
            if (r1 <= r3) goto L_0x00be
            java.lang.String r1 = "msg.too.many.function.args"
            r8.getMax((java.lang.String) r1, (java.lang.String) r5)
        L_0x00be:
            r2.setMin((java.util.List<o.isHasFace>) r10)
            o.switchOn r10 = r8.invoke
            int r10 = r10.values
            int r10 = r10 - r0
            r2.toString(r10)
            o.switchOn r10 = r8.invoke
            int r10 = r10.toString
            int r10 = r10 - r0
            r2.equals(r10)
            r10 = r2
            goto L_0x0009
        L_0x00d4:
            return r10
        L_0x00d5:
            r8.invokeSuspend = r4
            o.switchOn r1 = r8.invoke
            int r1 = r1.values
            o.switchOn r2 = r8.invoke
            int r2 = r2.isInside
            o.isHasFace r4 = r8.extraCallbackWithResult()
            int r5 = r4.Mean$Arithmetic()
            int r6 = r4.create()
            int r5 = r5 + r6
            r6 = 85
            java.lang.String r7 = "msg.no.bracket.index"
            boolean r6 = r8.length((int) r6, (java.lang.String) r7)
            if (r6 == 0) goto L_0x00fe
            o.switchOn r3 = r8.invoke
            int r3 = r3.values
            o.switchOn r5 = r8.invoke
            int r5 = r5.toString
        L_0x00fe:
            o.setGaussian r6 = new o.setGaussian
            int r5 = r5 - r0
            r6.<init>(r0, r5)
            java.lang.String r5 = "arg cannot be null"
            if (r10 == 0) goto L_0x0124
            r6.equals = r10
            r10.getMax(r6)
            if (r4 == 0) goto L_0x011e
            r6.toIntRange = r4
            r4.getMax(r6)
            r6.isInside = r1
            r6.toFloatRange = r3
            r6.setMin((int) r2)
        L_0x011b:
            r10 = r6
            goto L_0x0009
        L_0x011e:
            java.lang.IllegalArgumentException r9 = new java.lang.IllegalArgumentException
            r9.<init>(r5)
            throw r9
        L_0x0124:
            java.lang.IllegalArgumentException r9 = new java.lang.IllegalArgumentException
            r9.<init>(r5)
            goto L_0x012b
        L_0x012a:
            throw r9
        L_0x012b:
            goto L_0x012a
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.setMax(boolean, o.isHasFace):o.isHasFace");
    }

    private isHasFace getMax(int i, isHasFace ishasface) throws IOException {
        int i2;
        isHasFace ishasface2;
        String max;
        if (ishasface == null) {
            ITrustedWebActivityCallback();
        }
        int i3 = this.invoke.isInside;
        int i4 = this.invoke.values;
        this.invokeSuspend = 0;
        if (i == 144) {
            if (!this.length.getMin()) {
                getMax("msg.XML.not.available", (String) null);
            }
            i2 = 4;
        } else {
            i2 = 0;
        }
        if (!this.length.getMin()) {
            int min = getMin();
            this.invokeSuspend = 0;
            if (min != 39 && (!this.length.getMax() || !switchOn.setMin(this.invoke.setMin, this.length.setMin, this.setMax))) {
                getMax("msg.no.name.after.dot", (String) null);
            }
            resetAnimation resetanimation = new resetAnimation(ishasface, setMax(true, 33), i4);
            resetanimation.setMin(i3);
            return resetanimation;
        }
        int min2 = getMin();
        this.invokeSuspend = 0;
        if (min2 == 23) {
            int i5 = this.invoke.values;
            int i6 = this.invoke.isInside;
            this.onRelationshipValidationResult = i5;
            this.extraCallback = "*";
            this.onMessageChannelReady = i6;
            ishasface2 = getMin(-1, i2);
        } else if (min2 == 39) {
            ishasface2 = getMin(-1, i2);
        } else if (min2 == 50) {
            int i7 = this.invoke.values;
            int i8 = this.invoke.isInside;
            this.onRelationshipValidationResult = i7;
            this.extraCallback = "throw";
            this.onMessageChannelReady = i8;
            ishasface2 = getMin(-1, i2);
        } else if (min2 == 128) {
            String str = this.invoke.setMin;
            int i9 = this.invoke.values;
            int i10 = this.invoke.isInside;
            this.onRelationshipValidationResult = i9;
            this.extraCallback = str;
            this.onMessageChannelReady = i10;
            ishasface2 = getMin(-1, i2);
        } else if (min2 == 148) {
            ishasface2 = newSession();
        } else if (!this.length.getMax() || (max = Token.setMax(min2)) == null) {
            getMax("msg.no.name.after.dot", (String) null);
            return IPostMessageService();
        } else {
            int i11 = this.invoke.values;
            int i12 = this.invoke.isInside;
            this.onRelationshipValidationResult = i11;
            this.extraCallback = max;
            this.onMessageChannelReady = i12;
            ishasface2 = getMin(-1, i2);
        }
        boolean z = ishasface2 instanceof setWaveColor;
        getRightEyeBlinkRatio isshowwave = z ? new isShowWave() : new resetAnimation();
        if (z && i == 109) {
            isshowwave.setMax(109);
        }
        int Mean$Arithmetic2 = ishasface.Mean$Arithmetic();
        isshowwave.IsOverlapping(Mean$Arithmetic2);
        isshowwave.equals((ishasface2.Mean$Arithmetic() + ishasface2.create()) - Mean$Arithmetic2);
        isshowwave.toIntRange(i4 - Mean$Arithmetic2);
        isshowwave.setMin(ishasface.equals());
        isshowwave.setMax(ishasface);
        isshowwave.getMin(ishasface2);
        return isshowwave;
    }

    private isHasFace getMin(int i, int i2) throws IOException {
        CircleFrameLayout.WidgetListener widgetListener;
        int i3;
        int i4 = i != -1 ? i : this.invoke.values;
        int i5 = this.invoke.isInside;
        CircleFrameLayout.WidgetListener max = setMax(true, this.valueOf);
        if (setMin(145)) {
            i3 = this.invoke.values;
            int min = getMin();
            this.invokeSuspend = 0;
            if (min == 23) {
                int i6 = this.invoke.values;
                int i7 = this.invoke.isInside;
                this.onRelationshipValidationResult = i6;
                this.extraCallback = "*";
                this.onMessageChannelReady = i7;
                widgetListener = setMax(false, -1);
            } else if (min == 39) {
                widgetListener = setMax(false, 39);
            } else if (min == 84) {
                return getMax(i, max, i3);
            } else {
                getMax("msg.no.name.after.coloncolon", (String) null);
                return IPostMessageService();
            }
        } else {
            i3 = -1;
            widgetListener = max;
            max = null;
        }
        if (max == null && i2 == 0 && i == -1) {
            return widgetListener;
        }
        setShowWave setshowwave = new setShowWave(i4, (widgetListener.Mean$Arithmetic() + widgetListener.create()) - i4);
        setshowwave.toIntRange(i);
        setshowwave.getMax(max);
        setshowwave.hashCode(i3);
        setshowwave.toFloatRange = widgetListener;
        widgetListener.getMax(setshowwave);
        setshowwave.setMin(i5);
        return setshowwave;
    }

    private getAmplitudeRatio getMax(int i, CircleFrameLayout.WidgetListener widgetListener, int i2) throws IOException {
        int i3 = this.invoke.values;
        int i4 = -1;
        int i5 = i != -1 ? i : i3;
        isHasFace extraCallbackWithResult = extraCallbackWithResult();
        int Mean$Arithmetic2 = extraCallbackWithResult.Mean$Arithmetic() + extraCallbackWithResult.create();
        if (length(85, "msg.no.bracket.index")) {
            i4 = this.invoke.values;
            Mean$Arithmetic2 = this.invoke.toString;
        }
        getAmplitudeRatio getamplituderatio = new getAmplitudeRatio(i5, Mean$Arithmetic2 - i5);
        getamplituderatio.getMax(widgetListener);
        getamplituderatio.hashCode(i2);
        getamplituderatio.toIntRange(i);
        if (extraCallbackWithResult != null) {
            getamplituderatio.equals = extraCallbackWithResult;
            extraCallbackWithResult.getMax(getamplituderatio);
            getamplituderatio.toFloatRange = i3;
            getamplituderatio.isInside = i4;
            return getamplituderatio;
        }
        throw new IllegalArgumentException("arg cannot be null");
    }

    /* JADX INFO: finally extract failed */
    private isHasFace mayLaunchUrl() throws IOException, length {
        try {
            this.ICustomTabsCallback = true;
            isHasFace requestPostMessageChannel = requestPostMessageChannel();
            this.ICustomTabsCallback = false;
            return requestPostMessageChannel;
        } catch (Throwable th) {
            this.ICustomTabsCallback = false;
            throw th;
        }
    }

    private isHasFace postMessage() throws IOException {
        boolean z = this.onNavigationEvent;
        this.onNavigationEvent = false;
        try {
            getFaceRegion getfaceregion = this.b;
            this.b = null;
            int i = this.invoke.isInside;
            int i2 = this.invoke.values;
            isHasFace getpitch = getMin() == 89 ? new getPitch(i2) : extraCallbackWithResult();
            if (getMin() == 120) {
                return getMax(getpitch, i2, false);
            }
            PromptTextView.AnonymousClass1 r1 = new PromptTextView.AnonymousClass1(getpitch);
            if (getfaceregion == null) {
                getfaceregion = this.b;
                this.b = null;
            }
            if (getfaceregion != null) {
                r1.getMax(getfaceregion);
            }
            length(89, "msg.no.paren");
            if (getpitch.length() != 129 || getMin() == 165) {
                r1.equals(this.invoke.toString - r1.Mean$Arithmetic());
                r1.setMin(i);
                this.onNavigationEvent = z;
                return r1;
            }
            getMax("msg.syntax", (String) null);
            getLeftEyeBlinkRatio IPostMessageService = IPostMessageService();
            this.onNavigationEvent = z;
            return IPostMessageService;
        } finally {
            this.onNavigationEvent = z;
        }
    }

    private isHasFace length(int i) throws IOException {
        String str = this.invoke.setMin;
        int i2 = this.invoke.values;
        int i3 = this.invoke.isInside;
        if ((i & 131072) == 0 || getMin() != 104) {
            this.onRelationshipValidationResult = i2;
            this.extraCallback = str;
            this.onMessageChannelReady = i3;
            if (this.length.getMin()) {
                return getMin(-1, 0);
            }
            return setMax(true, 39);
        }
        CircleFrameLayout circleFrameLayout = new CircleFrameLayout(i2, this.invoke.toString - i2);
        circleFrameLayout.setMax(str);
        circleFrameLayout.setMin(this.invoke.isInside);
        return circleFrameLayout;
    }

    private isHasFace validateRelationship() throws IOException {
        int min;
        if (this.valueOf != 84) {
            ITrustedWebActivityCallback();
        }
        int i = this.invoke.values;
        int i2 = this.invoke.toString;
        ArrayList<isHasFace> arrayList = new ArrayList<>();
        setFaceId setfaceid = new setFaceId(i);
        int i3 = 1;
        int i4 = 0;
        while (true) {
            int i5 = -1;
            while (true) {
                min = getMin();
                if (min != 90) {
                    break;
                }
                this.invokeSuspend = 0;
                i5 = this.invoke.toString;
                if (i3 == 0) {
                    i3 = 1;
                } else {
                    arrayList.add(new getPitch(this.invoke.values, 1));
                    i4++;
                }
            }
            if (min == 85) {
                this.invokeSuspend = 0;
                i2 = this.invoke.toString;
                setfaceid.isInside = arrayList.size() + i3;
                setfaceid.toIntRange(i4);
                if (i5 != -1) {
                    length((List<?>) arrayList, i5);
                }
            } else if (min == 120 && i3 == 0 && arrayList.size() == 1) {
                return length((isHasFace) arrayList.get(0), i);
            } else {
                if (min == 0) {
                    getMax("msg.no.bracket.arg", (String) null);
                    break;
                }
                if (i3 == 0) {
                    getMax("msg.no.bracket.arg", (String) null);
                }
                arrayList.add(onMessageChannelReady());
                i3 = 0;
            }
        }
        for (isHasFace min2 : arrayList) {
            setfaceid.getMin(min2);
        }
        setfaceid.equals(i2 - i);
        return setfaceid;
    }

    private isHasFace length(isHasFace ishasface, int i) throws IOException {
        ArrayList arrayList = new ArrayList();
        while (getMin() == 120) {
            arrayList.add(updateVisuals());
        }
        setMin setmin = null;
        int i2 = 0;
        if (getMin() == 113) {
            this.invokeSuspend = 0;
            i2 = this.invoke.values - i;
            setmin = equals();
        }
        length(85, "msg.no.bracket.arg");
        F2fPayChannelView f2fPayChannelView = new F2fPayChannelView(i, this.invoke.toString - i);
        if (ishasface != null) {
            f2fPayChannelView.isInside = ishasface;
            ishasface.getMax(f2fPayChannelView);
            f2fPayChannelView.setMin(arrayList);
            if (setmin != null) {
                f2fPayChannelView.toFloatRange = i2;
                isHasFace ishasface2 = setmin.length;
                f2fPayChannelView.toIntRange = ishasface2;
                if (ishasface2 != null) {
                    ishasface2.getMax(f2fPayChannelView);
                }
                f2fPayChannelView.values = setmin.setMax - i;
                f2fPayChannelView.toDoubleRange = setmin.getMax - i;
            }
            return f2fPayChannelView;
        }
        throw new IllegalArgumentException("arg cannot be null");
    }

    private isHasFace getMax(isHasFace ishasface, int i, boolean z) throws IOException {
        ArrayList arrayList = new ArrayList();
        while (getMin() == 120) {
            arrayList.add(requestPostMessageChannelWithExtras());
        }
        setMin setmin = null;
        int i2 = 0;
        if (getMin() == 113) {
            this.invokeSuspend = 0;
            i2 = this.invoke.values - i;
            setmin = equals();
        }
        if (!z) {
            length(89, "msg.no.paren.let");
        }
        setDistance setdistance = new setDistance(i, this.invoke.toString - i);
        if (ishasface != null) {
            setdistance.toFloatRange = ishasface;
            ishasface.getMax(setdistance);
            setdistance.setMax(arrayList);
            if (setmin != null) {
                setdistance.equals = i2;
                isHasFace ishasface2 = setmin.length;
                setdistance.toIntRange = ishasface2;
                if (ishasface2 != null) {
                    ishasface2.getMax(setdistance);
                }
                setdistance.values = setmin.setMax - i;
                setdistance.toDoubleRange = setmin.getMax - i;
            }
            return setdistance;
        }
        throw new IllegalArgumentException("arg cannot be null");
    }

    /* JADX WARNING: type inference failed for: r5v0 */
    /* JADX WARNING: type inference failed for: r5v1, types: [java.lang.String, o.getFaceRegion] */
    /* JADX WARNING: type inference failed for: r5v6 */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x00cf, code lost:
        if (r8 != 8) goto L_0x0101;
     */
    /* JADX WARNING: Removed duplicated region for block: B:47:0x00c7  */
    /* JADX WARNING: Removed duplicated region for block: B:69:0x010c A[LOOP:0: B:5:0x0027->B:69:0x010c, LOOP_END] */
    /* JADX WARNING: Removed duplicated region for block: B:75:0x0113 A[EDGE_INSN: B:75:0x0113->B:70:0x0113 ?: BREAK  , SYNTHETIC] */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.LoadingProgressDialog receiveFile() throws java.io.IOException {
        /*
            r17 = this;
            r0 = r17
            o.switchOn r1 = r0.invoke
            int r1 = r1.values
            o.switchOn r2 = r0.invoke
            int r2 = r2.isInside
            java.util.ArrayList r3 = new java.util.ArrayList
            r3.<init>()
            boolean r4 = r0.setMax
            r5 = 0
            if (r4 == 0) goto L_0x001f
            java.util.HashSet r4 = new java.util.HashSet
            r4.<init>()
            java.util.HashSet r6 = new java.util.HashSet
            r6.<init>()
            goto L_0x0021
        L_0x001f:
            r4 = r5
            r6 = r4
        L_0x0021:
            o.getFaceRegion r7 = r0.b
            r0.b = r5
            r8 = -1
            r9 = -1
        L_0x0027:
            int r10 = r17.getMin()
            o.getFaceRegion r11 = r0.b
            r0.b = r5
            r12 = 87
            if (r10 != r12) goto L_0x003a
            if (r9 == r8) goto L_0x0113
            r0.length((java.util.List<?>) r3, (int) r9)
            goto L_0x0113
        L_0x003a:
            o.isHasFace r9 = r17.ICustomTabsService$Stub$Proxy()
            java.lang.String r14 = "msg.bad.prop"
            r15 = 90
            if (r9 != 0) goto L_0x004a
            r0.getMax((java.lang.String) r14, (java.lang.String) r5)
        L_0x0047:
            r8 = 1
            goto L_0x00bc
        L_0x004a:
            o.switchOn r5 = r0.invoke
            java.lang.String r5 = r5.setMin
            o.switchOn r13 = r0.invoke
            int r13 = r13.values
            r8 = 0
            r0.invokeSuspend = r8
            int r8 = r17.getMin()
            if (r8 == r15) goto L_0x00b1
            r15 = 104(0x68, float:1.46E-43)
            if (r8 == r15) goto L_0x00b1
            if (r8 == r12) goto L_0x00b1
            r10 = 88
            if (r8 != r10) goto L_0x0068
            r5 = 8
            goto L_0x0085
        L_0x0068:
            int r8 = r9.length()
            r10 = 39
            if (r8 != r10) goto L_0x0084
            java.lang.String r8 = "get"
            boolean r8 = r8.equals(r5)
            if (r8 == 0) goto L_0x007a
            r5 = 2
            goto L_0x0085
        L_0x007a:
            java.lang.String r8 = "set"
            boolean r5 = r8.equals(r5)
            if (r5 == 0) goto L_0x0084
            r5 = 4
            goto L_0x0085
        L_0x0084:
            r5 = 1
        L_0x0085:
            r8 = 2
            if (r5 == r8) goto L_0x008b
            r8 = 4
            if (r5 != r8) goto L_0x0098
        L_0x008b:
            o.isHasFace r9 = r17.ICustomTabsService$Stub$Proxy()
            if (r9 != 0) goto L_0x0095
            r8 = 0
            r0.getMax((java.lang.String) r14, (java.lang.String) r8)
        L_0x0095:
            r8 = 0
            r0.invokeSuspend = r8
        L_0x0098:
            if (r9 != 0) goto L_0x009d
            r8 = r5
            r5 = 0
            goto L_0x00bc
        L_0x009d:
            o.switchOn r8 = r0.invoke
            java.lang.String r8 = r8.setMin
            o.setAnimationInterval r10 = r0.setMax((int) r13, (o.isHasFace) r9, (int) r5)
            r9.getMax((o.getFaceRegion) r11)
            r3.add(r10)
            r16 = r8
            r8 = r5
            r5 = r16
            goto L_0x00bc
        L_0x00b1:
            r9.getMax((o.getFaceRegion) r11)
            o.setAnimationInterval r8 = r0.getMax((o.isHasFace) r9, (int) r10)
            r3.add(r8)
            goto L_0x0047
        L_0x00bc:
            boolean r9 = r0.setMax
            if (r9 == 0) goto L_0x0101
            if (r5 == 0) goto L_0x0101
            java.lang.String r9 = "msg.dup.obj.lit.prop.strict"
            r10 = 1
            if (r8 == r10) goto L_0x00ec
            r10 = 2
            if (r8 == r10) goto L_0x00df
            r10 = 4
            if (r8 == r10) goto L_0x00d2
            r10 = 8
            if (r8 == r10) goto L_0x00ec
            goto L_0x0101
        L_0x00d2:
            boolean r8 = r6.contains(r5)
            if (r8 == 0) goto L_0x00db
            r0.length((java.lang.String) r9, (java.lang.String) r5)
        L_0x00db:
            r6.add(r5)
            goto L_0x0101
        L_0x00df:
            boolean r8 = r4.contains(r5)
            if (r8 == 0) goto L_0x00e8
            r0.length((java.lang.String) r9, (java.lang.String) r5)
        L_0x00e8:
            r4.add(r5)
            goto L_0x0101
        L_0x00ec:
            boolean r8 = r4.contains(r5)
            if (r8 != 0) goto L_0x00f8
            boolean r8 = r6.contains(r5)
            if (r8 == 0) goto L_0x00fb
        L_0x00f8:
            r0.length((java.lang.String) r9, (java.lang.String) r5)
        L_0x00fb:
            r4.add(r5)
            r6.add(r5)
        L_0x0101:
            r5 = 0
            r0.b = r5
            r8 = 90
            boolean r8 = r0.setMin((int) r8)
            if (r8 == 0) goto L_0x0113
            o.switchOn r8 = r0.invoke
            int r9 = r8.toString
            r8 = -1
            goto L_0x0027
        L_0x0113:
            java.lang.String r4 = "msg.no.brace.prop"
            r0.length((int) r12, (java.lang.String) r4)
            o.LoadingProgressDialog r4 = new o.LoadingProgressDialog
            o.switchOn r5 = r0.invoke
            int r5 = r5.toString
            int r5 = r5 - r1
            r4.<init>(r1, r5)
            if (r7 == 0) goto L_0x0127
            r4.getMax((o.getFaceRegion) r7)
        L_0x0127:
            r4.getMax(r3)
            r4.setMin((int) r2)
            return r4
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.receiveFile():o.LoadingProgressDialog");
    }

    private isHasFace ICustomTabsService$Stub$Proxy() throws IOException {
        switch (getMin()) {
            case 39:
                return setMax(false, 39);
            case 40:
                return new setEnable(this.invoke.values, this.invoke.setMin, this.invoke.setMax);
            case 41:
                return ICustomTabsService$Default();
            default:
                if (!this.length.getMax() || !switchOn.setMin(this.invoke.setMin, this.length.setMin, this.setMax)) {
                    return null;
                }
                return setMax(false, 39);
        }
    }

    private setAnimationInterval getMax(isHasFace ishasface, int i) throws IOException {
        int min = getMin();
        if ((min == 90 || min == 87) && i == 39 && this.length.setMin >= 180) {
            if (!this.ICustomTabsCallback) {
                getMax("msg.bad.object.init", (String) null);
            }
            CircleFrameLayout.WidgetListener widgetListener = new CircleFrameLayout.WidgetListener(ishasface.Mean$Arithmetic(), ((CircleFrameLayout.WidgetListener) ishasface).equals);
            setAnimationInterval setanimationinterval = new setAnimationInterval();
            setanimationinterval.setMax(26, (Object) Boolean.TRUE);
            setanimationinterval.length(ishasface, widgetListener);
            return setanimationinterval;
        }
        length(104, "msg.no.colon.prop");
        setAnimationInterval setanimationinterval2 = new setAnimationInterval();
        setanimationinterval2.toIntRange(this.invoke.values);
        setanimationinterval2.length(ishasface, onMessageChannelReady());
        return setanimationinterval2;
    }

    private setAnimationInterval setMax(int i, isHasFace ishasface, int i2) throws IOException {
        FunctionNode max = setMax(2);
        CircleFrameLayout.WidgetListener widgetListener = max.toIntRange;
        if (widgetListener != null) {
            if ((widgetListener.equals == null ? 0 : widgetListener.equals.length()) != 0) {
                getMax("msg.bad.prop", (String) null);
            }
        }
        setAnimationInterval setanimationinterval = new setAnimationInterval(i);
        if (i2 == 2) {
            setanimationinterval.invoke();
            max.values = FunctionNode.Form.GETTER;
        } else if (i2 == 4) {
            setanimationinterval.onRelationshipValidationResult();
            max.values = FunctionNode.Form.SETTER;
        } else if (i2 == 8) {
            setanimationinterval.onPostMessage();
            max.values = FunctionNode.Form.METHOD;
        }
        setanimationinterval.setMax(ishasface);
        setanimationinterval.getMin(max);
        setanimationinterval.equals((max.Mean$Arithmetic() + max.create()) - i);
        return setanimationinterval;
    }

    /* JADX WARNING: Removed duplicated region for block: B:10:0x003c  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.CircleFrameLayout.WidgetListener setMax(boolean r6, int r7) {
        /*
            r5 = this;
            o.switchOn r0 = r5.invoke
            int r0 = r0.values
            o.switchOn r1 = r5.invoke
            java.lang.String r1 = r1.setMin
            o.switchOn r2 = r5.invoke
            int r2 = r2.isInside
            java.lang.String r3 = r5.extraCallback
            java.lang.String r4 = ""
            boolean r3 = r4.equals(r3)
            if (r3 != 0) goto L_0x0023
            int r0 = r5.onRelationshipValidationResult
            java.lang.String r1 = r5.extraCallback
            int r2 = r5.onMessageChannelReady
            r3 = 0
            r5.onRelationshipValidationResult = r3
            r5.extraCallback = r4
            r5.onMessageChannelReady = r3
        L_0x0023:
            if (r1 != 0) goto L_0x0031
            o.SecureQwertyKeyboard$2 r3 = r5.length
            boolean r3 = r3.values()
            if (r3 == 0) goto L_0x002e
            goto L_0x0032
        L_0x002e:
            r5.ITrustedWebActivityCallback()
        L_0x0031:
            r4 = r1
        L_0x0032:
            o.CircleFrameLayout$WidgetListener r1 = new o.CircleFrameLayout$WidgetListener
            r1.<init>(r0, r4)
            r1.setMin((int) r2)
            if (r6 == 0) goto L_0x003f
            r5.getMin((java.lang.String) r4, (int) r7)
        L_0x003f:
            return r1
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.setMax(boolean, int):o.CircleFrameLayout$WidgetListener");
    }

    private paintStroke ICustomTabsService$Default() {
        int i = this.invoke.values;
        paintStroke paintstroke = new paintStroke(i, this.invoke.toString - i);
        paintstroke.setMin(this.invoke.isInside);
        String str = this.invoke.setMin;
        if (str != null) {
            paintstroke.toFloatRange = str;
            paintstroke.toIntRange = this.invoke.setMin();
            return paintstroke;
        }
        throw new IllegalArgumentException("arg cannot be null");
    }

    /* access modifiers changed from: protected */
    public final void getMin(String str, int i) {
        if (length()) {
            boolean z = false;
            if (("arguments".equals(str) && ((FunctionNode) this.setMin).invokeSuspend != 4) || ((this.length.length != null && this.length.length.contains(str)) || ("length".equals(str) && i == 33 && this.length.setMin == 120))) {
                z = true;
            }
            if (z && length()) {
                ((FunctionNode) this.setMin).Mean$Arithmetic = true;
            }
        }
    }

    /* access modifiers changed from: protected */
    public final void getMax() {
        if (length()) {
            ((FunctionNode) this.setMin).Mean$Arithmetic = true;
        }
    }

    private void length(isHasFace ishasface) {
        if (((ishasface.length() == 39 && "eval".equals(((CircleFrameLayout.WidgetListener) ishasface).equals)) || (ishasface.length() == 33 && "eval".equals(((CircleFrameLayout.WidgetListener) ((resetAnimation) ishasface).invokeSuspend()).equals))) && length()) {
            ((FunctionNode) this.setMin).Mean$Arithmetic = true;
        }
    }

    private getLeftEyeBlinkRatio IPostMessageService() {
        getLeftEyeBlinkRatio getlefteyeblinkratio = new getLeftEyeBlinkRatio(this.invoke.values, this.invoke.toString - this.invoke.values);
        getlefteyeblinkratio.setMin(this.invoke.isInside);
        return getlefteyeblinkratio;
    }

    private int getMax(int i) {
        char[] cArr = this.toDoubleRange;
        if (cArr == null) {
            return -1;
        }
        if (i <= 0) {
            return 0;
        }
        if (i >= cArr.length) {
            i = cArr.length - 1;
        }
        do {
            i--;
            if (i < 0) {
                return 0;
            }
        } while (!LogItem.getMax((int) cArr[i]));
        return i + 1;
    }

    private void toIntRange(int i) {
        if (this.length.IsOverlapping()) {
            int[] iArr = new int[2];
            String max = this.invoke.setMax(i, iArr);
            this.length.values();
            if (max != null) {
                setMin("msg.missing.semi", "", iArr[0], max, iArr[1]);
            } else if (this.length.IsOverlapping()) {
                setMin("msg.missing.semi", "");
            }
        }
    }

    private void length(List<?> list, int i) {
        if (this.length.equals()) {
            if (!list.isEmpty()) {
                ((isHasFace) list.get(0)).Mean$Arithmetic();
            }
            getMax(i);
            setMin("msg.extra.trailing.comma", (String) null);
        }
    }

    private static String ICustomTabsService$Stub() throws IOException {
        BufferedReader bufferedReader = new BufferedReader((Reader) null);
        try {
            char[] cArr = new char[1024];
            StringBuilder sb = new StringBuilder(1024);
            while (true) {
                int read = bufferedReader.read(cArr, 0, 1024);
                if (read == -1) {
                    return sb.toString();
                }
                sb.append(cArr, 0, read);
            }
        } finally {
            bufferedReader.close();
        }
    }

    protected class getMax {
        private List<AlgorithmInfoPattern> IsOverlapping;
        private List<setWidgetListener> equals;
        private setRoundColor getMax;
        private int getMin;
        private getCricleColor length;
        private boolean setMax;
        private Map<String, setDeepLiveness> toFloatRange;

        getMax(FunctionNode functionNode) {
            this.length = traceTemplate.this.setMin;
            traceTemplate.this.setMin = functionNode;
            this.getMax = traceTemplate.this.toIntRange;
            traceTemplate.this.toIntRange = functionNode;
            this.toFloatRange = traceTemplate.this.toFloatRange;
            traceTemplate.this.toFloatRange = null;
            this.equals = traceTemplate.this.IsOverlapping;
            traceTemplate.this.IsOverlapping = null;
            this.IsOverlapping = traceTemplate.this.equals;
            traceTemplate.this.equals = null;
            this.getMin = traceTemplate.this.isInside;
            traceTemplate.this.isInside = 0;
            this.setMax = traceTemplate.this.onNavigationEvent;
            boolean unused = traceTemplate.this.onNavigationEvent = false;
        }

        /* access modifiers changed from: package-private */
        public final void getMin() {
            traceTemplate.this.setMin = this.length;
            traceTemplate.this.toIntRange = this.getMax;
            traceTemplate.this.toFloatRange = this.toFloatRange;
            traceTemplate.this.IsOverlapping = this.equals;
            traceTemplate.this.equals = this.IsOverlapping;
            traceTemplate.this.isInside = this.getMin;
            boolean unused = traceTemplate.this.onNavigationEvent = this.setMax;
        }
    }

    /* access modifiers changed from: package-private */
    public final LogFactory getMax(int i, LogFactory logFactory, LogFactory logFactory2) {
        getCricleColor getcriclecolor = this.setMin;
        StringBuilder sb = new StringBuilder("$");
        int i2 = getcriclecolor.setDefaultImpl;
        getcriclecolor.setDefaultImpl = i2 + 1;
        sb.append(i2);
        String obj = sb.toString();
        LogFactory max = getMax(i, logFactory, logFactory2, obj);
        LogFactory max2 = max.getMax();
        getMin(obj, 39);
        max2.getMax(LogFactory.length(39, obj));
        return max;
    }

    /* JADX INFO: finally extract failed */
    private LogFactory getMax(int i, LogFactory logFactory, LogFactory logFactory2, String str) {
        int equals2 = logFactory.equals();
        setRoundColor setroundcolor = new setRoundColor();
        setroundcolor.setMax(159);
        setroundcolor.setMin(equals2);
        getMin(str, 39);
        LogFactory length2 = LogFactory.length(39, str);
        length2.setMax(39);
        if (logFactory2 != null) {
            length2.getMax(logFactory2);
        }
        setroundcolor.length(new LogFactory(154, length2));
        try {
            setMin(setroundcolor);
            boolean z = true;
            length(154, str, true);
            this.toIntRange = this.toIntRange.asInterface();
            LogFactory logFactory3 = new LogFactory(90);
            setroundcolor.getMax(logFactory3);
            ArrayList arrayList = new ArrayList();
            int length3 = logFactory.length();
            if (length3 == 33 || length3 == 36) {
                if (i == 123 || i == 154 || i == 155) {
                    getMax("msg.bad.assign.left", (String) null);
                }
                getMin(str, 39);
                logFactory3.getMax(length(logFactory, LogFactory.length(39, str)));
            } else if (length3 == 66) {
                z = getMax((setFaceId) logFactory, i, str, logFactory3, arrayList);
            } else if (length3 != 67) {
                getMax("msg.bad.assign.left", (String) null);
            } else {
                z = setMin((LoadingProgressDialog) logFactory, i, str, logFactory3, (List<String>) arrayList);
            }
            if (z) {
                logFactory3.getMax(LogFactory.getMin(0.0d));
            }
            setroundcolor.setMax(22, (Object) arrayList);
            return setroundcolor;
        } catch (Throwable th) {
            this.toIntRange = this.toIntRange.asInterface();
            throw th;
        }
    }

    /* access modifiers changed from: protected */
    public final LogFactory setMin(String str) {
        getMin(str, 39);
        return LogFactory.length(39, str);
    }

    /* access modifiers changed from: protected */
    public final LogFactory length(LogFactory logFactory, LogFactory logFactory2) {
        LogFactory logFactory3;
        LogFactory logFactory4;
        int i;
        int length2 = logFactory.length();
        if (length2 == 33 || length2 == 36) {
            if (logFactory instanceof resetAnimation) {
                resetAnimation resetanimation = (resetAnimation) logFactory;
                logFactory4 = resetanimation.Grayscale$Algorithm();
                logFactory3 = (CircleFrameLayout.WidgetListener) resetanimation.invokeSuspend();
            } else if (logFactory instanceof setGaussian) {
                setGaussian setgaussian = (setGaussian) logFactory;
                logFactory4 = setgaussian.equals;
                logFactory3 = setgaussian.toIntRange;
            } else {
                logFactory4 = logFactory.setMin();
                logFactory3 = logFactory.getMax();
            }
            if (length2 == 33) {
                i = 35;
                logFactory3.setMax(41);
            } else {
                i = 37;
            }
            return new LogFactory(i, logFactory4, logFactory3, logFactory2);
        } else if (length2 == 39) {
            String str = ((CircleFrameLayout.WidgetListener) logFactory).equals;
            if (this.setMax && ("eval".equals(str) || "arguments".equals(str))) {
                getMax("msg.bad.id.strict", str);
            }
            logFactory.setMax(49);
            return new LogFactory(8, logFactory, logFactory2);
        } else if (length2 == 68) {
            LogFactory min = logFactory.setMin();
            if ((min.setMin(16, 0) & 4) != 0) {
                getMax("msg.bad.assign.left", (String) null);
            }
            return new LogFactory(69, min, logFactory2);
        } else {
            throw ITrustedWebActivityCallback();
        }
    }

    /* access modifiers changed from: protected */
    public final void setMin(LogFactory logFactory) {
        if ((logFactory.setMin(16, 0) & 4) != 0) {
            getMax("msg.bad.assign.left", (String) null);
        }
    }

    private static void getMax(isHasFace ishasface) {
        while (!(ishasface instanceof getGaussian)) {
            if (ishasface instanceof PromptTextView.AnonymousClass1) {
                ishasface = ((PromptTextView.AnonymousClass1) ishasface).equals;
            } else {
                return;
            }
        }
        ((getGaussian) ishasface).Grayscale$Algorithm();
    }

    private RuntimeException ITrustedWebActivityCallback() throws RuntimeException {
        StringBuilder sb = new StringBuilder("ts.cursor=");
        sb.append(this.invoke.toFloatRange);
        sb.append(", ts.tokenBeg=");
        sb.append(this.invoke.values);
        sb.append(", currentToken=");
        sb.append(this.valueOf);
        throw getStyleId.setMax(sb.toString());
    }

    public final boolean setMin() {
        return this.setMax;
    }

    private traceTemplate(SecureQwertyKeyboard.AnonymousClass2 r2) {
        this(r2, r2.setMax);
    }

    /* access modifiers changed from: package-private */
    public final void setMin(String str, String str2) {
        int length2 = str.length();
        int max = dispatchOnCancelled.setMax(length2);
        if (length2 != max) {
            onCanceled oncanceled = new onCanceled(length2, max, 1);
            onCancelLoad.setMax(-1603205390, oncanceled);
            onCancelLoad.getMin(-1603205390, oncanceled);
        }
        if (str2 == null) {
            LogItem.getMax(str);
        } else {
            LogItem.getMin(str, (Object) str2);
        }
        if (this.length.toIntRange()) {
            setMax(str, str2);
        } else if (this.toString == null) {
            this.invoke.toIntRange();
        }
    }

    /* access modifiers changed from: package-private */
    public final void setMax(String str) {
        setMax(str, (String) null);
    }

    private void getMin(String str) {
        setMax(str, (String) null);
        if (!this.length.toDoubleRange()) {
            throw new length();
        }
    }

    private void setMin(isHasFace ishasface) throws IOException {
        getMin();
        int i = this.invokeSuspend;
        int Mean$Arithmetic2 = ishasface.Mean$Arithmetic();
        int i2 = 65535 & i;
        if (!(i2 == -1 || i2 == 0)) {
            if (i2 == 83) {
                this.invokeSuspend = 0;
                ishasface.equals(this.invoke.toString - Mean$Arithmetic2);
                return;
            } else if (i2 != 87) {
                if ((i & 65536) == 0) {
                    getMax("msg.no.semi.stmt", (String) null);
                    return;
                } else {
                    toIntRange(ishasface.Mean$Arithmetic() + ishasface.create());
                    return;
                }
            }
        }
        toIntRange(ishasface.Mean$Arithmetic() + ishasface.create());
    }

    private setDeepLiveness valueOf() throws IOException {
        setDeepLiveness setdeepliveness;
        int min = getMin();
        if ((this.invokeSuspend & 65536) != 0) {
            min = 1;
        }
        if (min != 39) {
            return null;
        }
        this.invokeSuspend = 0;
        Map<String, setDeepLiveness> map = this.toFloatRange;
        if (map != null) {
            setdeepliveness = map.get(this.invoke.setMin);
        } else {
            setdeepliveness = null;
        }
        if (setdeepliveness == null) {
            getMax("msg.undef.label", (String) null);
        }
        return setdeepliveness;
    }

    private isHasFace newSession() throws IOException {
        int min = getMin();
        this.invokeSuspend = 0;
        int i = this.invoke.values;
        if (min == 23) {
            int i2 = this.invoke.values;
            int i3 = this.invoke.isInside;
            this.onRelationshipValidationResult = i2;
            this.extraCallback = "*";
            this.onMessageChannelReady = i3;
            return getMin(i, 0);
        } else if (min == 39) {
            return getMin(i, 0);
        } else {
            if (min == 84) {
                return getMax(i, (CircleFrameLayout.WidgetListener) null, -1);
            }
            getMax("msg.no.name.after.xmlAttr", (String) null);
            return IPostMessageService();
        }
    }

    private isHasFace requestPostMessageChannel() throws IOException {
        getMin();
        int i = this.invokeSuspend;
        int i2 = 65535 & i;
        if (i2 == -1) {
            this.invokeSuspend = 0;
        } else if (i2 != 0) {
            if (i2 != 24) {
                if (i2 == 84) {
                    this.invokeSuspend = 0;
                    return validateRelationship();
                } else if (i2 == 86) {
                    this.invokeSuspend = 0;
                    return receiveFile();
                } else if (i2 == 88) {
                    this.invokeSuspend = 0;
                    return postMessage();
                } else if (i2 != 101) {
                    if (i2 == 110) {
                        this.invokeSuspend = 0;
                        return setMax(2);
                    } else if (i2 == 128) {
                        this.invokeSuspend = 0;
                        getMax("msg.reserved.id", this.invoke.setMin);
                    } else if (i2 == 148) {
                        this.invokeSuspend = 0;
                        if (!this.length.getMin()) {
                            getMax("msg.XML.not.available", (String) null);
                        }
                        return newSession();
                    } else if (i2 != 154) {
                        switch (i2) {
                            case 39:
                                this.invokeSuspend = 0;
                                return length(i);
                            case 40:
                                this.invokeSuspend = 0;
                                String str = this.invoke.setMin;
                                if (this.setMax && this.invoke.setMax()) {
                                    getMax("msg.no.old.octal.strict", (String) null);
                                }
                                if (this.invoke.getMax()) {
                                    str = "0b".concat(String.valueOf(str));
                                }
                                if (this.invoke.setMax()) {
                                    str = "0".concat(String.valueOf(str));
                                }
                                if (this.invoke.length()) {
                                    str = "0o".concat(String.valueOf(str));
                                }
                                if (this.invoke.getMin()) {
                                    str = "0x".concat(String.valueOf(str));
                                }
                                return new setEnable(this.invoke.values, str, this.invoke.setMax);
                            case 41:
                                this.invokeSuspend = 0;
                                return ICustomTabsService$Default();
                            case 42:
                            case 43:
                            case 44:
                            case 45:
                                this.invokeSuspend = 0;
                                int i3 = this.invoke.values;
                                return new showInfo(i3, this.invoke.toString - i3, i2);
                            default:
                                this.invokeSuspend = 0;
                                getMax("msg.syntax", (String) null);
                                break;
                        }
                    } else {
                        this.invokeSuspend = 0;
                        return setMin(false, this.invoke.values);
                    }
                }
            }
            this.invokeSuspend = 0;
            this.invoke.getMin(i2);
            int i4 = this.invoke.values;
            setProcessColor setprocesscolor = new setProcessColor(i4, this.invoke.toString - i4);
            String str2 = this.invoke.setMin;
            if (str2 != null) {
                setprocesscolor.toFloatRange = str2;
                switchOn switchon = this.invoke;
                String str3 = switchon.length;
                switchon.length = null;
                setprocesscolor.isInside = str3;
                return setprocesscolor;
            }
            throw new IllegalArgumentException("arg cannot be null");
        } else {
            this.invokeSuspend = 0;
            getMax("msg.unexpected.eof", (String) null);
        }
        this.invokeSuspend = 0;
        return IPostMessageService();
    }

    /* JADX WARNING: Removed duplicated region for block: B:16:0x0044 A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:17:0x004a A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:20:0x0051 A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:26:0x0068 A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:29:0x0075 A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:32:0x0086 A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:36:0x0091 A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:45:0x00c0 A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:46:0x00c6 A[Catch:{ all -> 0x00f0 }] */
    /* JADX WARNING: Removed duplicated region for block: B:49:0x00dd A[Catch:{ all -> 0x00f0 }] */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private o.NotProguard updateVisuals() throws java.io.IOException {
        /*
            r13 = this;
            int r0 = r13.getMin()
            r1 = 0
            r13.invokeSuspend = r1
            r2 = 120(0x78, float:1.68E-43)
            if (r0 == r2) goto L_0x000e
            r13.ITrustedWebActivityCallback()
        L_0x000e:
            o.switchOn r0 = r13.invoke
            int r0 = r0.values
            o.NotProguard r2 = new o.NotProguard
            r2.<init>(r0)
            r13.setMin((o.setRoundColor) r2)
            r3 = 39
            boolean r4 = r13.setMin((int) r3)     // Catch:{ all -> 0x00f0 }
            java.lang.String r5 = "msg.no.paren.for"
            r6 = 0
            r7 = -1
            if (r4 == 0) goto L_0x003b
            o.switchOn r4 = r13.invoke     // Catch:{ all -> 0x00f0 }
            java.lang.String r4 = r4.setMin     // Catch:{ all -> 0x00f0 }
            java.lang.String r8 = "each"
            boolean r4 = r4.equals(r8)     // Catch:{ all -> 0x00f0 }
            if (r4 == 0) goto L_0x0038
            o.switchOn r4 = r13.invoke     // Catch:{ all -> 0x00f0 }
            int r4 = r4.values     // Catch:{ all -> 0x00f0 }
            int r4 = r4 - r0
            goto L_0x003c
        L_0x0038:
            r13.getMax((java.lang.String) r5, (java.lang.String) r6)     // Catch:{ all -> 0x00f0 }
        L_0x003b:
            r4 = -1
        L_0x003c:
            r8 = 88
            boolean r5 = r13.length((int) r8, (java.lang.String) r5)     // Catch:{ all -> 0x00f0 }
            if (r5 == 0) goto L_0x004a
            o.switchOn r5 = r13.invoke     // Catch:{ all -> 0x00f0 }
            int r5 = r5.values     // Catch:{ all -> 0x00f0 }
            int r5 = r5 - r0
            goto L_0x004b
        L_0x004a:
            r5 = -1
        L_0x004b:
            int r8 = r13.getMin()     // Catch:{ all -> 0x00f0 }
            if (r8 == r3) goto L_0x0068
            r9 = 84
            if (r8 == r9) goto L_0x0060
            r9 = 86
            if (r8 == r9) goto L_0x0060
            java.lang.String r8 = "msg.bad.var"
            r13.getMax((java.lang.String) r8, (java.lang.String) r6)     // Catch:{ all -> 0x00f0 }
            r8 = r6
            goto L_0x006e
        L_0x0060:
            o.isHasFace r8 = r13.mayLaunchUrl()     // Catch:{ all -> 0x00f0 }
            getMax((o.isHasFace) r8)     // Catch:{ all -> 0x00f0 }
            goto L_0x006e
        L_0x0068:
            r13.invokeSuspend = r1     // Catch:{ all -> 0x00f0 }
            o.CircleFrameLayout$WidgetListener r8 = r13.setMax((boolean) r1, (int) r3)     // Catch:{ all -> 0x00f0 }
        L_0x006e:
            int r9 = r8.length()     // Catch:{ all -> 0x00f0 }
            r10 = 1
            if (r9 != r3) goto L_0x007e
            r9 = 154(0x9a, float:2.16E-43)
            o.switchOn r11 = r13.invoke     // Catch:{ all -> 0x00f0 }
            java.lang.String r11 = r11.setMin     // Catch:{ all -> 0x00f0 }
            r13.length((int) r9, (java.lang.String) r11, (boolean) r10)     // Catch:{ all -> 0x00f0 }
        L_0x007e:
            int r9 = r13.getMin()     // Catch:{ all -> 0x00f0 }
            r13.invokeSuspend = r1     // Catch:{ all -> 0x00f0 }
            if (r9 == r3) goto L_0x0091
            r3 = 52
            if (r9 == r3) goto L_0x008b
            goto L_0x00ab
        L_0x008b:
            o.switchOn r3 = r13.invoke     // Catch:{ all -> 0x00f0 }
            int r3 = r3.values     // Catch:{ all -> 0x00f0 }
            int r3 = r3 - r0
            goto L_0x00b1
        L_0x0091:
            java.lang.String r3 = "of"
            o.switchOn r9 = r13.invoke     // Catch:{ all -> 0x00f0 }
            java.lang.String r9 = r9.setMin     // Catch:{ all -> 0x00f0 }
            boolean r3 = r3.equals(r9)     // Catch:{ all -> 0x00f0 }
            if (r3 == 0) goto L_0x00ab
            if (r4 == r7) goto L_0x00a4
            java.lang.String r3 = "msg.invalid.for.each"
            r13.getMax((java.lang.String) r3, (java.lang.String) r6)     // Catch:{ all -> 0x00f0 }
        L_0x00a4:
            o.switchOn r3 = r13.invoke     // Catch:{ all -> 0x00f0 }
            int r3 = r3.values     // Catch:{ all -> 0x00f0 }
            int r3 = r3 - r0
            r6 = 1
            goto L_0x00b2
        L_0x00ab:
            java.lang.String r3 = "msg.in.after.for.name"
            r13.getMax((java.lang.String) r3, (java.lang.String) r6)     // Catch:{ all -> 0x00f0 }
            r3 = -1
        L_0x00b1:
            r6 = 0
        L_0x00b2:
            o.isHasFace r9 = r13.extraCallbackWithResult()     // Catch:{ all -> 0x00f0 }
            r11 = 89
            java.lang.String r12 = "msg.no.paren.for.ctrl"
            boolean r11 = r13.length((int) r11, (java.lang.String) r12)     // Catch:{ all -> 0x00f0 }
            if (r11 == 0) goto L_0x00c6
            o.switchOn r11 = r13.invoke     // Catch:{ all -> 0x00f0 }
            int r11 = r11.values     // Catch:{ all -> 0x00f0 }
            int r11 = r11 - r0
            goto L_0x00c7
        L_0x00c6:
            r11 = -1
        L_0x00c7:
            o.switchOn r12 = r13.invoke     // Catch:{ all -> 0x00f0 }
            int r12 = r12.toString     // Catch:{ all -> 0x00f0 }
            int r12 = r12 - r0
            r2.equals(r12)     // Catch:{ all -> 0x00f0 }
            r2.getMin((o.isHasFace) r8)     // Catch:{ all -> 0x00f0 }
            r2.setMax((o.isHasFace) r9)     // Catch:{ all -> 0x00f0 }
            r2.toIntRange(r3)     // Catch:{ all -> 0x00f0 }
            r2.toDoubleRange(r4)     // Catch:{ all -> 0x00f0 }
            if (r4 == r7) goto L_0x00de
            r1 = 1
        L_0x00de:
            r2.setMax((boolean) r1)     // Catch:{ all -> 0x00f0 }
            r2.getMin(r5, r11)     // Catch:{ all -> 0x00f0 }
            r2.getMin((boolean) r6)     // Catch:{ all -> 0x00f0 }
            o.setRoundColor r0 = r13.toIntRange
            o.setRoundColor r0 = r0.asInterface()
            r13.toIntRange = r0
            return r2
        L_0x00f0:
            r0 = move-exception
            o.setRoundColor r1 = r13.toIntRange
            o.setRoundColor r1 = r1.asInterface()
            r13.toIntRange = r1
            throw r0
        */
        throw new UnsupportedOperationException("Method not decompiled: o.traceTemplate.updateVisuals():o.NotProguard");
    }

    private setRightEyeBlinkRatio requestPostMessageChannelWithExtras() throws IOException {
        int min = getMin();
        this.invokeSuspend = 0;
        if (min != 120) {
            ITrustedWebActivityCallback();
        }
        int i = this.invoke.values;
        setRightEyeBlinkRatio setrighteyeblinkratio = new setRightEyeBlinkRatio(i);
        setMin((setRoundColor) setrighteyeblinkratio);
        try {
            int i2 = -1;
            int i3 = length(88, "msg.no.paren.for") ? this.invoke.values - i : -1;
            int min2 = getMin();
            isHasFace ishasface = null;
            if (min2 == 39) {
                this.invokeSuspend = 0;
                ishasface = setMax(false, 39);
            } else if (min2 == 84 || min2 == 86) {
                ishasface = mayLaunchUrl();
                getMax(ishasface);
            } else {
                getMax("msg.bad.var", (String) null);
            }
            if (ishasface.length() == 39) {
                length(154, this.invoke.setMin, true);
            }
            int i4 = length(52, "msg.in.after.for.name") ? this.invoke.values - i : -1;
            isHasFace extraCallbackWithResult = extraCallbackWithResult();
            if (length(89, "msg.no.paren.for.ctrl")) {
                i2 = this.invoke.values - i;
            }
            setrighteyeblinkratio.equals(this.invoke.toString - i);
            setrighteyeblinkratio.getMin(ishasface);
            setrighteyeblinkratio.setMax(extraCallbackWithResult);
            setrighteyeblinkratio.toIntRange(i4);
            setrighteyeblinkratio.getMin(i3, i2);
            return setrighteyeblinkratio;
        } finally {
            this.toIntRange = this.toIntRange.asInterface();
        }
    }

    private void getMin(WaveView waveView) {
        isHasFace ishasface = waveView.equals;
        while (ishasface instanceof PromptTextView.AnonymousClass1) {
            ishasface = ((PromptTextView.AnonymousClass1) ishasface).equals;
        }
        int length2 = ishasface.length();
        if (length2 != 39 && length2 != 33 && length2 != 36 && length2 != 68 && length2 != 38) {
            getMax(waveView.length() == 107 ? "msg.bad.incr" : "msg.bad.decr", (String) null);
        }
    }

    private boolean getMax(setFaceId setfaceid, int i, String str, LogFactory logFactory, List<String> list) {
        setFaceId setfaceid2 = setfaceid;
        int i2 = i;
        String str2 = str;
        LogFactory logFactory2 = logFactory;
        int i3 = i2 == 155 ? 156 : 8;
        boolean z = true;
        int i4 = 0;
        for (isHasFace next : setfaceid2.toFloatRange != null ? setfaceid2.toFloatRange : setFaceId.equals) {
            if (next.length() == 129) {
                i4++;
            } else {
                getMin(str2, 39);
                LogFactory logFactory3 = new LogFactory(36, LogFactory.length(39, str2), LogFactory.getMin((double) i4));
                if (next.length() == 39) {
                    String str3 = ((CircleFrameLayout.WidgetListener) next).equals;
                    getMin(str3, 39);
                    LogFactory length2 = LogFactory.length(39, str3);
                    length2.setMax(49);
                    logFactory2.getMax(new LogFactory(i3, length2, logFactory3));
                    if (i2 != -1) {
                        length(i2, str3, true);
                        list.add(str3);
                    } else {
                        List<String> list2 = list;
                    }
                } else {
                    List<String> list3 = list;
                    getCricleColor getcriclecolor = this.setMin;
                    StringBuilder sb = new StringBuilder("$");
                    int i5 = getcriclecolor.setDefaultImpl;
                    getcriclecolor.setDefaultImpl = i5 + 1;
                    sb.append(i5);
                    logFactory2.getMax(getMax(i2, next, logFactory3, sb.toString()));
                }
                i4++;
                z = false;
            }
        }
        return z;
    }

    private boolean setMin(LoadingProgressDialog loadingProgressDialog, int i, String str, LogFactory logFactory, List<String> list) {
        LogFactory logFactory2;
        int i2 = i == 155 ? 156 : 8;
        boolean z = true;
        for (setAnimationInterval next : loadingProgressDialog.isInside != null ? loadingProgressDialog.isInside : LoadingProgressDialog.toFloatRange) {
            switchOn switchon = this.invoke;
            int i3 = switchon != null ? switchon.isInside : 0;
            isHasFace Grayscale$Algorithm2 = next.Grayscale$Algorithm();
            if (Grayscale$Algorithm2 instanceof CircleFrameLayout.WidgetListener) {
                LogFactory min = LogFactory.getMin(((CircleFrameLayout.WidgetListener) Grayscale$Algorithm2).equals);
                getMin(str, 39);
                logFactory2 = new LogFactory(33, LogFactory.length(39, str), min);
            } else if (Grayscale$Algorithm2 instanceof paintStroke) {
                LogFactory min2 = LogFactory.getMin(((paintStroke) Grayscale$Algorithm2).toFloatRange);
                getMin(str, 39);
                logFactory2 = new LogFactory(33, LogFactory.length(39, str), min2);
            } else if (Grayscale$Algorithm2 instanceof setEnable) {
                LogFactory min3 = LogFactory.getMin((double) ((int) ((setEnable) Grayscale$Algorithm2).toIntRange));
                getMin(str, 39);
                logFactory2 = new LogFactory(36, LogFactory.length(39, str), min3);
            } else {
                throw ITrustedWebActivityCallback();
            }
            logFactory2.setMin(i3);
            isHasFace invokeSuspend2 = next.invokeSuspend();
            if (invokeSuspend2.length() == 39) {
                String str2 = ((CircleFrameLayout.WidgetListener) invokeSuspend2).equals;
                getMin(str2, 39);
                LogFactory length2 = LogFactory.length(39, str2);
                length2.setMax(49);
                logFactory.getMax(new LogFactory(i2, length2, logFactory2));
                if (i != -1) {
                    length(i, str2, true);
                    list.add(str2);
                }
            } else {
                getCricleColor getcriclecolor = this.setMin;
                StringBuilder sb = new StringBuilder("$");
                int i4 = getcriclecolor.setDefaultImpl;
                getcriclecolor.setDefaultImpl = i4 + 1;
                sb.append(i4);
                logFactory.getMax(getMax(i, invokeSuspend2, logFactory2, sb.toString()));
            }
            z = false;
        }
        return z;
    }
}
